<!DOCTYPE html>

<html lang="en">
<head>
<link href="favicon.ico" rel="icon" type="image/x-icon"/>
<meta charset="utf-8"/>
<title>Legend of III Game Web Interface</title>
<style>
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: #202124;
      color: #eee;
      margin: 0;
      padding: 0;
    }
    #container {
      display: grid;
      grid-template-columns: 420px 1fr 420px;
      gap: 18px;
      padding: 26px;
      max-width: 2200px;
      margin: auto;
    }
    #explore-bar {
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 28px;
      margin-top: 10px;
    }
    #explore-btn-top {
      background: #ffba3a;
      color: #23252a;
      border-radius: 12px;
      border: none;
      padding: 14px 52px;
      font-weight: bold;
      font-size: 1.47em;
      cursor: pointer;
      box-shadow: 0 2px 14px #0006;
      letter-spacing: 1.5px;
      transition: background 0.18s, color 0.18s;
    }
    #explore-btn-top:hover {
      background: #ffd36b;
      color: #111;
    }
    #direction-select-bar {
      display: none;
      justify-content: center;
      align-items: center;
      margin-bottom: 18px;
      gap: 10px;
    }
    #direction-select-bar.active {
      display: flex;
    }
    .direction-btn {
      background: #35373e;
      color: #ffba3a;
      border: none;
      border-radius: 8px;
      padding: 10px 22px;
      font-weight: bold;
      font-size: 1.1em;
      cursor: pointer;
      margin: 0 4px;
      transition: background 0.17s;
    }
    .direction-btn:hover {
      background: #ffba3a;
      color: #23252a;
    }
    #left-col {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .panel {
      background: #292c31;
      border-radius: 10px;
      padding: 16px;
      box-shadow: 0 2px 10px #000a;
      margin-bottom: 0;
      min-width: 370px;
    }
    .panel h2 {
      margin-top: 0;
      color: #ffba3a;
      font-size: 1.19em;
      letter-spacing: 1px;
      margin-bottom: 9px;
      text-shadow: 0 0 3px #222, 0 2px 1px #1919195c;
    }
    #player-stats-ul {
      list-style: none; margin: 0; padding: 0;
      font-size: 1.05em;
    }
    #player-stats-ul li { margin-bottom: 3px; }
    .gold { color: gold; }
    .health { color: #90ee90; }
    .level { color: #61dafb; }
    #equipment-panel {
      position: relative;
      overflow: visible;
      padding-bottom: 0;
    }
    #equipment-ui {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: flex-start;
      gap: 10px;
      min-height: 320px;
      margin-bottom: 10px;
    }
    .equipment-side {
      display: flex;
      flex-direction: column;
      gap: 35px;
      min-width: 150px;
    }
    .equipment-side.left {
      align-items: flex-end;
    }
    .equipment-side.right {
      align-items: flex-start;
    }
#char-portrait-box {
  width: 100%;
  max-width: 320px;
  height: 40vw; /* Or another value that fits nicely */
  max-height: 480px;
}

#char-portrait {
  width: 100%;
  height: 100%;
}
    .equip-slot {
      width: 150px;
      height: 48px;
      margin: 5px 0;
      background: #23252a;
      border-radius: 6px;
      border: 2.5px solid #353841;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      position: relative;
      cursor: pointer;
      transition: border-color 0.2s;
      font-size: 1.12em;
      color: #ffba3a;
      font-weight: bold;
      padding-left: 14px;
      overflow: visible;
      min-width: 150px;
      max-width: 180px;
      white-space: nowrap;
    }
    .equip-slot.selected, .equip-slot:hover {
      border-color: #ffba3a;
      box-shadow: 0 0 6px #ffba3a90;
      z-index: 4;
    }
    .equip-slot .slot-tooltip {
      display: none;
      position: absolute;
      left: 110%;
      top: 50%;
      transform: translateY(-50%);
      background: #18191c;
      color: #eee;
      padding: 10px 16px;
      border-radius: 10px;
      border: 1.5px solid #444;
      white-space: nowrap;
      font-size: 1.05em;
      box-shadow: 0 2px 12px #0007;
      z-index: 10;
      pointer-events: none;
      min-width: 180px;
    }
    .equip-slot:hover .slot-tooltip {
      display: block;
    }
    #equipment-legend {
      margin-top: 14px;
      color: #aaa;
      font-size: 1.05em;
      text-align: center;
    }
    #baginv-panel {
      min-height: 155px;
    }
    #baginv-tabs {
      display: flex;
      gap: 7px;
      margin-bottom: 12px;
    }
    .baginv-tab {
      font-weight: 600;
      font-size: 1em;
      border: none;
      background: #23252a;
      color: #fff;
      border-radius: 6px 6px 0 0;
      padding: 7px 20px;
      cursor: pointer;
      transition: background 0.22s, color 0.22s;
      outline: none;
      border-bottom: 2px solid transparent;
    }
    .baginv-tab.active, .baginv-tab:hover {
      background: #34373e;
      color: #ffba3a;
      border-bottom: 2px solid #ffba3a;
    }
    #baginv-content {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      min-height: 70px;
      margin-bottom: 2px;
      justify-content: flex-start;
    }
    .item-card {
      background: #23252a;
      border-radius: 7px;
      border: 2px solid #353841;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 7px 10px 7px 10px;
      width: 110px;
      cursor: pointer;
      position: relative;
      transition: border-color 0.18s;
      min-height: 85px;
      font-size: 1em;
      color: #ffba3a;
      font-weight: bold;
      justify-content: center;
      word-break: break-word;
      max-width: 140px;
    }
    .item-card.selected, .item-card:hover {
      border-color: #ffba3a;
      box-shadow: 0 0 7px #ffba3a7c;
      z-index: 5;
    }
    .item-name {
      font-size: 1em;
      color: #fff;
      text-align: center;
      margin-bottom: 2.5px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: normal;
      width: 100%;
      max-width: 120px;
      word-break: break-word;
    }
    .item-actions {
      display: flex;
      gap: 3px;
      margin-top: 1px;
    }
    .item-action-btn {
      font-size: 0.98em;
      border: none;
      background: #35373e;
      color: #fff;
      border-radius: 4px;
      padding: 2px 8px;
      cursor: pointer;
      margin: 0 1px;
      transition: background 0.14s;
    }
    .item-action-btn:hover {
      background: #ffba3a;
      color: #101015;
    }
    .bag-x-remove-btn {
      position: absolute;
      top: 3px;
      left: 4px;
      background: #ff4444;
      color: #fff;
      border: none;
      border-radius: 50%;
      font-size: 1.05em;
      width: 22px;
      height: 22px;
      cursor: pointer;
      z-index: 7;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.12s;
    }
    .bag-x-remove-btn:hover {
      background: #ff0000;
      color: #fff;
    }
    .bag-equip-btn {
      margin-top: 2px;
      font-size: 1.01em;
      border: none;
      background: #35373e;
      color: #fff;
      border-radius: 4px;
      padding: 2px 12px;
      cursor: pointer;
      font-weight: bold;
      width: 90%;
      transition: background 0.14s;
      display: block;
      margin-left: auto;
      margin-right: auto;
    }
    .bag-equip-btn:hover {
      background: #ffba3a;
      color: #101015;
    }
    #center-col {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: start;
      position: relative;
      min-height: 520px;
    }
    #enemy-encounter {
      display: none;
      align-items: center;
      flex-direction: column;
      justify-content: center;
      min-height: 450px;
      width: 355px;
      background: #1b1c23;
      border-radius: 14px;
      box-shadow: 0 4px 28px #000a;
      margin-top: 24px;
      margin-bottom: 18px;
      position: relative;
      z-index: 12;
      border: 2.5px solid #3d3b2f;
      animation: popin 0.38s;
    }
    #chest-encounter {
      display: none;
      align-items: center;
      flex-direction: column;
      justify-content: center;
      min-height: 220px;
      width: 355px;
      background: #1b1c23;
      border-radius: 14px;
      box-shadow: 0 4px 28px #000a;
      margin-top: 24px;
      margin-bottom: 18px;
      position: relative;
      z-index: 13;
      border: 2.5px solid #3d3b2f;
      animation: popin 0.38s;
    }
    #chest-encounter h3 {
      color: #ffba3a;
      margin-top: 18px;
      margin-bottom: 10px;
      font-size: 1.3em;
    }
    #chest-encounter .chest-reward {
      color: gold;
      font-size: 1.2em;
      margin-bottom: 12px;
    }
    #chest-encounter .chest-btn {
      background: #ffba3a;
      color: #23252a;
      border-radius: 10px;
      border: none;
      padding: 10px 32px;
      font-weight: bold;
      font-size: 1.1em;
      cursor: pointer;
      margin-top: 10px;
      transition: background 0.18s, color 0.18s;
    }
    #chest-encounter .chest-btn:hover {
      background: #ffd36b;
      color: #111;
    }
    @keyframes popin {
      0% { opacity: 0; transform: scale(0.82);}
      100% { opacity: 1; transform: scale(1);}
    }
    #enemy-health-top {
      margin-top: 12px;
      margin-bottom: 0;
      width: 130px;
      margin-left: auto;
      margin-right: auto;
      display: block;
    }
    #enemy-hp-bar {
      width: 110px;
      height: 16px;
      background: #2d2222;
      border-radius: 7px;
      border: 1px solid #555;
      margin: 0 7px 0 0;
      position: relative;
      overflow: hidden;
      display: inline-block;
      vertical-align: middle;
    }
    #enemy-hp-bar-inner {
      background: linear-gradient(90deg, #ff6060 60%, #ffd700 100%);
      height: 100%;
      transition: width 0.22s;
      border-radius: 7px;
      position: absolute; left: 0; top: 0;
    }
    #enemy-hp-bar-text {
      color: #fff;
      font-size: 0.95em;
      position: absolute;
      width: 100%;
      text-align: center;
      left: 0; top: 0;
      pointer-events: none;
      text-shadow: 0 0 3px #000;
    }
    #attack-label {
      font-family: 'Oswald', 'Segoe UI', Arial, sans-serif;
      font-weight: bold;
      color: #ffba3a;
      text-shadow: 0 2px 6px #000, 0 0 2px #fff8;
      font-size: 2.1em;
      letter-spacing: 2px;
      margin-bottom: 0;
      text-align: center;
      margin-top: 6px;
      margin-bottom: 5px;
      user-select: none;
    }
    #enemy-image {
      width: 158px;
      height: 158px;
      margin: 25px auto 5px auto;
      background: #23252a;
      border-radius: 10px;
      box-shadow: 0 2px 14px #0007, 0 0 8px #ff55552a;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      border: 2px solid #444;
      z-index: 2;
      font-size: 1.44em;
      color: #ffba3a;
      font-weight: bold;
      text-align: center;
      justify-content: center;
    }
    #enemy-name-label {
      font-size: 1.05em;
      font-weight: bold;
      color: #ffba3a;
      text-align: center;
      margin-bottom: 10px;
    }
    #enemy-controls {
      margin: 8px 0 19px 0;
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 19px;
      justify-content: center;
    }
    .enemy-action-btn {
      font-size: 1.04em;
      border: none;
      background: #35373e;
      color: #fff;
      border-radius: 7px;
      padding: 4px 18px;
      cursor: pointer;
      font-weight: bold;
      transition: background 0.19s;
      margin: 0 2px;
      min-width: 78px;
    }
    .enemy-action-btn#attack-enemy-btn {
      order: -1;
      margin-right: 10px;
    }
    .enemy-action-btn#run-enemy-btn {
      order: 1;
    }
    .enemy-action-btn:hover { background: #ffba3a; color: #191717;}
    .hitsplat {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      top: 14px;
      background: #ff4444;
      color: #fff;
      font-weight: bold;
      padding: 4px 16px;
      border-radius: 11px;
      font-size: 1.3em;
      box-shadow: 0 1px 6px #a00a;
      opacity: 0.93;
      animation: splat 0.9s cubic-bezier(.59,.22,.44,1.36);
      pointer-events: none;
      z-index: 5;
      border: 2.2px solid #fff3;
    }
    @keyframes splat {
      0% { top: 34px; opacity: 0.01;}
      17% { opacity: 1;}
      50% { top: -16px; opacity: 0.95;}
      90% { opacity: 0.95;}
      100% { top: -32px; opacity: 0;}
    }
    #right-col {
      display: flex;
      flex-direction: column;
      gap: 16px;
      min-width:650px;
    }
    /* --- GAME MAP OVERHAUL --- */
    #map-panel {
      padding-bottom: 9px;
    }
    #map-container {
      background: linear-gradient(135deg, #23252a 60%, #18191c 100%);
      border-radius: 18px;
      border: 3px solid #444;
      width: 700px;
      min-width: 700px;
      max-width: 100vw;
      margin: 0 auto;
      padding: 18px 0 12px 0;
      box-shadow: 0 0 24px #000a, 0 2px 18px #23252a88;
      position: relative;
      overflow: visible;
    }
    #map-container::before {
      content: "";
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
      border-radius: 18px;
      box-shadow: 0 0 80px #ffba3a22, 0 0 120px #3887e022 inset;
      z-index: 1;
    }
    #map-index {
      display: flex;
      flex-wrap: wrap;
      gap: 10px 18px;
      margin: 10px 0 18px 0;
      justify-content: center;
      font-size: 1.05em;
      position: relative;
      z-index: 2;
      background: #23252a88;
      border-radius: 8px;
      padding: 6px 0;
      box-shadow: 0 1px 8px #0003;
    }
    .map-index-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-weight: bold;
      filter: drop-shadow(0 0 2px #0008);
    }
    .map-index-color {
      display: inline-block;
      width: 18px;
      height: 18px;
      border-radius: 4px;
      border: 2px solid #444;
      margin-right: 4px;
      vertical-align: middle;
      box-shadow: 0 0 6px #0006;
    }
    #game-map {
      display: grid;
      grid-template-columns: repeat(18, 34px);
      grid-template-rows: repeat(18, 34px);
      gap: 3px;
      background: linear-gradient(120deg, #23252a 80%, #18191c 100%);
      border-radius: 14px;
      border: 2.5px solid #444;
      width: 646px;
      min-width: 646px;
      max-width: 100vw;
      margin: auto;
      box-shadow: 0 0 24px #000a, 0 2px 18px #23252a88;
      position: relative;
      z-index: 2;
      overflow: visible;
    }
    .map-cell {
      width: 34px;
      height: 34px;
      background: #222;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1em;
      color: #fff;
      position: relative;
      overflow: visible;
      border: 1.5px solid #292c31;
      font-weight: bold;
      text-align: center;
      cursor: pointer;
      transition: background 0.18s, color 0.18s, box-shadow 0.18s;
      user-select: none;
      box-shadow: 0 0 8px #0004;
      filter: drop-shadow(0 0 2px #0008);
    }
    .map-cell.player {
      outline: 3px solid #ffe066;
      z-index: 3;
      box-shadow: 0 0 18px #ffe06699, 0 0 8px #fff;
      animation: playerPulse 1.2s infinite alternate;
    }
    @keyframes playerPulse {
      0% { box-shadow: 0 0 18px #ffe06699, 0 0 8px #fff; }
      100% { box-shadow: 0 0 32px #ffe066cc, 0 0 16px #fff; }
    }
    .map-cell.central-town {
      background: radial-gradient(circle at 60% 40%, #e53935 80%, #a00 100%);
      color: #fff;
      font-weight: bold;
      box-shadow: 0 0 18px #e5393593, 0 0 8px #fff3;
      z-index: 2;
      border: 2px solid #e53935;
      animation: townGlow 1.5s infinite alternate;
    }
    @keyframes townGlow {
      0% { box-shadow: 0 0 18px #e5393593, 0 0 8px #fff3; }
      100% { box-shadow: 0 0 32px #e53935cc, 0 0 16px #fff6; }
    }
    .map-cell.town {
      background: radial-gradient(circle at 60% 40%, #3887e0 80%, #1a4a8a 100%);
      color: #fff;
      font-weight: bold;
      box-shadow: 0 0 18px #3887e093, 0 0 8px #fff3;
      z-index: 2;
      border: 2px solid #3887e0;
      animation: townGlow 1.5s infinite alternate;
    }
    .map-cell.area {
      background: linear-gradient(135deg, #ffe066 80%, #bfae44 100%);
      color: #23252a;
      font-weight: bold;
      border: 1.5px solid #ffe066;
      box-shadow: 0 0 8px #ffe06644;
    }
    .map-cell.discovered {
      background: linear-gradient(135deg, #2e7d32 80%, #90ee90 100%);
      color: #fff;
      border: 1.5px solid #2e7d32;
      box-shadow: 0 0 8px #2e7d3244;
      animation: discoveredPulse 1.2s infinite alternate;
    }
    @keyframes discoveredPulse {
      0% { box-shadow: 0 0 8px #2e7d3244; }
      100% { box-shadow: 0 0 16px #90ee9099; }
    }
    .map-cell.chest {
      background: linear-gradient(135deg, #bfae44 80%, #ffe066 100%);
      color: #23252a;
      border: 2px solid #bfae44;
      box-shadow: 0 0 18px #bfae44cc, 0 0 8px #ffe06666;
      animation: chestPulse 1.2s infinite alternate;
    }
    @keyframes chestPulse {
      0% { box-shadow: 0 0 18px #bfae44cc, 0 0 8px #ffe06666; }
      100% { box-shadow: 0 0 32px #ffe066cc, 0 0 16px #bfae44cc; }
    }
    .map-cell.undiscovered {
      background: repeating-linear-gradient(135deg, #444 0 8px, #23252a 8px 16px);
      color: #888;
      font-style: italic;
      border: 1.5px dashed #444;
      box-shadow: 0 0 4px #444;
      filter: grayscale(0.7);
    }
    /* --- Overlay Effects --- */
    #game-map::before {
      content: "";
      position: absolute;
      left: -12px; top: -12px; right: -12px; bottom: -12px;
      pointer-events: none;
      border-radius: 18px;
      box-shadow: 0 0 80px #ffba3a22, 0 0 120px #3887e022 inset;
      z-index: 1;
    }
    #game-map::after {
      content: "";
      position: absolute;
      left: 0; top: 0; right: 0; bottom: 0;
      pointer-events: none;
      border-radius: 14px;
     
      opacity: 0.08;
      z-index: 2;
      mix-blend-mode: lighten;
    }
    /* --- Map Cell Hover/Selection --- */
    .map-cell:hover {
      box-shadow: 0 0 24px #ffba3a99, 0 0 12px #fff;
      border-color: #ffba3a;
      z-index: 10;
      transform: scale(1.08);
    }
    .map-cell.player:hover {
      outline: 3px solid #fff;
      box-shadow: 0 0 32px #ffe066cc, 0 0 16px #fff;
    }
    /* --- Map Controls --- */
    #map-controls {
      text-align: center;
      margin-top: 8px;
      z-index: 3;
      position: relative;
    }
    .map-move-btn {
      margin: 2px 8px;
      background: linear-gradient(135deg, #35373e 80%, #23252a 100%);
      color: #eee;
      border: none;
      border-radius: 6px;
      padding: 6px 16px;
      cursor: pointer;
      font-size: 1.18em;
      font-weight: bold;
      box-shadow: 0 2px 8px #0004;
      transition: background 0.18s, color 0.18s, box-shadow 0.18s;
    }
    .map-move-btn:hover {
      background: #ffba3a;
      color: #23252a;
      box-shadow: 0 0 12px #ffba3a99;
    }
    #map-area-label {
      margin-top: 12px;
      font-size: 1.08em;
      color: #ffba3a;
      text-align: center;
      font-weight: bold;
      letter-spacing: 1px;
      text-shadow: 0 0 6px #23252a88;
      background: #23252a88;
      border-radius: 8px;
      padding: 4px 0;
      box-shadow: 0 1px 8px #0003;
      z-index: 2;
      position: relative;
    }
    /* --- Mini animated overlays for map --- */
    #map-container .map-overlay-effect {
      position: absolute;
      pointer-events: none;
      z-index: 10;
      left: 0; top: 0; width: 100%; height: 100%;
      border-radius: 18px;
      mix-blend-mode: lighten;
      opacity: 0.18;
      animation: mapOverlayAnim 6s linear infinite;
      
    }
    @keyframes mapOverlayAnim {
      0% { background-position: 0 0; }
      100% { background-position: 120px 80px; }
    }
    /* --- Responsive --- */
    @media (max-width: 1100px) {
      #map-container { width: 370px; min-width: 370px; }
      #game-map { grid-template-columns: repeat(18, 18px); grid-template-rows: repeat(18, 18px); width: 342px; min-width: 342px; }
      .map-cell { width: 18px; height: 18px; font-size: 0.55em; }
    
    }
    #bank-panel {
      margin-top: 6px;
      margin-bottom: 0;
      padding-bottom: 10px;
    }
    #bank-open-btn {
      background: #35373e;
      color: #ffba3a;
      border-radius: 8px;
      border: none;
      padding: 6px 20px;
      font-weight: 600;
      font-size: 1.08em;
      cursor: pointer;
      margin: 0 auto 5px auto;
      display: block;
      transition: background 0.17s;
    }
    #bank-open-btn:hover {
      background: #ffba3a;
      color: #26221c;
    }
    #bank-modal-bg {
      display: none;
      position: fixed;
      z-index: 1200;
      top: 0; left: 0; width: 100vw; height: 100vh;
      background: #18191cbb;
      align-items: center;
      justify-content: center;
    }
    #bank-modal {
      background: #23252a;
      border-radius: 18px;
      box-shadow: 0 0 44px #000c, 0 5px 32px #2b2a2a45;
      padding: 32px 29px 24px 29px;
      min-width: 450px;
      min-height: 320px;
      position: relative;
      z-index: 1211;
      display: flex;
      flex-direction: column;
    }
    #bank-modal h2 {
      margin-bottom: 10px;
      color: #ffba3a;
    }
    #bank-close-btn {
      position: absolute; top: 12px; right: 16px;
      font-size: 1.38em;
      background: none;
      border: none;
      color: #fff;
      cursor: pointer;
    }
    #bank-content {
      display: flex;
      flex-direction: row;
      gap: 32px;
      margin-top: 14px;
      justify-content: center;
      align-items: flex-start;
    }
    .bank-section {
      min-width: 180px;
    }
    .bank-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 110px;
    }
    .bank-item-card {
      display: flex;
      align-items: center;
      gap: 8px;
      background: #18191c;
      border-radius: 7px;
      border: 1px solid #444;
      padding: 4px 8px;
      font-size: 0.97em;
      min-width: 120px;
      min-height: 36px;
      color: #ffba3a;
      font-weight: bold;
    }
    .bank-action-btn {
      background: #35373e;
      color: #ffba3a;
      border: none;
      border-radius: 5px;
      padding: 2px 10px;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.98em;
      margin-left: 6px;
      transition: background 0.14s;
    }
    .bank-action-btn:hover { background: #ffba3a; color: #26221c;}
    #bank-empty-msg { color: #888; font-size: 0.95em; text-align: center; margin-top: 13px; }
    #log-panel {
      min-height: 130px;
      margin-top: 7px;
      grid-column:1/4;
      max-width:none;
      width:100%;
      margin-top:24px;
    }
    #game-log {
      height: 142px;
      overflow-y: auto;
      background: #181818;
      padding: 7px 7px;
      border-radius: 4px;
      font-size: 0.99em;
      font-family: 'Fira Mono', 'Consolas', monospace;
      max-height: 142px;
      border: 1.2px solid #333;
      margin-bottom: 1px;
    }
    #derived-stats-panel {
      margin-top: 0;
      margin-bottom: 0;
      padding-bottom: 5px;
    }
    #derived-stats-list {
      list-style: none; margin: 0; padding: 0; font-size: 1em;
    }
    #derived-stats-list li { margin-bottom: 3px; }
    .derived-label { color: #ffba3a; font-weight: bold; margin-right: 5px;}
    #left-col #derived-stats-panel {
      order: 4;
      margin-top: 0;
      margin-bottom: 0;
      min-width: 310px;
    }
    #right-col #derived-stats-panel {
      display: none !important;
    }
    #actions-panel .action-btn:first-child {
      display: none !important;
    }
    @media (max-width: 1400px) {
      #container { grid-template-columns: 1fr; grid-template-rows: auto; }
      #left-col, #right-col { min-width: 175px; }
      #center-col { min-width: 280px;}
      #explore-bar { margin-bottom: 10px; }
      #map-container { width: 370px; min-width: 370px; }
      #game-map { grid-template-columns: repeat(18, 18px); grid-template-rows: repeat(18, 18px); width: 342px; min-width: 342px; }
      #map-index { font-size: 0.85em; }
      .map-index-color { width: 12px; height: 12px; }
    }
    /* Update these styles in your <style> section */
#map-container {
  background: #1a1b1e;
  border-radius: 9px;
  border: 2px solid #444;
  width: 620px; /* 18*32px + 17*2px gap + padding */
  min-width: 620px;
  max-width: 100vw;
  margin: 0 auto;
  padding: 7px 0 4px 0;
  box-shadow: 0 0 8px #0007;
  position: relative;
}

#game-map {
  display: grid;
  grid-template-columns: repeat(18, 32px);
  grid-template-rows: repeat(18, 32px);
  gap: 2px;
  background: #23252a;
  border-radius: 7px;
  border: 2px solid #444;
  width: 596px; /* 18*32px + 17*2px gap */
  min-width: 596px;
  max-width: 100vw;
  margin: auto;
}

.map-cell {
  width: 32px;
  height: 32px;
  background: #222;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.75em;
  color: #fff;
  position: relative;
  overflow: hidden;
  border: 1px solid #292c31;
  font-weight: bold;
  text-align: center;
  cursor: pointer;
  transition: background 0.18s, color 0.18s;
  user-select: none;
}

/* Responsive: shrink map for small screens */
@media (max-width: 1100px) {
  #map-container { width: 370px; min-width: 370px; }
  #game-map { grid-template-columns: repeat(18, 18px); grid-template-rows: repeat(18, 18px); width: 342px; min-width: 342px; }
  .map-cell { width: 18px; height: 18px; font-size: 0.55em; }
}
    .panel-draggable-handle {
      cursor: grab;
      background: #191a1e;
      color: #ffba3a;
      font-weight: bold;
      padding: 4px 0 4px 10px;
      border-radius: 8px 8px 0 0;
      user-select: none;
      margin: -16px -18px 8px -18px;
      font-size: 1.05em;
      letter-spacing: 1px;
    }
    .panel.dragging {
      opacity: 0.6;
    }
    .drop-target {
      outline: 3px dashed #ffba3a;
      background: #23252a44;
    }
    #username-overlay {
      position: fixed;
      z-index: 3000;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #191a1e;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #username-overlay > div {
      background: #23252a;
      padding: 38px 44px 32px 44px;
      border-radius: 18px;
      box-shadow: 0 2px 24px #000a;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #username-overlay h2 {
      color: #ffba3a;
      margin-bottom: 18px;
    }
    #username-input {
      font-size: 1.2em;
      padding: 8px 18px;
      border-radius: 7px;
      border: 1.5px solid #444;
      background: #18191c;
      color: #fff;
      margin-bottom: 18px;
      width: 220px;
      outline: none;
    }
    #username-submit {
      font-size: 1.1em;
      font-weight: bold;
      background: #ffba3a;
      color: #23252a;
      border: none;
      border-radius: 7px;
      padding: 8px 32px;
      cursor: pointer;
    }
    #username-error {
      color: #ff4444;
      margin-top: 10px;
      display: none;
      font-size: 1em;
    }
    #overlay-save-load-ui {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 18px;
    }
    #overlay-save-btn {
      font-weight: bold;
      font-size: 1em;
      background: #ffba3a;
      color: #23252a;
      border: none;
      border-radius: 6px;
      padding: 6px 18px;
      cursor: pointer;
    }
    #overlay-load-btn {
      font-weight: bold;
      font-size: 1em;
      background: #35373e;
      color: #ffba3a;
      border: none;
      border-radius: 6px;
      padding: 6px 18px;
      cursor: pointer;
      display: none;
    }
    #overlay-save-list {
      display: none;
      margin-left: 8px;
      font-size: 1em;
      padding: 4px 8px;
      border-radius: 5px;
    }
    /* --- ADDED STYLES FOR SAVE/LOAD UI --- */
    #main-save-ui {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 2100;
      background: #23252a;
      border-radius: 10px;
      padding: 8px 16px;
      box-shadow: 0 2px 12px #0007;
      display: flex;
      gap: 8px;
      align-items: center;
    }
    #overlay-load-delete-ui {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 18px;
    }
    #overlay-delete-btn {
      font-weight: bold;
      font-size: 1em;
      background: #ff4444;
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 6px 18px;
      cursor: pointer;
      display: none;
    }
    #delete-save-ui {
      display: none;
      flex-direction: column;
      align-items: center;
      margin-bottom: 10px;
    }
    #delete-save-list {
      margin-bottom: 8px;
      font-size: 1em;
      padding: 4px 8px;
      border-radius: 5px;
    }
    #confirm-delete-btn {
      background: #ff4444;
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 6px 18px;
      cursor: pointer;
    }
    #flame-bg {
      position: fixed;
      top: 0; left: 0; width: 100vw; height: 100vh;
      z-index: 0;
      pointer-events: none;
      display: block;
      background: #191a1e;
    }
    body > *:not(#flame-bg) {
      position: relative;
      z-index: 1;
    }
  </style>
</head>
<body style="margin:0;padding:0;">
<canvas id="flame-bg"></canvas>
<!-- Save button in main UI, top left -->
<div id="main-save-ui" style="position:fixed;top:10px;left:10px;z-index:2100;background:#23252a;border-radius:10px;padding:8px 16px;box-shadow:0 2px 12px #0007;display:flex;gap:8px;align-items:center;">
  <button id="main-save-btn" style="font-weight:bold;font-size:1em;background:#ffba3a;color:#23252a;border:none;border-radius:6px;padding:6px 18px;cursor:pointer;">Save</button>
  <button id="main-load-btn" style="font-weight:bold;font-size:1em;background:#35373e;color:#ffba3a;border:none;border-radius:6px;padding:6px 18px;cursor:pointer;">Load Save State</button>
  <input type="file" id="main-load-input" accept=".json,application/json" style="display:none;">
</div>
<!-- Username overlay with load/delete only -->
<div id="username-overlay" style="position:fixed;z-index:3000;top:0;left:0;width:100vw;height:100vh;background:#191a1e;display:flex;align-items:center;justify-content:center;">
  <div style="background:#23252a;padding:38px 44px 32px 44px;border-radius:18px;box-shadow:0 2px 24px #000a;display:flex;flex-direction:column;align-items:center;">
    <!-- Audio upload section -->
    <label for="audio-upload" style="margin-bottom:10px;">
      <input type="file" id="audio-upload" accept="audio/mp3,audio/mpeg" style="display:none;" />
      <button id="upload-audio-btn" type="button" style="font-weight:bold;font-size:1em;background:#35373e;color:#ffba3a;border:none;border-radius:6px;padding:6px 18px;cursor:pointer;">Background Music</button>
      <span id="audio-upload-filename" style="color:#aaa;font-size:0.98em;margin-left:8px;"></span>
    </label>
    <div style="display:flex;gap:8px;margin-bottom:10px;">
      <button id="play-audio" disabled style="font-weight:bold;font-size:1em;background:#35373e;color:#ffba3a;border:none;border-radius:6px;padding:6px 18px;cursor:pointer;">Play</button>
      <button id="stop-audio" disabled style="font-weight:bold;font-size:1em;background:#ff4444;color:#fff;border:none;border-radius:6px;padding:6px 18px;cursor:pointer;">Stop</button>
    </div>
    <audio id="uploaded-audio" loop style="display:none;"></audio>
    <script>
      const uploadInput = document.getElementById('audio-upload');
      const uploadBtn = document.getElementById('upload-audio-btn');
      const audio = document.getElementById('uploaded-audio');
      const playBtn = document.getElementById('play-audio');
      const stopBtn = document.getElementById('stop-audio');
      const fileNameSpan = document.getElementById('audio-upload-filename');
      let audioLoaded = false;

      uploadBtn.onclick = function() {
        uploadInput.click();
      };

      uploadInput.addEventListener('change', function() {
        const file = uploadInput.files[0];
        if (file && (file.type === "audio/mp3" || file.type === "audio/mpeg")) {
          const url = URL.createObjectURL(file);
          audio.src = url;
          audioLoaded = true;
          playBtn.disabled = false;
          stopBtn.disabled = false;
          audio.style.display = "block";
          fileNameSpan.textContent = file.name;
        } else {
          alert("Please select a valid MP3 file.");
          playBtn.disabled = true;
          stopBtn.disabled = true;
          audioLoaded = false;
          audio.style.display = "none";
          audio.src = "";
          fileNameSpan.textContent = "";
        }
      });

      playBtn.addEventListener('click', function() {
        if (audioLoaded) {
          audio.play();
        }
      });

      stopBtn.addEventListener('click', function() {
        if (audioLoaded) {
          audio.pause();
          audio.currentTime = 0;
        }
      });

      audio.addEventListener('ended', function() {
        audio.currentTime = 0;
      });
    </script>
    <!-- Space after audio controls -->
    <div style="height:18px;"></div>
    <div id="overlay-load-delete-ui" style="display:flex;gap:8px;align-items:center;margin-bottom:18px;">
      <select id="overlay-save-list" style="display:none;margin-left:8px;font-size:1em;padding:4px 8px;border-radius:5px;"></select>
      <button id="overlay-delete-btn" style="font-weight:bold;font-size:1em;background:#ff4444;color:#fff;border:none;border-radius:6px;padding:6px 18px;cursor:pointer;display:none;">Delete Save</button>
    </div>
    <div id="delete-save-ui" style="display:none;flex-direction:column;align-items:center;margin-bottom:10px;">
      <select id="delete-save-list" style="margin-bottom:8px;font-size:1em;padding:4px 8px;border-radius:5px;"></select>
      <button id="confirm-delete-btn" style="background:#ff4444;color:#fff;border:none;border-radius:6px;padding:6px 18px;cursor:pointer;">Confirm Delete</button>
    </div>
    <!-- Space before username -->
    <div style="height:18px;"></div>
    <h2 style="color:#ffba3a;margin-bottom:18px;">Enter Username</h2>
    <input autofocus="" id="username-input" maxlength="18" placeholder="Your name..." style="font-size:1.2em;padding:8px 18px;border-radius:7px;border:1.5px solid #444;background:#18191c;color:#fff;margin-bottom:18px;width:220px;outline:none;" type="text"/>
    <button id="username-submit" style="font-size:1.1em;font-weight:bold;background:#ffba3a;color:#23252a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">Start Game</button>
    <div id="username-error" style="color:#ff4444;margin-top:10px;display:none;font-size:1em;"></div>
  </div>
</div>
<script>
  // Load button logic for main UI
  document.getElementById('main-load-btn').onclick = function() {
    document.getElementById('main-load-input').click();
  };
</script>

<div id="explore-bar">
<button id="explore-btn-top" onclick="startExplore()">Explore</button>
</div>
<div id="direction-select-bar">
<span style="color:#ffba3a;font-weight:bold;">Pick a direction:</span>
<button class="direction-btn" onclick="chooseExploreDir(0,-1)">North</button>
<button class="direction-btn" onclick="chooseExploreDir(1,0)">East</button>
<button class="direction-btn" onclick="chooseExploreDir(0,1)">South</button>
<button class="direction-btn" onclick="chooseExploreDir(-1,0)">West</button>
</div>
<div id="container">
<div id="left-col">
<div class="panel" id="player-stats">
<h2>Player Stats</h2>
<ul id="player-stats-ul"></ul>
</div>
<div class="panel" id="equipment">
<h2>Equipment</h2>
<div id="equipment-ui">
<div class="equipment-side left" id="equipment-slots-left"></div>
<div id="char-portrait-box">
<div id="char-portrait"></div>
</div>
<div class="equipment-side right" id="equipment-slots-right"></div>
</div>
<div id="equipment-legend"></div>
</div>
<div class="panel" id="baginv">
<div id="baginv-tabs">
<button class="baginv-tab active" id="tab-inventory" onclick="switchBagInv('inventory')">Inventory</button>
<button class="baginv-tab" id="tab-bag" onclick="switchBagInv('bag')">Bag</button>
</div>
<div id="baginv-content"></div>
</div>
<div class="panel" id="derived-stats">
<h2>Current Stats</h2>
<ul id="derived-stats-list"></ul>
</div>
<div class="panel" id="bank">
<button id="bank-open-btn" onclick="openBank()">Open Bank</button>
</div>
</div>
<div id="center-col">
<div id="enemy-encounter">
<div id="attack-label">ATTACK</div>
<div id="enemy-health-top">
<div id="enemy-hp-bar">
<div id="enemy-hp-bar-inner"></div>
<div id="enemy-hp-bar-text"></div>
</div>
</div>
<div id="enemy-image"></div>
<div id="enemy-name-label"></div>
<div id="enemy-controls">
<button class="enemy-action-btn" id="attack-enemy-btn" onclick="attackEnemy()">Attack</button>
<button class="enemy-action-btn" id="run-enemy-btn" onclick="runFromEnemy()">Run</button>
</div>
</div>
<div id="chest-encounter">
<h3>Chest Found!</h3>
<div class="chest-reward" id="chest-reward"></div>
<button class="chest-btn" onclick="closeChest()">Close</button>
</div>
</div>
<div id="right-col">
<div class="panel" id="map">
<div id="map-container">
<div id="map-index">
<div class="map-index-item"><span class="map-index-color" style="background:#e53935"></span>Central Town</div>
<div class="map-index-item"><span class="map-index-color" style="background:#3887e0"></span>Town</div>
<div class="map-index-item"><span class="map-index-color" style="background:#ffe066"></span>Area (Undiscovered)</div>
<div class="map-index-item"><span class="map-index-color" style="background:#2e7d32"></span>Area (Discovered)</div>
<div class="map-index-item"><span class="map-index-color" style="background:#bfae44"></span>Chest</div>
<div class="map-index-item"><span class="map-index-color" style="background:#444"></span>Unknown</div>
</div>
<div id="game-map"></div>
<div id="map-controls">
<button class="map-move-btn" onclick="movePlayer(-1,0)">⬅️</button>
<button class="map-move-btn" onclick="movePlayer(0,-1)">⬆️</button>
<button class="map-move-btn" onclick="movePlayer(1,0)">➡️</button>
<button class="map-move-btn" onclick="movePlayer(0,1)">⬇️</button>
</div>
<div id="map-area-label"></div>
</div>
</div>
<!-- SHOP PANEL OVERHAUL -->
<div class="panel" id="shop" style="margin-top:18px; position:relative; overflow:visible;">
  <!-- Shop Banner (shown by default) -->
  <div id="shop-banner" style="display:flex;flex-direction:column;align-items:center;justify-content:center;padding:32px 0;">
    <div style="font-size:2em;color:#ffba3a;font-weight:bold;margin-bottom:18px;">Welcome to the Shop</div>
    <button id="open-shop-btn" style="font-size:1.15em;background:#ffba3a;color:#23252a;border:none;border-radius:10px;padding:12px 38px;cursor:pointer;box-shadow:0 2px 14px #0006;font-weight:bold;letter-spacing:1.5px;transition:background 0.18s, color 0.18s;">Open Shop</button>
  </div>
  <!-- Curtain effect overlay (horizontal animation) -->
  <div id="shop-curtain" style="display:none;position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(90deg,#23252a 80%,#ffba3a 100%);z-index:100;pointer-events:none;opacity:1;transition:opacity 1.1s cubic-bezier(.59,.22,.44,1.36);"></div>
  <!-- Shop Items List (hidden by default) -->
  <div id="shop-items-list" style="margin-top:12px;display:none;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:18px;">
    <!-- Shop items will be rendered here -->
  </div>
  <div id="shop-controls" style="display:none;margin-top:12px;">
    <button id="refresh-shop-btn" style="font-size:1em;background:#35373e;color:#ffba3a;border:none;border-radius:6px;padding:6px 18px;cursor:pointer;box-shadow:0 2px 8px #0004;">Refresh</button>
  </div>
  <style>
    #shop {
      position: relative;
    }
    #shop-curtain {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(90deg,#23252a 80%,#ffba3a 100%);
      z-index: 100;
      pointer-events: none;
      opacity: 1;
      transition: opacity 1.1s cubic-bezier(.59,.22,.44,1.36);
      /* For horizontal effect, animate transform: translateX */
      transform: translateX(0);
    }
  </style>
  <script>
    // Shop open logic with horizontal curtain effect
    const shopBanner = document.getElementById('shop-banner');
    const shopCurtain = document.getElementById('shop-curtain');
    const shopItemsList = document.getElementById('shop-items-list');
    const shopControls = document.getElementById('shop-controls');
    const openShopBtn = document.getElementById('open-shop-btn');
    openShopBtn.onclick = function() {
      shopCurtain.style.display = 'block';
      shopCurtain.style.opacity = '1';
      shopCurtain.style.transform = 'translateX(0)';
      // Animate curtain sliding to the right (horizontal)
      const anim = shopCurtain.animate([
        { opacity: 1, transform: 'translateX(0)' },
        { opacity: 1, transform: 'translateX(0)' },
        { opacity: 0, transform: 'translateX(100%)' }
      ], {
        duration: 1100,
        easing: 'cubic-bezier(.59,.22,.44,1.36)',
        fill: 'forwards'
      });
      anim.onfinish = function() {
        shopCurtain.style.display = 'none';
        shopBanner.style.display = 'none';
        shopItemsList.style.display = 'grid';
        shopControls.style.display = 'block';
        shopCurtain.style.transform = 'translateX(0)';
      };
    };
  </script>
</div>
<div class="panel" id="log-panel" style="grid-column:1/4;max-width:none;width:100%;margin-top:0;">
  <div id="game-log"></div>
</div>
</div>
</div>
<div id="bank-modal-bg" style="display:none;position:fixed;z-index:1200;top:0;left:0;width:100vw;height:100vh;background:#18191cbb;align-items:center;justify-content:center;">
  <div id="bank" style="background:#23252a;border-radius:18px;box-shadow:0 0 44px #000c,0 5px 32px #2b2a2a45;padding:32px 29px 24px 29px;min-width:450px;min-height:320px;position:relative;z-index:1211;display:flex;flex-direction:column;">
    <button id="bank-close-btn" onclick="closeBank()" style="position:absolute;top:12px;right:16px;font-size:1.38em;background:none;border:none;color:#fff;cursor:pointer;">×</button>
    <div id="bank-content" style="display:flex;flex-direction:column;gap:18px;margin-top:14px;justify-content:center;align-items:flex-start;">
      <!-- Bank Gold and Deposit section (top row) -->
      <div style="display:flex;align-items:center;gap:18px;">
        <div style="font-weight:bold;color:#ffba3a;">Bank Gold: <span id="bank-gold-label"></span></div>
        <div>
          <input type="number" id="deposit-gold-amount" min="1" placeholder="Gold to deposit" style="width:120px;padding:4px 8px;border-radius:5px;border:1px solid #444;background:#18191c;color:#fff;">
          <button id="deposit-gold-btn" style="background:#ffba3a;color:#23252a;border:none;border-radius:6px;padding:6px 18px;font-weight:bold;cursor:pointer;">Deposit Gold</button>
        </div>
        <div>
          <input type="number" id="withdraw-gold-amount" min="1" placeholder="Gold to withdraw" style="width:120px;padding:4px 8px;border-radius:5px;border:1px solid #444;background:#18191c;color:#fff;">
          <button id="withdraw-gold-btn" style="background:#35373e;color:#ffba3a;border:none;border-radius:6px;padding:6px 18px;font-weight:bold;cursor:pointer;">Withdraw Gold</button>
        </div>
      </div>
      <!-- Inventory/Bag section (below bank gold/deposit) -->
      <div class="bank-section">
        <div style="font-weight:bold;color:#ffba3a;margin-bottom:7px;">Inventory/Bag</div>
        <div class="bank-list" id="bank-inv-list"></div>
      </div>
      <!-- Bank Items section (below inventory/bag) -->
      <div class="bank-section">
        <div style="font-weight:bold;color:#ffba3a;margin-bottom:7px;">Bank Items</div>
        <div class="bank-list" id="bank-list"></div>
      </div>
    </div>
    <script>
      function updateBankGoldLabels() {
        document.getElementById('bank-gold-label').textContent = player.bankGold;
        renderPlayerStats();
      }
      document.getElementById('deposit-gold-btn').onclick = function() {
        const amt = parseInt(document.getElementById('deposit-gold-amount').value, 10);
        if (isNaN(amt) || amt <= 0) {
          alert('Enter a valid amount.');
          return;
        }
        if (player.gold < amt) {
          alert('Not enough gold to deposit.');
          return;
        }
        player.gold -= amt;
        player.bankGold += amt;
        updateBankGoldLabels();
        logMsg(`Deposited ${amt} gold to the bank.`);
        document.getElementById('deposit-gold-amount').value = '';
      };
      document.getElementById('withdraw-gold-btn').onclick = function() {
        const amt = parseInt(document.getElementById('withdraw-gold-amount').value, 10);
        if (isNaN(amt) || amt <= 0) {
          alert('Enter a valid amount.');
          return;
        }
        if (player.bankGold < amt) {
          alert('Not enough gold in bank.');
          return;
        }
        player.bankGold -= amt;
        player.gold += amt;
        updateBankGoldLabels();
        logMsg(`Withdrew ${amt} gold from the bank.`);
        document.getElementById('withdraw-gold-amount').value = '';
      };
      // Update label when bank modal opens
      if (document.getElementById('bank-modal-bg')) {
        document.getElementById('bank-modal-bg').addEventListener('show', updateBankGoldLabels);
      }
      function renderBank() {
        // ...existing code...
        updateBankGoldLabels();
      }
    </script>
  </div>
</div>
    </script>
  </div>
</div>
</script>
</div>
</div>
</div>
</div>
<script>
const itemIcons = {};
let player = {
  name: "Hero",
  health: 100,
  maxHealth: 100,
  gold: 1000,
  experience: 0,
  level: 1,
  bankGold: 0,
  inventory: [
    { name: "Potion", type: "potion", heal: 50, count: 10 },
    { name: "Arrows", type: "arrows", count: 100 }
   
  ],
  bag: [],
  equipment: {
    helmet: null,
    weapon: null,
    armor: null,
    ring: null,
    arrows: null,
    cloak: null,
    shield: null,
    amulet: null,
    gloves: null,
    boots: null
  },
  bank: []
};
// Equipment slot order for UI
const equipmentOrderLeft = [
  {slot: "helmet", label: "Helmet"},
  {slot: "weapon", label: "Weapon"},
  {slot: "armor", label: "Armor"},
  {slot: "ring", label: "Ring"},
  {slot: "arrows", label: "Arrows"}
];
const equipmentOrderRight = [
  {slot: "cloak", label: "Cloak"},
  {slot: "shield", label: "Shield"},
  {slot: "amulet", label: "Amulet"},
  {slot: "gloves", label: "Gloves"},
  {slot: "boots", label: "Boots"}
];
let areaNames = [
  "Plains", "Forest", "Mountain", "River", "Ruins", "Cave", "Desert", "Swamp", "Valley", "Hills"
];
let mapSize = 18;
let mapData = [];
let discovered = [];
let towns = [];
let chests = [];
let playerPosition = { x: Math.floor(mapSize/2), y: Math.floor(mapSize/2) };
let enemyIcons = {};
const enemyPool = [
  { name: "Slime", maxHealth: 40, minAttack: 4, maxAttack: 9, xp: 15 },
  { name: "Goblin", maxHealth: 55, minAttack: 7, maxAttack: 14, xp: 22 },
  { name: "Wolf", maxHealth: 65, minAttack: 10, maxAttack: 19, xp: 29 },
  { name: "Bandit", maxHealth: 80, minAttack: 14, maxAttack: 23, xp: 40 },
  { name: "Orc", maxHealth: 120, minAttack: 18, maxAttack: 29, xp: 60 },
  { name: "Dark Knight", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
  { name: "Fire Elemental", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
  { name: "Stone Golem", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
  { name: "Vampire Lord", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
  { name: "Frost Giant", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
  { name: "Shadow Assassin", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
  { name: "Ancient Dragon", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
  { name: "Lich King", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
  { name: "Forest Guardian", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
  { name: "Thunder Beast", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
  { name: "Skeleton Warrior", maxHealth: 70, minAttack: 12, maxAttack: 20, xp: 32 },
  { name: "Zombie", maxHealth: 90, minAttack: 10, maxAttack: 18, xp: 28 },
  { name: "Harpy", maxHealth: 60, minAttack: 15, maxAttack: 22, xp: 35 },
  { name: "Troll", maxHealth: 140, minAttack: 20, maxAttack: 32, xp: 55 },
  { name: "Sand Wraith", maxHealth: 85, minAttack: 17, maxAttack: 25, xp: 38 },
  { name: "Cursed Knight", maxHealth: 130, minAttack: 25, maxAttack: 36, xp: 65 },
  { name: "Giant Spider", maxHealth: 75, minAttack: 13, maxAttack: 21, xp: 30 },
  { name: "Dire Bear", maxHealth: 110, minAttack: 18, maxAttack: 28, xp: 48 },
  { name: "Crystal Serpent", maxHealth: 100, minAttack: 22, maxAttack: 33, xp: 52 },
  { name: "Wraith", maxHealth: 95, minAttack: 19, maxAttack: 27, xp: 44 }
];
// --- Ancient Boss Logic ---
const ancientBossData = {
  name: "Ancient Boss",
  maxHealth: 600,
  minAttack: 40,
  maxAttack: 70,
  xp: 1000
};
let ancientBossActive = false;
if (!document.getElementById('ancient-boss-popup')) {
  const bossPopup = document.createElement('div');
  bossPopup.id = 'ancient-boss-popup';
  bossPopup.style = 'display:none;position:fixed;z-index:5000;top:0;left:0;width:100vw;height:100vh;background:#191a1ecc;align-items:center;justify-content:center;';
  bossPopup.innerHTML = `
    <div style="background:linear-gradient(135deg,#23252a 80%,#e53935 100%);padding:48px 54px 38px 54px;border-radius:28px;box-shadow:0 4px 32px #e5393588,0 2px 24px #000a;display:flex;flex-direction:column;align-items:center;min-width:380px;position:relative;">
      <div style="position:absolute;top:-32px;left:50%;transform:translateX(-50%);font-size:3.2em;color:#e53935;text-shadow:0 2px 12px #000a,0 0 8px #ffba3a88;">👑</div>
      <div style="color:#ffba3a;font-size:1.7em;font-weight:bold;margin-bottom:18px;text-shadow:0 2px 8px #23252a88,0 0 4px #fff;">ANCIENT BOSS ENCOUNTER!</div>
      <div style="margin-bottom:18px;font-size:1.15em;color:#fff;text-align:center;">
        <span style="color:#e53935;font-weight:bold;">A legendary foe blocks your path!</span><br>
        <span style="color:#ffba3a;">Defeat the Ancient Boss for:</span><br>
        <span style="color:gold;font-weight:bold;">Ancient Sword</span> <span style="font-size:1.2em;">⚔️</span> <span style="color:#90ee90;">Ancient Armor Set</span> <span style="font-size:1.2em;">🛡️</span><br>
        
      </div>
      <div style="margin-bottom:18px;">
        <span style="color:#fff;">Will you risk it all for glory and treasure?</span>
      </div>
      <div style="display:flex;gap:18px;">
        <button id="ancient-boss-fight" style="font-size:1.15em;font-weight:bold;background:linear-gradient(90deg,#e53935 70%,#ffba3a 100%);color:#23252a;border:none;border-radius:9px;padding:10px 38px;cursor:pointer;box-shadow:0 2px 14px #e5393588;transition:background 0.18s, color 0.18s;">Fight</button>
        <button id="ancient-boss-run" style="font-size:1.15em;font-weight:bold;background:#35373e;color:#ffba3a;border:none;border-radius:9px;padding:10px 38px;cursor:pointer;box-shadow:0 2px 14px #0006;transition:background 0.18s, color 0.18s;">Run</button>
      </div>
      <div style="margin-top:22px;font-size:0.98em;color:#aaa;text-align:center;">
        <span style="color:#ffd36b;">Tip:</span> Running has a <b>60%</b> chance to succeed.<br>
        If you fail, the boss will strike you for <span style="color:#e53935;font-weight:bold;">25% of your max HP!</span>
      </div>
    </div>
  `;
  document.body.appendChild(bossPopup);
}

document.getElementById('ancient-boss-fight').onclick = function() {
  document.getElementById('ancient-boss-popup').style.display = 'none';
  showAncientBoss();
};
// --- PATCH: Ancient Boss Run Option with Chance to Fail ---
document.getElementById('ancient-boss-run').onclick = function() {
  document.getElementById('ancient-boss-popup').style.display = 'none';
  // 60% chance to successfully run, 40% chance to fail
  if (Math.random() < 0.6) {
    logMsg('You successfully ran away from the Ancient Boss!');
    ancientBossActive = false;
  } else {
    // Fail: Boss hits player for 25% of their max health
    let damage = Math.floor(getTotalMaxHealth() * 0.25);
    player.health = Math.max(0, player.health - damage);
    logMsg(`<span style="color:#e53935;font-weight:bold;">Failed to run! The Ancient Boss hits you for <b>${damage}</b>!</span>`);
    renderPlayerStats();
    if (player.health <= 0) {
      logMsg(`<span style="color:#f44;font-weight:bold;">You died! Respawning at town...</span>`);
      respawnPlayer();
    }
    ancientBossActive = false;
  }
};

const origShowEnemy = typeof showEnemy === "function" ? showEnemy : null;
function maybeAncientBossEncounter() {
  if (!ancientBossActive && Math.random() < 0.15) {
    ancientBossActive = true;
    document.getElementById('ancient-boss-popup').style.display = 'flex';
    return true;
  }
  return false;
}
function showAncientBoss() {
  currentEnemy = {
    name: ancientBossData.name,
    health: ancientBossData.maxHealth,
    maxHealth: ancientBossData.maxHealth,
    minAttack: ancientBossData.minAttack,
    maxAttack: ancientBossData.maxAttack,
    xp: ancientBossData.xp,
    isBoss: true
  };
  inCombat = true;
  renderEnemyEncounter();
  logMsg(`<span style="color:#e53935;font-weight:bold;">A Special Boss has appeared!</span>`);
}

// Patch all places where showEnemy is called to maybeAncientBossEncounter
function patchedRandomEncounter() {
  if (maybeAncientBossEncounter()) return;
  origShowEnemy && origShowEnemy();
}
// Replace showEnemy calls in movePlayer, doExplore, etc.
window.showEnemy = patchedRandomEncounter;

// --- Boss Drop Logic ---
function giveAncientBossRewards() {
  // Ancient Sword
  const ancientSword = {
    name: "Ancient Sword",
    type: "weapon",
    attackPower: 60,
    price: 0,
    description: "A sword only dropped by the Ancient Boss. +60 ATK, +150 HP",
    health: 150
  };
  addItem(ancientSword);

  // Ancient Armor Set: helmet, armor, boots, gloves, cloak
  const armorPieces = [
    { slot: "helmet", name: "Ancient Helmet" },
    { slot: "armor", name: "Ancient Armor" },
    { slot: "boots", name: "Ancient Boots" },
    { slot: "gloves", name: "Ancient Gloves" },
    { slot: "cloak", name: "Ancient Cloak" }
  ];
  armorPieces.forEach(piece => {
    addItem({
      name: piece.name,
      type: piece.slot,
      defense: randomStat(30, 60),
      health: 150,
      price: 0,
      description: `A ${piece.name} only dropped by the Ancient Boss. 0 - 150 HP, +${piece.slot === "armor" ? "60" : "30-60"} DEF`
    });
  });
  logMsg(`<span style="color:gold;font-weight:bold;">You defeated the Ancient Boss!<br>
    <span style="color:#ffba3a;">Ancient Sword</span> and <span style="color:#90ee90;">Ancient Armor Set</span> have been added to your inventory!</span>`);
}

// --- Ancient Set Bonus Logic ---
function getAncientSetCount() {
  let count = 0;
  ["helmet", "armor", "boots", "gloves", "cloak"].forEach(slot => {
    const eq = player.equipment[slot];
    if (eq && eq.name && eq.name.startsWith("Ancient ")) count++;
  });
  return count;
}

// Patch getTotalDefense and getTotalMaxHealth for set bonus
const origGetTotalDefense = getTotalDefense;
getTotalDefense = function() {
  let base = origGetTotalDefense();
  let setCount = getAncientSetCount();
  if (setCount >= 2) base += 20; // 2+ pieces: +20 DEF
  if (setCount >= 4) base += 40; // 4+ pieces: +40 DEF
  if (setCount === 5) base += 60; // Full set: +60 DEF
  return base;
};
const origGetTotalMaxHealth = getTotalMaxHealth;
getTotalMaxHealth = function() {
  let base = origGetTotalMaxHealth();
  let setCount = getAncientSetCount();
  if (setCount >= 2) base += 50; // 2+ pieces: +50 HP
  if (setCount >= 4) base += 100; // 4+ pieces: +100 HP
  if (setCount === 5) base += 150; // Full set: +150 HP
  return base;
};

// Patch attackEnemy to handle boss death and rewards
const origAttackEnemy = typeof attackEnemy === "function" ? attackEnemy : null;
window.attackEnemy = function() {
  if (!currentEnemy || !inCombat) {
    logMsg("No enemy to attack.");
    return;
  }
  // Boss logic
  if (currentEnemy.isBoss) {
    let pAtk = (player.equipment.weapon ? player.equipment.weapon.attackPower||8 : 6)
      + (player.equipment.ring ? player.equipment.ring.attackPower||0 : 0);
    let hit = randomStat(30, 90);
    currentEnemy.health = Math.max(0, currentEnemy.health - hit);
    showHitsplat(hit);
    logMsg(`You hit the <b>${currentEnemy.name}</b> for <b>${hit}</b>!`);
    renderEnemyEncounter();
    if (currentEnemy.health <= 0) {
      player.experience += currentEnemy.xp;
      checkLevelUp();
      giveAncientBossRewards();
      ancientBossActive = false;
      clearEnemy();
      renderPlayerStats();
      return;
    }
    setTimeout(()=>{ enemyAttack(); }, 700);
    return;
  }
  // Normal enemy
  origAttackEnemy && origAttackEnemy();
};

function randomStat(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
const items = [
  { name: 'Sword', price: 50, description: 'A basic sword for beginners.', type: 'weapon', attackPower: 15 },
  { name: 'Shield', price: 30, description: 'A sturdy shield for protection.', type: 'shield', defense: 20 },
  { name: 'Potion', price: 10, description: 'A basic healing potion.', type: 'potion', heal: 50 },
  { name: 'Advanced Sword', price: 100, description: 'A more powerful sword for experienced fighters.', type: 'weapon', attackPower: 25 },
  { name: 'Advanced Shield', price: 60, description: 'A stronger shield for better protection.', type: 'shield', defense: 30 },
  { name: 'Advanced Potion', price: 25, description: 'A potion that heals more health.', type: 'potion', heal: 50 },
  { name: 'Helmet', price: 40, description: 'A helmet to protect your head.', type: 'helmet', defense: 25, health: randomStat(30,100) },
  { name: 'Armor', price: 80, description: 'A set of armor for full body protection.', type: 'armor', defense: 40 },
  { name: 'Boots', price: 20, description: 'Boots to protect your feet.', type: 'boots', defense: 20, health: randomStat(20,100) },
  { name: 'Magic Wand', price: 120, description: 'A wand for casting powerful spells.', type: 'weapon', attackPower: 20 },
  { name: 'Bow', price: 70, description: 'A bow for ranged attacks.', type: 'weapon', attackPower: 18 },
  { name: 'Arrows', price: 15, description: 'A set of arrows for your bow.', type: 'arrows' },
  { name: 'Ring of Strength', price: 150, description: 'A ring that increases your strength.', type: 'ring', attackPower: 3, health: randomStat(10,100) },
  { name: 'Amulet of Health', price: 200, description: 'An amulet that increases your health.', type: 'amulet', defense: 10 },
  { name: 'Cloak of Invisibility', price: 300, description: 'A cloak that makes you invisible for a short time.', type: 'cloak', defense: 35, health: randomStat(25,100) },
  { name: 'Dagger', price: 45, description: 'A small, quick weapon for close combat.', type: 'weapon', attackPower: 15 },
  { name: 'Healing Herb', price: 5, description: 'A herb that heals minor wounds.', type: 'consumable', heal: 50 },
  { name: 'Mana Potion', price: 20, description: 'A potion that restores mana.', type: 'potion', heal: 50 },
  { name: 'Steel Boots', price: 35, description: 'Heavy boots for better protection.', type: 'boots', defense: 25, health: randomStat(30,100) },
  { name: 'Fire Staff', price: 150, description: 'A staff that casts fire spells.', type: 'weapon', attackPower: 22 },
  { name: 'Ice Amulet', price: 180, description: 'An amulet that grants resistance to ice.', type: 'amulet', defense: 15 },
  { name: 'Thunder Hammer', price: 250, description: 'A hammer that strikes with thunder.', type: 'weapon', attackPower: 30 },
  { name: 'Dragon Scale Armor', price: 500, description: 'Armor made from dragon scales.', type: 'armor', defense: 50 },
  { name: 'Phoenix Feather', price: 75, description: 'A rare feather with magical properties.', type: 'material' },
  { name: 'Elven Bow', price: 200, description: 'A bow crafted by elves.', type: 'weapon', attackPower: 25 },
  { name: 'Mystic Ring', price: 220, description: 'A ring that enhances magical abilities.', type: 'ring', attackPower: 2, health: randomStat(10,100) },
  { name: 'Warrior Helmet', price: 90, description: 'A helmet worn by warriors.', type: 'helmet', defense: 30, health: randomStat(40,100) },
  { name: 'Assassin Cloak', price: 250, description: 'A cloak that grants stealth.', type: 'cloak', defense: 35, health: randomStat(30,100) },
  { name: 'Knight Lance', price: 300, description: 'A lance used by knights.', type: 'weapon', attackPower: 28 },
  { name: 'Ranger Hat', price: 60, description: 'A hat worn by rangers.', type: 'helmet', defense: 20, health: randomStat(20,100) },
  { name: 'Mage Robe', price: 100, description: 'A robe worn by mages.', type: 'armor', defense: 25 },
  { name: 'Leather Gloves', price: 25, description: 'Gloves for better grip.', type: 'gloves', defense: 15, health: randomStat(30,100) }
];

let currentEnemy = null;
let inCombat = false;
let baginvTab = "inventory";
let searchTerm = "";
let chestReward = 0;
let chestOpen = false;
let exploreDir = null;

function getTotalDefense() {
  return (player.equipment.armor?.defense || 0)
    + (player.equipment.helmet?.defense || 0)
    + (player.equipment.shield?.defense || 0)
    + (player.equipment.cloak?.defense || 0)
    + (player.equipment.boots?.defense || 0)
    + (player.equipment.amulet?.defense || 0)
    + (player.equipment.gloves?.defense || 0);
}
function getTotalMaxHealth() {
  return player.maxHealth
    + (player.equipment.helmet?.health || 0)
    + (player.equipment.boots?.health || 0)
    + (player.equipment.cloak?.health || 0)
    + (player.equipment.ring?.health || 0)
    + (player.equipment.gloves?.health || 0);
}
function getTotalAttack() {
  return (player.equipment.weapon?.attackPower || 0)
    + (player.equipment.ring?.attackPower || 0);
}
function renderPlayerStats() {
  document.getElementById('player-stats-ul').innerHTML = `
    <li><span class="username">Name:</span> ${player.name || username || ''}</li>
    <li><span class="level">Level:</span> ${player.level}</li>
    <li><span class="health">Health:</span> ${player.health}/${getTotalMaxHealth()}</li>
    <li><span class="gold">Gold:</span> ${player.gold}</li>
    <li>Experience: ${player.experience}</li>
    <li>Bank Gold: ${player.bankGold}</li>
    <li><span class="defense" style="color:#90ee90;">Defense:</span> ${getTotalDefense()}</li>
    <li><span class="attack" style="color:#ffba3a;">Attack:</span> ${getTotalAttack()}</li>
  `;
}
function renderDerivedStats() {
  let atk = getTotalAttack();
  let def = getTotalDefense();
  let hp = getTotalMaxHealth();
  let stats = [
    `<li><span class="derived-label">Attack:</span> ${atk}</li>`,
    `<li><span class="derived-label">Defense:</span> ${def}</li>`,
    `<li><span class="derived-label">Max Health:</span> ${hp}</li>`
  ];
  document.getElementById('derived-stats-list').innerHTML = stats.join('');
}

function initMap() {
  mapData = [];
  discovered = [];
  towns = [];
  chests = [];
  for (let y = 0; y < mapSize; ++y) {
    let row = [];
    let drow = [];
    for (let x = 0; x < mapSize; ++x) {
      // Assign random area name to each cell
      let areaIdx = Math.floor(Math.random() * areaNames.length);
      row.push({ type: "area", name: areaNames[areaIdx] });
      drow.push(false);
    }
    mapData.push(row);
    discovered.push(drow);
  }
  // Place main town in center
  let mid = Math.floor(mapSize/2);
  mapData[mid][mid] = { type: "central-town", name: "Central Town" };
  discovered[mid][mid] = true;
  towns.push({ x: mid, y: mid, name: "Central Town", central: true });
  // Place 10 more towns randomly
  let townNames = [
    "Oakvale", "Riverside", "Stonehill", "Windmere", "Goldport", "Ironforge", "Mistwood", "Sunvale", "Frostholm", "Shadowfen"
  ];
  for (let i = 0; i < 10; ++i) {
    let tx, ty;
    do {
      tx = Math.floor(Math.random()*mapSize);
      ty = Math.floor(Math.random()*mapSize);
    } while ((mapData[ty][tx].type !== "area") || (Math.abs(tx-mid)+Math.abs(ty-mid)<2));
    mapData[ty][tx] = { type: "town", name: townNames[i] };
    towns.push({ x: tx, y: ty, name: townNames[i], central: false });
  }
  // Place 8 chests randomly
  for (let i = 0; i < 8; ++i) {
    let cx, cy;
    do {
      cx = Math.floor(Math.random()*mapSize);
      cy = Math.floor(Math.random()*mapSize);
    } while (mapData[cy][cx].type !== "area");
    mapData[cy][cx] = { type: "chest", name: "Chest" };
    chests.push({ x: cx, y: cy });
  }
}
function renderMap() {
  const map = document.getElementById('game-map');
  map.innerHTML = "";
  for (let y = 0; y < mapSize; ++y) {
    for (let x = 0; x < mapSize; ++x) {
      let cellClass = "map-cell";
      let label = "";
      let cell = mapData[y][x];
      // Player
      if (x === playerPosition.x && y === playerPosition.y) {
        cellClass += " player";
      }
      // Central Town
      if (cell.type === "central-town") {
        cellClass += " central-town";
        label = "C";
      }
      // Other Towns
      else if (cell.type === "town") {
        cellClass += " town";
        if (visitedTowns[cell.name]) {
          label = "✔";
        } else {
          label = "T";
        }
      }
      // Chest
      else if (cell.type === "chest") {
        cellClass += " chest";
        label = "💰";
      }
      // Area
      else if (cell.type === "area") {
        if (discovered[y][x]) {
          cellClass += " discovered";
          label = cell.name[0];
        } else {
          cellClass += " area";
          label = cell.name[0];
        }
      }
      // Discovered
      else if (cell.type === "discovered") {
        cellClass += " discovered";
        label = "";
      }
      // Undiscovered
      if (!discovered[y][x] && cell.type !== "central-town" && cell.type !== "town" && cell.type !== "chest") {
        cellClass += " undiscovered";
        label = "";
      }
      // Show player icon
      if (x === playerPosition.x && y === playerPosition.y) {
        label = "🧑";
      }
      map.innerHTML += `<div class="${cellClass}" data-x="${x}" data-y="${y}" onclick="mapCellClick(${x},${y})" title="${cell.type === 'area' || cell.type === 'discovered' ? cell.name : cell.name || ''}">${label}</div>`;
    }
  }
  let areaLabel = "";
  let cell = mapData[playerPosition.y][playerPosition.x];
  if (cell.type === "central-town") areaLabel = "Area: Central Town";
  else if (cell.type === "town") areaLabel = "Area: " + cell.name;
  else if (cell.type === "chest") areaLabel = "Area: Chest";
  else if (!discovered[playerPosition.y][playerPosition.x]) areaLabel = "Area: Not Discovered";
  else areaLabel = "Area: " + (cell.name || "Discovered");
  document.getElementById("map-area-label").textContent = areaLabel;
}
function mapCellClick(x, y) {
  // If player is on a chest, allow to open
  if (x === playerPosition.x && y === playerPosition.y && mapData[y][x].type === "chest") {
    openChest();
  }
}
function movePlayer(dx,dy) {
  if (inCombat || chestOpen) {
    logMsg('You cannot move while fighting or opening a chest!');
    return;
  }
  let nx = Math.max(0, Math.min(mapSize-1, playerPosition.x+dx));
  let ny = Math.max(0, Math.min(mapSize-1, playerPosition.y+dy));
  playerPosition.x = nx;
  playerPosition.y = ny;
  discovered[ny][nx] = true;
  renderMap();
  let cell = mapData[ny][nx];
  if (cell.type === "central-town") {
    logMsg(`Arrived at <b>Central Town</b>.`);
  } else if (cell.type === "town") {
    showTownPopup(cell.name);
    logMsg(`Arrived at town: <b>${cell.name}</b>.`);
    return; // Wait for popup interaction
  } else if (cell.type === "chest") {
    logMsg("You found a chest!");
    openChest();
    return;
  } else if (!discovered[ny][nx]) {
    logMsg("You entered a not discovered area.");
  } else {
    logMsg("You entered: <b>" + (cell.name || "a discovered area") + "</b>.");
  }
  // Random town events
  if (cell.type === "town" && Math.random() < 0.5) {
    triggerRandomTownEvent();
  }
  // Random area events
  if (cell.type === "area" && discovered[ny][nx] && Math.random() < 0.15) {
    triggerRandomAreaEvent();
  }
  if (Math.random() < 0.18 && cell.type !== "central-town" && cell.type !== "town" && cell.type !== "chest") {
    setTimeout(showEnemy, 350);
  }
}
function startExplore() {
  if (inCombat || chestOpen) {
    logMsg("Finish your battle or chest first!");
    return;
  }
  document.getElementById('direction-select-bar').classList.add('active');
}
function chooseExploreDir(dx, dy) {
  document.getElementById('direction-select-bar').classList.remove('active');
  exploreDir = {dx, dy};
  doExplore();
}

(function() {
  // Remove old button if exists
  let oldBtn = document.getElementById('auto-explore-btn');
  if (oldBtn) oldBtn.remove();
  // Create button
  const btn = document.createElement('button');
  btn.id = 'auto-explore-btn';
  btn.textContent = 'Auto Explore';
  btn.style.fontWeight = 'bold';
  btn.style.fontSize = '1em';
  btn.style.background = '#ffba3a';
  btn.style.color = '#23252a';
  btn.style.border = 'none';
  btn.style.borderRadius = '12px';
  btn.style.padding = '14px 32px';
  btn.style.cursor = 'pointer';
  btn.style.marginLeft = '18px';
  btn.onclick = function() {
    showAutoExploreDirectionPopup();
  };
  // Insert beside Explore button
  const exploreBar = document.getElementById('explore-bar');
  if (exploreBar) {
    exploreBar.appendChild(btn);
  }
})();

let autoExploreActive = false;
let autoExploreDir = null;
let autoExploreTimer = null;
let autoExploreAutoAttack = false;

function showAutoExploreDirectionPopup() {
  // Remove old popup if exists
  let oldPopup = document.getElementById('auto-explore-dir-popup');
  if (oldPopup) oldPopup.remove();
  // Create popup
  const popup = document.createElement('div');
  popup.id = 'auto-explore-dir-popup';
  popup.style = 'position:fixed;z-index:9999;top:0;left:0;width:100vw;height:100vh;background:#191a1ecc;display:flex;align-items:center;justify-content:center;';
  popup.innerHTML = `
    <div style="background:#23252a;padding:32px 38px 24px 38px;border-radius:18px;box-shadow:0 2px 24px #000a;display:flex;flex-direction:column;align-items:center;">
      <div style="color:#ffba3a;font-size:1.2em;margin-bottom:18px;">Choose Auto Explore Direction</div>
      <label style="margin-bottom:14px;display:flex;align-items:center;gap:8px;">
        <input type="checkbox" id="auto-explore-auto-attack" style="width:18px;height:18px;">
        <span style="color:#ffba3a;font-weight:bold;">Auto Attack Enemies</span>
      </label>
      <div style="display:flex;gap:18px;margin-bottom:18px;">
        <button onclick="startAutoExplore(0,-1);closeAutoExploreDirPopup()" style="font-size:1.1em;background:#35373e;color:#ffba3a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">North</button>
        <button onclick="startAutoExplore(1,0);closeAutoExploreDirPopup()" style="font-size:1.1em;background:#35373e;color:#ffba3a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">East</button>
        <button onclick="startAutoExplore(0,1);closeAutoExploreDirPopup()" style="font-size:1.1em;background:#35373e;color:#ffba3a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">South</button>
        <button onclick="startAutoExplore(-1,0);closeAutoExploreDirPopup()" style="font-size:1.1em;background:#35373e;color:#ffba3a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">West</button>
      </div>
      <button onclick="closeAutoExploreDirPopup()" style="font-size:1em;background:#ff4444;color:#fff;border:none;border-radius:7px;padding:6px 24px;cursor:pointer;">Cancel</button>
    </div>
  `;
  document.body.appendChild(popup);
  // Restore last checkbox state
  setTimeout(() => {
    const cb = document.getElementById('auto-explore-auto-attack');
    if (cb) cb.checked = autoExploreAutoAttack;
    cb && cb.addEventListener('change', function() {
      autoExploreAutoAttack = cb.checked;
    });
  }, 50);
}
function closeAutoExploreDirPopup() {
  let popup = document.getElementById('auto-explore-dir-popup');
  if (popup) popup.remove();
}

function startAutoExplore(dx, dy) {
  autoExploreActive = true;
  autoExploreDir = {dx, dy};
  // Get checkbox value
  const cb = document.getElementById('auto-explore-auto-attack');
  autoExploreAutoAttack = cb ? cb.checked : autoExploreAutoAttack;
  updateAutoExploreBtn(true);
  autoExploreLoop();
}

function stopAutoExplore() {
  autoExploreActive = false;
  autoExploreDir = null;
  if (autoExploreTimer) clearTimeout(autoExploreTimer);
  updateAutoExploreBtn(false);
}

function updateAutoExploreBtn(active) {
  const btn = document.getElementById('auto-explore-btn');
  if (!btn) return;
  if (active) {
    btn.textContent = 'Stop Auto Explore';
    btn.style.background = '#ff4444';
    btn.style.color = '#fff';
    btn.onclick = stopAutoExplore;
  } else {
    btn.textContent = 'Auto Explore';
    btn.style.background = '#ffba3a';
    btn.style.color = '#23252a';
    btn.onclick = function() { showAutoExploreDirectionPopup(); };
  }
}

function autoExploreLoop() {
  if (!autoExploreActive || !autoExploreDir) return;
  // If in combat or chest open, wait and retry
  if (inCombat || chestOpen) {
    autoExploreTimer = setTimeout(autoExploreLoop, 1200);
    return;
  }
  // Try to move in direction
  let nx = Math.max(0, Math.min(mapSize-1, playerPosition.x+autoExploreDir.dx));
  let ny = Math.max(0, Math.min(mapSize-1, playerPosition.y+autoExploreDir.dy));
  // If can't move further, stop
  if (nx === playerPosition.x && ny === playerPosition.y) {
    stopAutoExplore();
    return;
  }
  playerPosition.x = nx;
  playerPosition.y = ny;
  discovered[ny][nx] = true;
  renderMap();
  let cell = mapData[ny][nx];
  // Interactions: stop auto-explore, resume after
  if (cell.type === "central-town") {
    logMsg(`Arrived at <b>Central Town</b>.`);
    stopAutoExplore();
    return;
  } else if (cell.type === "town") {
    showTownPopup(cell.name);
    logMsg(`Arrived at town: <b>${cell.name}</b>.`);
    stopAutoExplore();
    return;
  } else if (cell.type === "chest") {
    logMsg("You found a chest!");
    openChest();
    stopAutoExplore();
    return;
  } else if (!discovered[ny][nx]) {
    logMsg("You entered a not discovered area.");
  } else {
    logMsg("You entered: <b>" + (cell.name || "a discovered area") + "</b>.");
  }
  // Random town events
  if (cell.type === "town" && Math.random() < 0.5) {
    triggerRandomTownEvent();
    stopAutoExplore();
    return;
  }
  // Random area events
  if (cell.type === "area" && discovered[ny][nx] && Math.random() < 0.15) {
    triggerRandomAreaEvent();
    stopAutoExplore();
    return;
  }
  // Enemy encounter: stop auto-explore, resume after
  if (Math.random() < 0.22 && cell.type !== "central-town" && cell.type !== "town" && cell.type !== "chest") {
    setTimeout(() => {
      showEnemy();
      // If auto-attack is enabled, auto attack until enemy defeated or player dies
      if (autoExploreAutoAttack && currentEnemy && inCombat) {
        autoAttackActive = true;
        autoAttackLoopAutoExplore();
      } else {
        stopAutoExplore();
      }
    }, 350);
    return;
  }
  // Continue auto-explore after short delay
  autoExploreTimer = setTimeout(autoExploreLoop, 700);
}

// Auto-attack loop for auto-explore (does not stop auto-explore unless player dies or ancient boss)
function autoAttackLoopAutoExplore() {
  if (!autoAttackActive || !currentEnemy || !inCombat) {
    stopAutoExplore();
    return;
  }
  // If ancient boss, stop auto-explore and require manual input
  if (currentEnemy.isBoss) {
    stopAutoExplore();
    return;
  }
  // Only attack if enemy and player are alive
  if (currentEnemy.health > 0 && player.health > 0) {
    attackEnemy();
    setTimeout(() => {
      if (currentEnemy && currentEnemy.health > 0 && player.health > 0 && inCombat && autoAttackActive) {
        autoAttackLoopAutoExplore();
      } else {
        stopAutoExplore();
      }
    }, 900);
  } else {
    stopAutoExplore();
  }
}


function doExplore() {
  if (!exploreDir) return;
  let nx = Math.max(0, Math.min(mapSize-1, playerPosition.x+exploreDir.dx));
  let ny = Math.max(0, Math.min(mapSize-1, playerPosition.y+exploreDir.dy));
  playerPosition.x = nx;
  playerPosition.y = ny;
  discovered[ny][nx] = true;
  renderMap();
  let cell = mapData[ny][nx];
  if (cell.type === "central-town") {
    logMsg(`Arrived at <b>Central Town</b>.`);
  } else if (cell.type === "town") {
    showTownPopup(cell.name);
    logMsg(`Arrived at town: <b>${cell.name}</b>.`);
    exploreDir = null;
    return; // Wait for popup interaction
  } else if (cell.type === "chest") {
    logMsg("You found a chest!");
    openChest();
    return;
  } else if (!discovered[ny][nx]) {
    logMsg("You entered a not discovered area.");
  } else {
    logMsg("You entered: <b>" + (cell.name || "a discovered area") + "</b>.");
  }
  // Random town events
  if (cell.type === "town" && Math.random() < 0.5) {
    triggerRandomTownEvent();
  }
  // Random area events
  if (cell.type === "area" && discovered[ny][nx] && Math.random() < 0.15) {
    triggerRandomAreaEvent();
  }
  if (Math.random() < 0.22 && cell.type !== "central-town" && cell.type !== "town" && cell.type !== "chest") {
    setTimeout(showEnemy, 350);
  }
  exploreDir = null;
}
// --- Add this after your renderDerivedStats function ---
function updateAllStats() {
  renderPlayerStats();
  renderDerivedStats();
  renderEquipment();
}

// --- Replace all calls to renderPlayerStats(), renderDerivedStats(), or renderEquipment() after stat changes with updateAllStats() ---
// For example, in equipItem, equipBagItem, useItem, addItem, handleEquipSlot, etc.
// Example for equipItem:
function equipItem(idx) {
  let item = player.inventory[idx];
  let slot = item.type;
  if (!isEquipable(item)) {
    logMsg(`Cannot equip ${item.name}.`);
    return;
  }
  let old = player.equipment[slot];
  if (old) player.bag.push(old);
  player.equipment[slot] = item;
  player.inventory.splice(idx, 1);
  logMsg(`Equipped ${item.name}.`);
  updateAllStats();
  renderBagInv();
}
function renderEquipment() {
  const eqLeft = document.getElementById('equipment-slots-left');
  const eqRight = document.getElementById('equipment-slots-right');
  eqLeft.innerHTML = "";
  eqRight.innerHTML = "";
  equipmentOrderLeft.forEach((slotData) => {
    const slot = slotData.slot;
    const eq = player.equipment[slot];
    let isAncient = eq && eq.name && eq.name.startsWith("Ancient ");
    let setCount = getAncientSetCount();
    let setBonus = "";
    if (isAncient) {
      setBonus = `<br><span style="color:#90ee90;font-weight:bold;">Ancient Set Bonus (${setCount}/5):</span>`;
      setBonus += `<br><span style="color:${setCount>=2?'#90ee90':'#fff'};">+20 DEF, +50 HP</span>`;
      setBonus += `<br><span style="color:${setCount>=4?'#90ee90':'#fff'};">+40 DEF, +100 HP</span>`;
      setBonus += `<br><span style="color:${setCount===5?'#90ee90':'#fff'};">+60 DEF, +150 HP</span>`;
    }
    eqLeft.innerHTML += `
      <div class="equip-slot${isAncient ? ' ancient-set' : ''}" onclick="handleEquipSlot('${slot}')" title="${slotData.label}">
       <b>${slotData.label}:</b> <span class="item-name">${eq ? eq.name.replace(/\s*\([^)]*\)/, "") : "<em>none</em>"}</span>
  <div class="slot-tooltip">
  ${eq ? eq.name.replace(/\s*\([^)]*\)/, "") : "<em>none</em>"}
  ${eq && eq.attackPower ? `<br>ATK: <b>+${eq.attackPower}</b>` : ""}
  ${eq && eq.defense ? `<br>DEF: <b>+${eq.defense}</b>` : ""}
  ${eq && eq.health ? `<br>HP: <b>+${eq.health}</b>` : ""}
  ${setBonus}
</div>
    `;
  });
  equipmentOrderRight.forEach((slotData) => {
    const slot = slotData.slot;
    const eq = player.equipment[slot];
    let isAncient = eq && eq.name && eq.name.startsWith("Ancient ");
    let setCount = getAncientSetCount();
    let setBonus = "";
    if (isAncient) {
      setBonus = `<br><span style="color:#90ee90;font-weight:bold;">Ancient Set Bonus (${setCount}/5):</span>`;
      if (setCount >= 2) setBonus += `<br><span style="color:#90ee90;">+20 DEF, +50 HP</span>`;
      if (setCount >= 4) setBonus += `<br><span style="color:#90ee90;">+40 DEF, +100 HP</span>`;
      if (setCount === 5) setBonus += `<br><span style="color:#90ee90;">+60 DEF, +150 HP</span>`;
    }
    eqRight.innerHTML += `
  <div class="equip-slot${isAncient ? ' ancient-set' : ''}" onclick="handleEquipSlot('${slot}')" title="${slotData.label}">
    <b>${slotData.label}:</b> <span class="item-name" style="max-width:70px;display:inline-block;vertical-align:middle;">${eq ? eq.name.replace(/\s*\([^)]*\)/, "") : "<em>none</em>"}</span>
    <div class="slot-tooltip">
      ${eq ? eq.name.replace(/\s*\([^)]*\)/, "") : "<em>none</em>"}
      ${eq && eq.attackPower ? `<br>ATK: <b>+${eq.attackPower}</b>` : ""}
      ${eq && eq.defense ? `<br>DEF: <b>+${eq.defense}</b>` : ""}
      ${eq && eq.health ? `<br>HP: <b>+${eq.health}</b>` : ""}
      ${setBonus}
    </div>
  </div>
 `;
  });
  document.getElementById('equipment-legend').textContent = "Click a slot to unequip";
}
function handleEquipSlot(slot) {
  if (!player.equipment[slot]) return;
  player.bag.push(player.equipment[slot]);
  logMsg(`Unequipped ${player.equipment[slot].name} from ${slot}.`);
  player.equipment[slot] = null;
  updateAllStats();
  renderBagInv();
}
function switchBagInv(tab) {
  baginvTab = tab;
  document.getElementById('tab-inventory').classList.toggle('active', tab === "inventory");
  document.getElementById('tab-bag').classList.toggle('active', tab === "bag");
  renderBagInv();
}
function renderBagInv() {
  const content = document.getElementById('baginv-content');
  content.innerHTML = "";
  let itemsArr = baginvTab === "inventory" ? player.inventory : player.bag;
  if (searchTerm) {
    itemsArr = itemsArr.filter(i => i.name.toLowerCase().includes(searchTerm));
  }
  if (!itemsArr.length) {
    content.innerHTML = `<div style="color:#9c9c9c;text-align:center;width:100%;padding:29px 0;">No items</div>`;
    return;
  }
  if (baginvTab === "inventory") {
    itemsArr.forEach((item, idx) => {
      let isAncient = item.name && item.name.startsWith("Ancient ");
      let setCount = getAncientSetCount();
      let setBonus = "";
      if (isAncient) {
        setBonus = `<br><span style="color:gold;font-weight:bold;">Ancient Set Bonus (${setCount}/5):</span>`;
        setBonus += `<br><span style="color:${setCount>=2?'#ffd36b':'#fff'};">+20 DEF, +50 HP</span>`;
        setBonus += `<br><span style="color:${setCount>=4?'#ffd36b':'#fff'};">+40 DEF, +100 HP</span>`;
        setBonus += `<br><span style="color:${setCount===5?'#ffd36b':'#fff'};">+60 DEF, +150 HP</span>`;
      }
      content.innerHTML += `
        <div class="item-card${isAncient ? ' ancient-set' : ''}">
          ${item.type==="material" ? `<button class="bag-x-remove-btn" onclick="removeItem(${idx});event.stopPropagation()" title="Remove">&times;</button>` : ""}
          <div class="item-name">${item.name.replace(/\s*\([^)]*\)/, "")}${item.count > 1 ? ` (x${item.count})` : ""}</div>
          <div class="item-actions">
            ${item.type==="potion"||item.type==="consumable"||isHealingItem(item) ? `<button class="item-action-btn" onclick="useItem(${idx});event.stopPropagation()">Use</button>` : ""}
            ${isEquipable(item) ? `<button class="item-action-btn" onclick="equipItem(${idx});event.stopPropagation()">Equip</button>` : ""}
          </div>
          <div class="item-tooltip" style="display:none;position:absolute;left:110%;top:50%;transform:translateY(-50%);background:#18191c;color:#eee;padding:7px 13px;border-radius:8px;border:1px solid #444;white-space:nowrap;font-size:0.98em;box-shadow:0 2px 10px #0007;z-index:10;min-width:160px;">
            <b>${item.name}</b>
            ${item.description ? `<br><span style="color:#aaa;">${item.description}</span>` : ""}
            ${item.attackPower ? `<br>ATK: <b>+${item.attackPower}</b>` : ""}
            ${item.defense ? `<br>DEF: <b>+${item.defense}</b>` : ""}
            ${item.health ? `<br>HP: <b>+${item.health}</b>` : ""}
            ${item.heal ? `<br>Heals: <b>+${item.heal}</b>` : ""}
            ${item.count && item.type === "arrows" ? `<br>Arrows: <b>x${item.count}</b>` : ""}
            ${item.type ? `<br><span style="color:#ffba3a;">Type: ${item.type.charAt(0).toUpperCase() + item.type.slice(1)}</span>` : ""}
            ${setBonus}
          </div>
        </div>
      `;
    });
  } else {
    itemsArr.forEach((item, idx) => {
      let isAncient = item.name && item.name.startsWith("Ancient ");
      let setCount = getAncientSetCount();
      let setBonus = "";
      if (isAncient) {
        setBonus = `<br><span style="color:gold;font-weight:bold;">Ancient Set Bonus (${setCount}/5):</span>`;
        if (setCount >= 2) setBonus += `<br><span style="color:#ffd36b;">+20 DEF, +50 HP</span>`;
        if (setCount >= 4) setBonus += `<br><span style="color:#ffd36b;">+40 DEF, +100 HP</span>`;
        if (setCount === 5) setBonus += `<br><span style="color:#ffd36b;">+60 DEF, +150 HP</span>`;
      }
      content.innerHTML += `
        <div class="item-card${isAncient ? ' ancient-set' : ''}">
          <button class="bag-x-remove-btn" onclick="removeItem(${idx});event.stopPropagation()" title="Remove">&times;</button>
          <div class="item-name">${item.name.replace(/\s*\([^)]*\)/, "")}${item.count > 1 ? ` (x${item.count})` : ""}</div>
          <button class="bag-equip-btn" onclick="equipBagItem(${idx});event.stopPropagation()">Equip</button>
          <div class="item-tooltip" style="display:none;position:absolute;left:110%;top:50%;transform:translateY(-50%);background:#18191c;color:#eee;padding:7px 13px;border-radius:8px;border:1px solid #444;white-space:nowrap;font-size:0.98em;box-shadow:0 2px 10px #0007;z-index:10;min-width:160px;">
            <b>${item.name}</b>
            ${item.description ? `<br><span style="color:#aaa;">${item.description}</span>` : ""}
            ${item.attackPower ? `<br>ATK: <b>+${item.attackPower}</b>` : ""}
            ${item.defense ? `<br>DEF: <b>+${item.defense}</b>` : ""}
            ${item.health ? `<br>HP: <b>+${item.health}</b>` : ""}
            ${item.heal ? `<br>Heals: <b>+${item.heal}</b>` : ""}
            ${item.count && item.type === "arrows" ? `<br>Arrows: <b>x${item.count}</b>` : ""}
            ${item.type ? `<br><span style="color:#ffba3a;">Type: ${item.type.charAt(0).toUpperCase() + item.type.slice(1)}</span>` : ""}
            ${setBonus}
          </div>
        </div>
      `;
    });
  }
  // Tooltip hover logic for all .item-card
  const cards = content.querySelectorAll('.item-card');
  cards.forEach(card => {
    const tip = card.querySelector('.item-tooltip');
    card.onmouseenter = () => { if (tip) tip.style.display = 'block'; };
    card.onmouseleave = () => { if (tip) tip.style.display = 'none'; };
    card.onmousemove = (e) => {
      if (tip) {
        tip.style.left = (e.offsetX + 30) + 'px';
        tip.style.top = (e.offsetY - 10) + 'px';
      }
    };
  });
}
function isHealingItem(item) {
  return typeof item.heal === "number" && item.heal > 0;
}
function isStatItem(item) {
  return (
    (typeof item.attackPower === "number" && item.attackPower > 0) ||
    (typeof item.defense === "number" && item.defense > 0) ||
    (typeof item.health === "number" && item.health > 0) ||
    ["weapon","armor","shield","ring","arrows","helmet","cloak","amulet","gloves","boots"].includes(item.type)
  );
}
function isEquipable(item) {
  return ["weapon","armor","shield","ring","arrows","helmet","cloak","amulet","gloves","boots"].includes(item.type);
}
function addItem(item) {
  // If gloves, boots, helmet, cloak, ring: assign random health/defense
  if (item.type === "gloves") {
    item.defense = 15;
    item.health = randomStat(30,100);
  }
  if (item.type === "boots") {
    item.defense = 20;
    item.health = randomStat(20,100);
  }
  if (item.type === "helmet") {
    item.defense = 25;
    item.health = randomStat(30,100);
  }
  if (item.type === "cloak") {
    item.defense = 35;
    item.health = randomStat(25,100);
  }
  if (item.type === "ring") {
    item.attackPower = item.attackPower || 2;
    item.health = randomStat(10,100);
  }

  // Helper to stack items
  function tryStack(arr, item) {
    for (let i = 0; i < arr.length; i++) {
      let it = arr[i];
      // Stack arrows by type only
      if (item.type === "arrows" && it.type === "arrows") {
        it.count = (it.count || 1) + (item.count || 1);
        return true;
      }
      // Stack other items by name, type, and key stats
      if (
        it.name === item.name &&
        it.type === item.type &&
        (it.attackPower === item.attackPower || (!it.attackPower && !item.attackPower)) &&
        (it.defense === item.defense || (!it.defense && !item.defense)) &&
        (it.heal === item.heal || (!it.heal && !item.heal)) &&
        (it.health === item.health || (!it.health && !item.health))
      ) {
        it.count = (it.count || 1) + (item.count || 1);
        return true;
      }
    }
    return false;
  }

  // Arrows always go to bag and stack
  if (item.type === "arrows") {
    if (!tryStack(player.bag, item)) {
      player.bag.push({ ...item, count: item.count || 1 });
    }
    logMsg(`Added ${item.name}${item.count > 1 ? ` (x${item.count})` : ""} to Bag.`);
  } else if (item.type === "material") {
    if (!tryStack(player.inventory, item)) {
      player.inventory.push({ ...item, count: item.count || 1 });
    }
    logMsg(`Added ${item.name}${item.count > 1 ? ` (x${item.count})` : ""} to Inventory.`);
  } else if (isHealingItem(item)) {
    if (!tryStack(player.inventory, item)) {
      player.inventory.push({ ...item, count: item.count || 1 });
    }
    logMsg(`Added ${item.name}${item.count > 1 ? ` (x${item.count})` : ""} to Inventory.`);
  } else if (isStatItem(item)) {
    if (!tryStack(player.bag, item)) {
      player.bag.push({ ...item, count: item.count || 1 });
    }
    logMsg(`Added ${item.name}${item.count > 1 ? ` (x${item.count})` : ""} to Bag.`);
  } else {
    if (!tryStack(player.inventory, item)) {
      player.inventory.push({ ...item, count: item.count || 1 });
    }
    logMsg(`Added ${item.name}${item.count > 1 ? ` (x${item.count})` : ""} to Inventory.`);
  }
  renderBagInv();
}
function selectBagInvItem(idx) {}

// --- PATCH: Multi-use healing items popup ---
function useItem(idx) {
  let itemsArr = baginvTab === "inventory" ? player.inventory : player.bag;
  const item = itemsArr[idx];
  if (isHealingItem(item)) {
    let maxHeal = getTotalMaxHealth();
    if (maxHeal <= 100) maxHeal = 100;
    if (item.count && item.count > 1) {
      // Show popup to ask how many to use
      showUseMultiplePopup(item, idx, itemsArr, maxHeal);
      return;
    }
    if (player.health < maxHeal) {
      player.health = Math.min(maxHeal, player.health + (item.heal||0));
      logMsg(`Used ${item.name}, healed for ${item.heal}.`);
      itemsArr.splice(idx, 1);
    } else {
      logMsg(`${item.name} can't be used at full health.`);
    }
  } else {
    logMsg(`You can't use ${item.name} directly.`);
  }
  updateAllStats();
  renderBagInv();
}

// Helper: show popup for multi-use healing items
function showUseMultiplePopup(item, idx, itemsArr, maxHeal) {
  // Remove existing popup if any
  let oldPopup = document.getElementById('multi-use-popup');
  if (oldPopup) oldPopup.remove();
  // Create popup
  const popup = document.createElement('div');
  popup.id = 'multi-use-popup';
  popup.style = 'position:fixed;z-index:9999;top:0;left:0;width:100vw;height:100vh;background:#191a1ecc;display:flex;align-items:center;justify-content:center;';
  popup.innerHTML = `
    <div style="background:#23252a;padding:32px 38px 24px 38px;border-radius:18px;box-shadow:0 2px 24px #000a;display:flex;flex-direction:column;align-items:center;">
      <div style="color:#ffba3a;font-size:1.2em;margin-bottom:18px;">Use ${item.name} (x${item.count})</div>
      <div style="margin-bottom:12px;">How many would you like to use?</div>
      <input id="multi-use-count" type="number" min="1" max="${item.count}" value="1" style="font-size:1.1em;padding:6px 18px;border-radius:7px;border:1.5px solid #444;background:#18191c;color:#fff;margin-bottom:18px;width:120px;outline:none;">
      <div style="margin-bottom:12px;color:#aaa;">Each heals for ${item.heal}. Current HP: ${player.health}/${maxHeal}</div>
      <div style="display:flex;gap:18px;">
        <button id="multi-use-confirm" style="font-size:1.1em;font-weight:bold;background:#ffba3a;color:#23252a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">Use</button>
        <button id="multi-use-cancel" style="font-size:1.1em;font-weight:bold;background:#35373e;color:#ffba3a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">Cancel</button>
      </div>
      <div id="multi-use-error" style="color:#ff4444;margin-top:10px;display:none;font-size:1em;"></div>
    </div>
  `;
  document.body.appendChild(popup);

  document.getElementById('multi-use-cancel').onclick = function() {
    popup.remove();
  };
  document.getElementById('multi-use-confirm').onclick = function() {
    const countInput = document.getElementById('multi-use-count');
    let useCount = parseInt(countInput.value, 10);
    if (isNaN(useCount) || useCount < 1 || useCount > item.count) {
      document.getElementById('multi-use-error').textContent = 'Enter a valid number.';
      document.getElementById('multi-use-error').style.display = 'block';
      return;
    }
    let totalHeal = useCount * (item.heal || 0);
    let healed = Math.min(maxHeal - player.health, totalHeal);
    if (player.health >= maxHeal) {
      document.getElementById('multi-use-error').textContent = `${item.name} can't be used at full health.`;
      document.getElementById('multi-use-error').style.display = 'block';
      return;
    }
    player.health = Math.min(maxHeal, player.health + totalHeal);
    item.count -= useCount;
    if (item.count <= 0) itemsArr.splice(idx, 1);
    logMsg(`Used ${useCount} ${item.name}${useCount > 1 ? 's' : ''}, healed for ${healed}.`);
    updateAllStats();
    renderBagInv();
    popup.remove();
  };
  document.getElementById('multi-use-count').addEventListener('keydown', function(e) {
    if (e.key === 'Enter') document.getElementById('multi-use-confirm').click();
  });
}
function equipItem(idx) {
  let item = player.inventory[idx];
  let slot = item.type;
  if (!isEquipable(item)) {
    logMsg(`Cannot equip ${item.name}.`);
    return;
  }
  let old = player.equipment[slot];
  if (old) player.bag.push(old);
  player.equipment[slot] = item;
  player.inventory.splice(idx, 1);
  logMsg(`Equipped ${item.name}.`);
  updateAllStats();
  renderBagInv();
}
function removeItem(idx) {
  let itemsArr = baginvTab === "inventory" ? player.inventory : player.bag;
  let item = itemsArr.splice(idx, 1)[0];
  logMsg(`Removed ${item.name}.`);
  renderBagInv();
}
function equipBagItem(idx) {
  let item = player.bag[idx];
  let slot = item.type;
  let old = player.equipment[slot];
  if (old) player.bag.push(old);
  player.equipment[slot] = item;
  player.bag.splice(idx, 1);
  logMsg(`Equipped ${item.name}.`);
  updateAllStats();
  renderBagInv();
}
function getRandomEnemy() {
  let e = enemyPool[Math.floor(Math.random() * enemyPool.length)];
  return {
    name: e.name,
    health: e.maxHealth,
    maxHealth: e.maxHealth,
    minAttack: e.minAttack,
    maxAttack: e.maxAttack,
    xp: e.xp
  };
}
function showEnemy() {
  currentEnemy = getRandomEnemy();
  inCombat = true;
  renderEnemyEncounter();
  logMsg(`A wild <b>${currentEnemy.name}</b> appears!`);
}
function renderEnemyEncounter() {
  const enemyDiv = document.getElementById('enemy-encounter');
  if (!currentEnemy) {
    enemyDiv.style.display = "none";
    return;
  }
  enemyDiv.style.display = "flex";
  const percent = Math.max(0, 100 * currentEnemy.health/currentEnemy.maxHealth);
  document.getElementById('enemy-hp-bar-inner').style.width = percent + "%";
  document.getElementById('enemy-hp-bar-text').textContent = `${currentEnemy.health}/${currentEnemy.maxHealth}`;
  const imageBox = document.getElementById('enemy-image');
  imageBox.innerHTML = `${currentEnemy.name}`;
  document.getElementById('enemy-name-label').textContent = currentEnemy.name;
}
function clearEnemy() {
  currentEnemy = null;
  inCombat = false;
  renderEnemyEncounter();
}
function showHitsplat(damage) {
  const imageBox = document.getElementById('enemy-image');
  const splat = document.createElement('div');
  splat.className = "hitsplat";
  splat.textContent = `-${damage}`;
  imageBox.appendChild(splat);
  setTimeout(()=>{ if (imageBox.contains(splat)) imageBox.removeChild(splat); }, 850);
}
function attackEnemy() {
  if (!currentEnemy || !inCombat) {
    logMsg("No enemy to attack.");
    return;
  }
  let pAtk = (player.equipment.weapon ? player.equipment.weapon.attackPower||8 : 6)
      + (player.equipment.ring ? player.equipment.ring.attackPower||0 : 0);
  let hit = 0;
  if(player.equipment.weapon && (player.equipment.weapon.name && player.equipment.weapon.name.toLowerCase().includes('bow') || player.equipment.weapon.isBow)) {
    // Bow logic
    if(pAtk < 25) hit = randomStat(1,50);
    else if(pAtk >= 50) hit = randomStat(1,100);
    else hit = randomStat(20,75);
  } else {
    // Weapon logic
    if(pAtk < 25) hit = randomStat(1,50);
    else if(pAtk >= 50) hit = randomStat(1,100);
    else hit = randomStat(20,75);
  }
  currentEnemy.health = Math.max(0, currentEnemy.health - hit);
  showHitsplat(hit);
  logMsg(`You hit the <b>${currentEnemy.name}</b> for <b>${hit}</b>!`);
  renderEnemyEncounter();
  if (currentEnemy.health <= 0) {
    let goldDrop = Math.floor(Math.random() * 51);
    player.gold += goldDrop;
    let randomItem = JSON.parse(JSON.stringify(items[Math.floor(Math.random() * items.length)]));
    addItem(randomItem);
    let goldMsg = goldDrop > 0 ? ` <span style=\"color:gold;\">+${goldDrop} Gold</span>` : '';
    logMsg(`<span style=\"color:#90ee90\"><b>You defeated the ${currentEnemy.name}!</b></span> +${currentEnemy.xp} XP${goldMsg} and found ${randomItem.name}`);
    player.experience += currentEnemy.xp;
    checkLevelUp();
    clearEnemy();
    renderPlayerStats();
    return;
  }
  setTimeout(()=>{ enemyAttack(); }, 700);
}
function enemyAttack() {
  if (!currentEnemy || !inCombat) return;
  let pDef = (player.equipment.armor ? player.equipment.armor.defense||0 : 0)
    + (player.equipment.helmet ? player.equipment.helmet.defense||0 : 0)
    + (player.equipment.shield ? player.equipment.shield.defense||0 : 0)
    + (player.equipment.cloak ? player.equipment.cloak.defense||0 : 0)
    + (player.equipment.boots ? player.equipment.boots.defense||0 : 0)
    + (player.equipment.amulet ? player.equipment.amulet.defense||0 : 0)
    + (player.equipment.gloves ? player.equipment.gloves.defense||0 : 0);
  let min = currentEnemy.minAttack;
  let max = currentEnemy.maxAttack;
  let eHit = Math.max(0, Math.floor(min + Math.random()*(max-min+1)) - Math.floor(pDef/3));
  player.health = Math.max(0, player.health - eHit);
  logMsg(`<span style="color:#f66">The ${currentEnemy.name} hits you for <b>${eHit}</b>!</span>`);
  renderPlayerStats();
  if (player.health <= 0) {
    logMsg(`<span style="color:#f44;font-weight:bold;">You died! Respawning at town...</span>`);
    respawnPlayer();
    clearEnemy();
  }
}
function runFromEnemy() {
  if (!currentEnemy || !inCombat) return;
  if (Math.random() < 0.6) {
    logMsg(`<span style="color:#9cf">You ran away from the ${currentEnemy.name}!</span>`);
    clearEnemy();
  } else {
    logMsg(`<span style="color:#f77">You failed to run away!</span>`);
    setTimeout(enemyAttack, 500);
  }
}
function openChest() {
  chestOpen = true;
  let reward = Math.floor(Math.random()*500)+1;
  chestReward = reward;
  player.gold += reward;
  document.getElementById('chest-reward').textContent = `You found ${reward} gold!`;
  document.getElementById('chest-encounter').style.display = "flex";
  // Remove chest from map
  mapData[playerPosition.y][playerPosition.x] = { type: "discovered", name: "" };
  renderMap();
  renderPlayerStats();
}
function closeChest() {
  chestOpen = false;
  document.getElementById('chest-encounter').style.display = "none";
}
function openBank() {
  document.getElementById('bank-modal-bg').style.display = 'flex';
  renderBank();
}
function closeBank() {
  document.getElementById('bank-modal-bg').style.display = 'none';
}
function renderBank() {
  const bankList = document.getElementById('bank-list');
  const invList = document.getElementById('bank-inv-list');
  bankList.innerHTML = "";
  invList.innerHTML = "";
  if (!player.bank.length) bankList.innerHTML = "<div id='bank-empty-msg'>No items in bank.</div>";
  player.bank.forEach((item, idx) => {
    bankList.innerHTML += `
      <div class="bank-item-card">
        <span>${item.name}</span>
        <button class="bank-action-btn" onclick="removeFromBank(${idx})">Withdraw</button>
      </div>
    `;
  });
  let invItems = [...player.inventory, ...player.bag];
  if (!invItems.length) invList.innerHTML = "<div id='bank-empty-msg'>No items to deposit.</div>";
  invItems.forEach((item, idx) => {
    invList.innerHTML += `
      <div class="bank-item-card">
        <span>${item.name}</span>
        <button class="bank-action-btn" onclick="addToBank(${idx})">Deposit</button>
      </div>
    `;
  });
}
function addToBank(idx) {
  let itemsArr = [...player.inventory, ...player.bag];
  let item = itemsArr[idx];
  let invIdx = player.inventory.findIndex(i => i === item);
  if (invIdx !== -1) player.inventory.splice(invIdx, 1);
  else player.bag.splice(player.bag.findIndex(i => i === item), 1);
  player.bank.push(item);
  logMsg(`Deposited ${item.name} to the bank.`);
  renderBagInv(); renderBank();
}
function removeFromBank(idx) {
  let item = player.bank.splice(idx, 1)[0];
  if (isEquipable(item)) player.bag.push(item);
  else player.inventory.push(item);
  logMsg(`Withdrew ${item.name} from the bank.`);
  renderBagInv(); renderBank();
}
function explore() {
  // Deprecated, use startExplore
  startExplore();
}
function visitShop() { logMsg("Opening shop... (implement backend)"); }
function showCommands() {
  logMsg(`Commands: /explore, /attack, /shop, /bank, /status, /inventory, /bag, /buy, /sell, /equipment, /unequip`);
}
function searchItem() {
  searchTerm = document.getElementById('item-search').value.toLowerCase();
  renderBagInv();
}
function logMsg(msg) {
  let logDiv = document.getElementById('game-log');
  logDiv.innerHTML += `<div>${msg}</div>`;
  logDiv.scrollTop = logDiv.scrollHeight;
}
function checkLevelUp() {
  let nextLvXp = 60 + (player.level-1)*45;
  if (player.experience >= nextLvXp) {
    player.level += 1;
    player.maxHealth += 18;
    player.health = player.maxHealth;
    player.experience -= nextLvXp;
    logMsg(`<span style="color:gold;font-weight:bold;">You leveled up to Level ${player.level}! Max HP increased.</span>`);
    updateAllStats();
  }
}
function respawnPlayer() {
  player.health = Math.floor(player.maxHealth * 0.7);
  playerPosition = { x: Math.floor(mapSize/2), y: Math.floor(mapSize/2) };
  discovered[playerPosition.y][playerPosition.x] = true;
  renderPlayerStats();
  renderMap();
}
function renderDerivedStats() {
  let atk = getTotalAttack();
  let def = getTotalDefense();
  let hp = getTotalMaxHealth();
  let stats = [
    `<li><span class="derived-label">Attack:</span> ${atk}</li>`,
    `<li><span class="derived-label">Defense:</span> ${def}</li>`,
    `<li><span class="derived-label">Max Health:</span> ${hp}</li>`
  ];
  document.getElementById('derived-stats-list').innerHTML = stats.join('');
}
// --- TOWN POPUP LOGIC ---
if (!document.getElementById('town-popup')) {
  const townPopup = document.createElement('div');
  townPopup.id = 'town-popup';
  townPopup.style = 'display:none;position:fixed;z-index:4000;top:0;left:0;width:100vw;height:100vh;background:#191a1e99;align-items:center;justify-content:center;';
  townPopup.innerHTML = `
    <div style="background:#23252a;padding:32px 38px 24px 38px;border-radius:18px;box-shadow:0 2px 24px #000a;display:flex;flex-direction:column;align-items:center;">
      <div id="town-popup-title" style="color:#ffba3a;font-size:1.3em;margin-bottom:18px;"></div>
      <div style="margin-bottom:18px;">Do you wish to visit this town?</div>
      <div style="display:flex;gap:18px;">
        <button id="town-popup-yes" style="font-size:1.1em;font-weight:bold;background:#ffba3a;color:#23252a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">Yes</button>
        <button id="town-popup-no" style="font-size:1.1em;font-weight:bold;background:#35373e;color:#ffba3a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">No</button>
      </div>
    </div>
  `;
  document.body.appendChild(townPopup);
}
if (!document.getElementById('special-seller-popup')) {
  const sellerPopup = document.createElement('div');
  sellerPopup.id = 'special-seller-popup';
  sellerPopup.style = 'display:none;position:fixed;z-index:4100;top:0;left:0;width:100vw;height:100vh;background:#191a1e99;align-items:center;justify-content:center;';
  sellerPopup.innerHTML = `
    <div style="background:#23252a;padding:32px 38px 24px 38px;border-radius:18px;box-shadow:0 2px 24px #000a;display:flex;flex-direction:column;align-items:center;min-width:340px;">
      <div style="color:#ffba3a;font-size:1.3em;margin-bottom:18px;">Special Seller</div>
      <div style="margin-bottom:18px;">Welcome, traveler! Here are my rare wares:</div>
      <div id="special-seller-items" style="margin-bottom:18px;width:100%;"></div>
      <button onclick="closeSpecialSeller()" style="font-size:1.1em;font-weight:bold;background:#35373e;color:#ffba3a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">Close</button>
    </div>
  `;
  document.body.appendChild(sellerPopup);


// Ensure showSpecialSeller is globally available and generates items and buy buttons

  // Generate 6 random high-stat items under 500 gold
  let specialItems = [];
  for (let i = 0; i < 6; ++i) {
    let type = ["armor", "weapon", "potion", "helmet", "boots", "shield", "cloak", "amulet", "ring", "gloves"][Math.floor(Math.random()*10)];
    let item = { price: Math.floor(Math.random()*200)+250 };
    if (type === "armor") {
      item.name = "Special Armor";
      item.type = "armor";
      item.defense = Math.floor(Math.random()*30)+50;
    } else if (type === "weapon") {
      item.name = "Special Sword";
      item.type = "weapon";
      item.attackPower = Math.floor(Math.random()*20)+45;
    } else if (type === "potion") {
      item.name = "Mega Potion";
      item.type = "potion";
      item.heal = Math.floor(Math.random()*50)+100;
    } else if (type === "helmet") {
      item.name = "Special Helmet";
      item.type = "helmet";
      item.defense = Math.floor(Math.random()*15)+25;
      item.health = Math.floor(Math.random()*30)+25;
    } else if (type === "boots") {
      item.name = "Special Boots";
      item.type = "boots";
      item.defense = Math.floor(Math.random()*10)+20;
      item.health = Math.floor(Math.random()*20)+20;
    } else if (type === "shield") {
      item.name = "Special Shield";
      item.type = "shield";
      item.defense = Math.floor(Math.random()*20)+30;
    } else if (type === "cloak") {
      item.name = "Special Cloak";
      item.type = "cloak";
      item.defense = Math.floor(Math.random()*15)+30;
      item.health = Math.floor(Math.random()*20)+20;
    } else if (type === "amulet") {
      item.name = "Special Amulet";
      item.type = "amulet";
      item.defense = Math.floor(Math.random()*10)+15;
    } else if (type === "ring") {
      item.name = "Special Ring";
      item.type = "ring";
      item.attackPower = Math.floor(Math.random()*5)+5;
      item.health = Math.floor(Math.random()*20)+10;
    } else if (type === "gloves") {
      item.name = "Special Gloves";
      item.type = "gloves";
      item.defense = Math.floor(Math.random()*10)+15;
      item.health = Math.floor(Math.random()*20)+10;
    }
    item.price = Math.min(item.price, 499);
    specialItems.push(item);
  }
  let html = '';
  specialItems.forEach((item, idx) => {
    let stat = '';
    if(item.defense) stat += ` DEF: <b>+${item.defense}</b>`;
    if(item.attackPower) stat += ` ATK: <b>+${item.attackPower}</b>`;
    if(item.heal) stat += ` HEAL: <b>+${item.heal}</b>`;
    if(item.health) stat += ` HP: <b>+${item.health}</b>`;
    html += `<div style="background:#18191c;border-radius:8px;padding:10px 14px;margin-bottom:8px;display:flex;align-items:center;justify-content:space-between;">
      <div><b>${item.name}</b>${stat}</div>
      <div><span style="color:gold;font-weight:bold;">${item.price} Gold</span> <button onclick="buySpecialSellerItem(${idx})" style="margin-left:10px;background:#ffba3a;color:#23252a;border:none;border-radius:6px;padding:6px 18px;font-weight:bold;cursor:pointer;">Buy</button></div>
    </div>`;
  });

};


let lastTownVisited = null;
function showTownPopup(townName) {
  lastTownVisited = townName;
  document.getElementById('town-popup-title').textContent = `You arrived at ${townName}!`;
  document.getElementById('town-popup').style.display = 'flex';
}
document.getElementById('town-popup-yes').onclick = function() {
  document.getElementById('town-popup').style.display = 'none';
  if (!visitedTowns[lastTownVisited]) {
    showSpecialSeller();
    visitedTowns[lastTownVisited] = true;
    renderMap();
  }
};
document.getElementById('town-popup-no').onclick = function() {
  document.getElementById('town-popup').style.display = 'none';
};
// --- PATCH renderMap to show checkmark for visited towns ---
const origRenderMap = renderMap;
renderMap = function() {
  const map = document.getElementById('game-map');
  map.innerHTML = "";
  for (let y = 0; y < mapSize; ++y) {
    for (let x = 0; x < mapSize; ++x) {
      let cellClass = "map-cell";
      let label = "";
      let cell = mapData[y][x];
      // Player
      if (x === playerPosition.x && y === playerPosition.y) {
        cellClass += " player";
      }
      // Central Town
      if (cell.type === "central-town") {
        cellClass += " central-town";
        label = "C";
      }
      // Other Towns
      else if (cell.type === "town") {
        cellClass += " town";
        if (visitedTowns[cell.name]) {
          label = "✔";
        } else {
          label = "T";
        }
      }
      // Chest
      else if (cell.type === "chest") {
        cellClass += " chest";
        label = "💰";
      }
      // Area
      else if (cell.type === "area") {
        if (discovered[y][x]) {
          cellClass += " discovered";
          label = cell.name[0];
        } else {
          cellClass += " area";
          label = cell.name[0];
        }
      }
      // Discovered
      else if (cell.type === "discovered") {
        cellClass += " discovered";
        label = "";
      }
      // Undiscovered
      if (!discovered[y][x] && cell.type !== "central-town" && cell.type !== "town" && cell.type !== "chest") {
        cellClass += " undiscovered";
        label = "";
      }
      // Show player icon
      if (x === playerPosition.x && y === playerPosition.y) {
        label = "🧑";
      }
      map.innerHTML += `<div class="${cellClass}" data-x="${x}" data-y="${y}" onclick="mapCellClick(${x},${y})" title="${cell.type === 'area' || cell.type === 'discovered' ? cell.name : cell.name || ''}">${label}</div>`;
    }
  }
  let areaLabel = "";
  let cell = mapData[playerPosition.y][playerPosition.x];
  if (cell.type === "central-town") areaLabel = "Area: Central Town";
  else if (cell.type === "town") areaLabel = "Area: " + cell.name;
  else if (cell.type === "chest") areaLabel = "Area: Chest";
  else if (!discovered[playerPosition.y][playerPosition.x]) areaLabel = "Area: Not Discovered";
  else areaLabel = "Area: " + (cell.name || "Discovered");
  document.getElementById("map-area-label").textContent = areaLabel;
};
function refreshShopItems() {
  // Helper to generate a random item by type
  function generateItem(type) {
    switch (type) {
      case "armor":
        {
          let def = Math.floor(Math.random() * 106) + 20;
          let price = Math.floor(50 + (def - 20) * 8);
          return {
            name: `Armor (${def} DEF)`,
            type: 'armor',
            defense: def,
            price: price,
            description: `Protective armor.`
          };
        }
      case "weapon":
        {
          let atk = Math.floor(Math.random() * 91) + 10;
          let price = Math.floor(30 + (atk - 10) * 5);
          return {
            name: `Weapon (${atk} ATK)`,
            type: 'weapon',
            attackPower: atk,
            price: price,
            description: `A sharp weapon.`
          };
        }
      case "potion":
        {
          let heal = Math.floor(Math.random() * 81) + 20;
          let price = Math.floor(10 + (heal - 20) * 3);
          return {
            name: `Potion (+${heal} HP)`,
            type: 'potion',
            heal: heal,
            price: price,
            description: `Heals for ${heal} HP.`
          };
        }
      case "helmet":
        {
          let def = Math.floor(Math.random() * 41) + 10;
          let hp = Math.floor(Math.random() * 61) + 20;
          let price = Math.floor(40 + def * 6 + hp * 2);
          return {
            name: `Helmet (${def} DEF, ${hp} HP)`,
            type: 'helmet',
            defense: def,
            health: hp,
            price: price,
            description: `Sturdy helmet.`
          };
        }
      case "boots":
        {
          let def = Math.floor(Math.random() * 31) + 10;
          let hp = Math.floor(Math.random() * 41) + 10;
          let price = Math.floor(30 + def * 5 + hp * 2);
          return {
            name: `Boots (${def} DEF, ${hp} HP)`,
            type: 'boots',
            defense: def,
            health: hp,
            price: price,
            description: `Protective boots.`
          };
        }
      case "shield":
        {
          let def = Math.floor(Math.random() * 41) + 20;
          let price = Math.floor(50 + def * 7);
          return {
            name: `Shield (${def} DEF)`,
            type: 'shield',
            defense: def,
            price: price,
            description: `Sturdy shield.`
          };
        }
      case "cloak":
        {
          let def = Math.floor(Math.random() * 26) + 15;
          let hp = Math.floor(Math.random() * 41) + 10;
          let price = Math.floor(60 + def * 5 + hp * 2);
          return {
            name: `Cloak (${def} DEF, ${hp} HP)`,
            type: 'cloak',
            defense: def,
            health: hp,
            price: price,
            description: `Mystical cloak.`
          };
        }
      case "amulet":
        {
          let def = Math.floor(Math.random() * 16) + 5;
          let price = Math.floor(100 + def * 12);
          return {
            name: `Amulet (+${def} DEF)`,
            type: 'amulet',
            defense: def,
            price: price,
            description: `Mystic amulet.`
          };
        }
      case "ring":
        {
          let atk = Math.floor(Math.random() * 6) + 2;
          let hp = Math.floor(Math.random() * 51) + 10;
          let price = Math.floor(120 + atk * 20 + hp * 3);
          return {
            name: `Ring (+${atk} ATK, +${hp} HP)`,
            type: 'ring',
            attackPower: atk,
            health: hp,
            price: price,
            description: `Magical ring.`
          };
        }
      case "gloves":
        {
          let def = Math.floor(Math.random() * 21) + 10;
          let hp = Math.floor(Math.random() * 31) + 10;
          let price = Math.floor(25 + def * 4 + hp * 2);
          return {
            name: `Gloves (${def} DEF, ${hp} HP)`,
            type: 'gloves',
            defense: def,
            health: hp,
            price: price,
            description: `Strong gloves.`
          };
        }
      case "full-armor-set":
        {
          let setDef = Math.floor(Math.random() * 101) + 100;
          let setHp = Math.floor(Math.random() * 201) + 200;
          let price = Math.floor(1000 + setDef * 15 + setHp * 5);
          return {
            name: `Full Armor Set (${setDef} DEF, ${setHp} HP)`,
            type: 'armor-set',
            defense: setDef,
            health: setHp,
            price: Math.min(price, 5000),
            description: `Contains Armor, Helmet, Boots, Shield, Cloak, Gloves.`
          };
        }
      case "arrows":
        return {
          name: 'Arrows (x100)',
          type: 'arrows',
          count: 100,
          price: 15,
          description: 'A pack of 100 arrows.'
        };
      case "bow":
        {
          let batk = Math.floor(Math.random() * 131) + 20;
          let price = Math.floor(60 + (batk - 20) * 3.5);
          return {
            name: `Bow (${batk} ATK)`,
            type: 'weapon',
            attackPower: batk,
            isBow: true,
            price: price,
            description: `A powerful bow.`
          };
        }
      default:
        return null;
    }
  }

  // List of types to pick from for variety
  const types = [
    "armor", "weapon", "potion", "helmet", "boots", "shield", "cloak", "amulet", "ring", "gloves", "full-armor-set", "arrows", "bow"
  ];

  // Shuffle and pick 12 types for shop
  let shopTypes = types.slice();
  let shopItems = [];
  while (shopItems.length < 12) {
    let t = shopTypes[Math.floor(Math.random() * shopTypes.length)];
    let item = generateItem(t);
    if (item) shopItems.push(item);
    // Remove type if already picked to avoid duplicates, except for potions/arrows
    if (!["potion", "arrows"].includes(t)) {
      shopTypes = shopTypes.filter(x => x !== t);
    }
    if (shopTypes.length === 0) shopTypes = types.slice();
  }

  window._shopItems = shopItems;
  renderShopItems();
}

// Patch buyShopItem to replace bought item with a new random item of same type
const origBuyShopItem = buyShopItem;
buyShopItem = function(idx) {
  let item = window._shopItems[idx];
  if (player.gold < item.price) {
    logMsg('Not enough gold!');
    return;
  }
  player.gold -= item.price;
  // If buying a full armor set, add all set items
  if (item.type === 'armor-set') {
    let baseDef = Math.floor(item.defense / 6);
    let baseHp = Math.floor(item.health / 6);
    let setItems = [
      { name: 'Set Armor', type: 'armor', defense: baseDef, health: baseHp, price: 0, description: 'Part of full set.' },
      { name: 'Set Helmet', type: 'helmet', defense: baseDef, health: baseHp, price: 0, description: 'Part of full set.' },
      { name: 'Set Gloves', type: 'gloves', defense: baseDef, health: baseHp, price: 0, description: 'Part of full set.' },
      { name: 'Set Boots', type: 'boots', defense: baseDef, health: baseHp, price: 0, description: 'Part of full set.' },
      { name: 'Set Cloak', type: 'cloak', defense: baseDef, health: baseHp, price: 0, description: 'Part of full set.' },
      { name: 'Set Shield', type: 'shield', defense: baseDef, price: 0, description: 'Part of full set.' }
    ];
    setItems.forEach(si => addItem(JSON.parse(JSON.stringify(si))));
    logMsg(`Bought Full Armor Set for ${item.price} gold from the Shop. All set items added!`);
  } else {
    addItem(JSON.parse(JSON.stringify(item)));
    logMsg(`Bought ${item.name} for ${item.price} gold from the Shop.`);
  }
  renderPlayerStats();

  // Replace bought item with a new random item of same type
  function generateItem(type) {
    // (same as above, but you can move the function outside if you want)
    switch (type) {
      case "armor": { let def = Math.floor(Math.random() * 106) + 20; let price = Math.floor(50 + (def - 20) * 8); return { name: `Armor (${def} DEF)`, type: 'armor', defense: def, price: price, description: `Protective armor.` }; }
      case "weapon": { let atk = Math.floor(Math.random() * 91) + 10; let price = Math.floor(30 + (atk - 10) * 5); return { name: `Weapon (${atk} ATK)`, type: 'weapon', attackPower: atk, price: price, description: `A sharp weapon.` }; }
      case "potion": { let heal = Math.floor(Math.random() * 81) + 20; let price = Math.floor(10 + (heal - 20) * 3); return { name: `Potion (+${heal} HP)`, type: 'potion', heal: heal, price: price, description: `Heals for ${heal} HP.` }; }
      case "helmet": { let def = Math.floor(Math.random() * 41) + 10; let hp = Math.floor(Math.random() * 61) + 20; let price = Math.floor(40 + def * 6 + hp * 2); return { name: `Helmet (${def} DEF, ${hp} HP)`, type: 'helmet', defense: def, health: hp, price: price, description: `Sturdy helmet.` }; }
      case "boots": { let def = Math.floor(Math.random() * 31) + 10; let hp = Math.floor(Math.random() * 41) + 10; let price = Math.floor(30 + def * 5 + hp * 2); return { name: `Boots (${def} DEF, ${hp} HP)`, type: 'boots', defense: def, health: hp, price: price, description: `Protective boots.` }; }
      case "shield": { let def = Math.floor(Math.random() * 41) + 20; let price = Math.floor(50 + def * 7); return { name: `Shield (${def} DEF)`, type: 'shield', defense: def, price: price, description: `Sturdy shield.` }; }
      case "cloak": { let def = Math.floor(Math.random() * 26) + 15; let hp = Math.floor(Math.random() * 41) + 10; let price = Math.floor(60 + def * 5 + hp * 2); return { name: `Cloak (${def} DEF, ${hp} HP)`, type: 'cloak', defense: def, health: hp, price: price, description: `Mystical cloak.` }; }
      case "amulet": { let def = Math.floor(Math.random() * 16) + 5; let price = Math.floor(100 + def * 12); return { name: `Amulet (+${def} DEF)`, type: 'amulet', defense: def, price: price, description: `Mystic amulet.` }; }
      case "ring": { let atk = Math.floor(Math.random() * 6) + 2; let hp = Math.floor(Math.random() * 51) + 10; let price = Math.floor(120 + atk * 20 + hp * 3); return { name: `Ring (+${atk} ATK, +${hp} HP)`, type: 'ring', attackPower: atk, health: hp, price: price, description: `Magical ring.` }; }
      case "gloves": { let def = Math.floor(Math.random() * 21) + 10; let hp = Math.floor(Math.random() * 31) + 10; let price = Math.floor(25 + def * 4 + hp * 2); return { name: `Gloves (${def} DEF, ${hp} HP)`, type: 'gloves', defense: def, health: hp, price: price, description: `Strong gloves.` }; }
      case "full-armor-set": { let setDef = Math.floor(Math.random() * 101) + 100; let setHp = Math.floor(Math.random() * 201) + 200; let price = Math.floor(1000 + setDef * 15 + setHp * 5); return { name: `Full Armor Set (${setDef} DEF, ${setHp} HP)`, type: 'armor-set', defense: setDef, health: setHp, price: Math.min(price, 5000), description: `Contains Armor, Helmet, Boots, Shield, Cloak, Gloves.` }; }
      case "arrows": return { name: 'Arrows (x100)', type: 'arrows', count: 100, price: 15, description: 'A pack of 100 arrows.' };
      case "bow": { let batk = Math.floor(Math.random() * 131) + 20; let price = Math.floor(60 + (batk - 20) * 3.5); return { name: `Bow (${batk} ATK)`, type: 'weapon', attackPower: batk, isBow: true, price: price, description: `A powerful bow.` }; }
      default: return null;
    }
  }
  window._shopItems[idx] = generateItem(item.type);
  renderShopItems();
};
function renderShopItems() {
  const shopDiv = document.getElementById('shop-items-list');
  if (!window._shopItems) return;
  shopDiv.innerHTML = "";
  window._shopItems.forEach((item, idx) => {
    shopDiv.innerHTML += `
      <div class="shop-item-card" style="background:#18191c;border-radius:8px;padding:10px 14px;margin-bottom:8px;display:flex;align-items:center;justify-content:space-between;position:relative;cursor:pointer;">
        <b>${item.name.replace(/\s*\([^)]*\)/, "")}</b>
        <div>
          <span style="color:gold;font-weight:bold;">${item.price} Gold</span>
          <button onclick="buyShopItem(${idx})" style="margin-left:10px;background:#ffba3a;color:#23252a;border:none;border-radius:6px;padding:6px 18px;font-weight:bold;cursor:pointer;">Buy</button>
        </div>
        <div class="shop-item-tooltip" style="display:none;position:absolute;left:110%;top:50%;transform:translateY(-50%);background:#18191c;color:#eee;padding:7px 13px;border-radius:8px;border:1px solid #444;white-space:nowrap;font-size:0.98em;box-shadow:0 2px 10px #0007;z-index:20;min-width:160px;">
          ${getShopItemTooltip(item)}
        </div>
      </div>
    `;
  });
  function getShopItemTooltip(item) {
    let lines = [];
    lines.push(`<b>${item.name.replace(/\s*\([^)]*\)/, "")}</b>`);
    if (item.description) lines.push(`<span style="color:#aaa;">${item.description}</span>`);
    if (item.attackPower) lines.push(`ATK: <b>+${item.attackPower}</b>`);
    if (item.defense) lines.push(`DEF: <b>+${item.defense}</b>`);
    if (item.health) lines.push(`HP: <b>+${item.health}</b>`);
    if (item.heal) lines.push(`Heals: <b>+${item.heal}</b>`);
    if (item.count && item.type === "arrows") lines.push(`Arrows: <b>x${item.count}</b>`);
    if (item.type) lines.push(`<span style="color:#ffba3a;">Type: ${item.type.charAt(0).toUpperCase() + item.type.slice(1)}</span>`);
    return lines.join('<br>');
  }

  // Add hover logic for tooltips
  const cards = shopDiv.querySelectorAll('.shop-item-card');
  cards.forEach(card => {
    const tip = card.querySelector('.shop-item-tooltip');
    card.onmouseenter = () => { if (tip) tip.style.display = 'block'; };
    card.onmouseleave = () => { if (tip) tip.style.display = 'none'; };
    card.onmousemove = (e) => {
      if (tip) {
        tip.style.left = (e.offsetX + 30) + 'px';
        tip.style.top = (e.offsetY - 10) + 'px';
      }
    };
  });
}

// --- PATCH: Remove ( ... ) from item names when adding to inventory/bag ---
const origAddItem = addItem;
addItem = function(item) {
  // Remove ( ... ) from item name for display in bag/inventory
  if (item && typeof item.name === "string") {
    item.name = item.name.replace(/\s*\([^)]*\)/, "");
  }
  origAddItem(item);
};
function buyShopItem(idx) {
  let item = window._shopItems[idx];
  if (player.gold < item.price) {
    logMsg('Not enough gold!');
    return;
  }
  player.gold -= item.price;
  // If buying a full armor set, add all set items
  if (item.type === 'armor-set') {
    let baseDef = Math.floor(item.defense / 6);
    let baseHp = Math.floor(item.health / 6);
    let setItems = [
      { name: 'Set Armor', type: 'armor', defense: baseDef, health: baseHp, price: 0, description: 'Part of full set.' },
      { name: 'Set Helmet', type: 'helmet', defense: baseDef, health: baseHp, price: 0, description: 'Part of full set.' },
      { name: 'Set Gloves', type: 'gloves', defense: baseDef, health: baseHp, price: 0, description: 'Part of full set.' },
      { name: 'Set Boots', type: 'boots', defense: baseDef, health: baseHp, price: 0, description: 'Part of full set.' },
      { name: 'Set Cloak', type: 'cloak', defense: baseDef, health: baseHp, price: 0, description: 'Part of full set.' },
      { name: 'Set Ring', type: 'ring', attackPower: 3, health: baseHp, price: 0, description: 'Part of full set.' }
    ];
    setItems.forEach(si => addItem(JSON.parse(JSON.stringify(si))));
    logMsg(`Bought Full Armor Set for ${item.price} gold from the Shop. All set items added!`);
  } else {
    addItem(JSON.parse(JSON.stringify(item)));
    logMsg(`Bought ${item.name} for ${item.price} gold from the Shop.`);
  }
  renderPlayerStats();
  renderShopItems();
}
document.getElementById('refresh-shop-btn').onclick = refreshShopItems;
refreshShopItems();

// --- SPECIAL SELLER: Only once per town, mark with checkmark ---
let visitedTowns = {};
const origShowTownPopup = showTownPopup;
showTownPopup = function(townName) {
  lastTownVisited = townName;
  document.getElementById('town-popup-title').textContent = `You arrived at ${townName}!`;
  document.getElementById('town-popup').style.display = 'flex';
};
document.getElementById('town-popup-yes').onclick = function() {
  document.getElementById('town-popup').style.display = 'none';
  if (!visitedTowns[lastTownVisited]) {
    showSpecialSeller();
    visitedTowns[lastTownVisited] = true;
    renderMap();
  }
};
document.getElementById('town-popup-no').onclick = function() {
  document.getElementById('town-popup').style.display = 'none';
};
// --- START GAME BUTTON LOGIC ---
document.getElementById('username-submit').onclick = function() {
  const input = document.getElementById('username-input');
  const error = document.getElementById('username-error');
  const val = input.value.trim();
  if (!val) {
    error.textContent = 'Please enter a username.';
    error.style.display = 'block';
    return;
  }
  player.name = val;
  error.style.display = 'none';
  document.getElementById('username-overlay').style.display = 'none';

  // Initialize map and player position before rendering
  initMap();
  playerPosition = { x: Math.floor(mapSize/2), y: Math.floor(mapSize/2) };
  discovered[playerPosition.y][playerPosition.x] = true;

  renderPlayerStats();
  renderDerivedStats();
  renderEquipment();
  renderBagInv();
  renderMap();

  // Play music if available
  const music = document.getElementById('username-music');
  if (music) {
    music.currentTime = 0;
    music.play().catch(() => {
      document.body.addEventListener('click', () => music.play(), { once: true });
    });
  }
};
// Allow Enter key to submit
document.getElementById('username-input').addEventListener('keydown', function(e) {
  if (e.key === 'Enter') document.getElementById('username-submit').click();
});
function showSpecialSeller() {
  // Generate 6 random high-stat items under 500 gold
  let specialItems = [];
  for (let i = 0; i < 6; ++i) {
    let type = ["armor", "weapon", "potion", "helmet", "boots", "shield", "cloak", "amulet", "ring", "gloves"][Math.floor(Math.random()*10)];
    let item = { price: Math.floor(Math.random()*200)+250 };
    if (type === "armor") {
      item.name = "Special Armor";
      item.type = "armor";
      item.defense = Math.floor(Math.random()*30)+50;
    } else if (type === "weapon") {
      item.name = "Special Sword";
      item.type = "weapon";
      item.attackPower = Math.floor(Math.random()*20)+45;
    } else if (type === "potion") {
      item.name = "Mega Potion";
      item.type = "potion";
      item.heal = Math.floor(Math.random()*50)+100;
    } else if (type === "helmet") {
      item.name = "Special Helmet";
      item.type = "helmet";
      item.defense = Math.floor(Math.random()*15)+25;
      item.health = Math.floor(Math.random()*30)+25;
    } else if (type === "boots") {
      item.name = "Special Boots";
      item.type = "boots";
      item.defense = Math.floor(Math.random()*10)+20;
      item.health = Math.floor(Math.random()*20)+20;
    } else if (type === "shield") {
      item.name = "Special Shield";
      item.type = "shield";
      item.defense = Math.floor(Math.random()*20)+30;
    } else if (type === "cloak") {
      item.name = "Special Cloak";
      item.type = "cloak";
      item.defense = Math.floor(Math.random()*15)+30;
      item.health = Math.floor(Math.random()*20)+20;
    } else if (type === "amulet") {
      item.name = "Special Amulet";
      item.type = "amulet";
      item.defense = Math.floor(Math.random()*10)+15;
    } else if (type === "ring") {
      item.name = "Special Ring";
      item.type = "ring";
      item.attackPower = Math.floor(Math.random()*5)+5;
      item.health = Math.floor(Math.random()*20)+10;
    } else if (type === "gloves") {
      item.name = "Special Gloves";
      item.type = "gloves";
      item.defense = Math.floor(Math.random()*10)+15;
      item.health = Math.floor(Math.random()*20)+10;
    }
    item.price = Math.min(item.price, 499);
    specialItems.push(item);
  }
  let html = '';
  specialItems.forEach((item, idx) => {
    let stat = '';
    if(item.defense) stat += ` DEF: <b>+${item.defense}</b>`;
    if(item.attackPower) stat += ` ATK: <b>+${item.attackPower}</b>`;
    if(item.heal) stat += ` HEAL: <b>+${item.heal}</b>`;
    if(item.health) stat += ` HP: <b>+${item.health}</b>`;
    html += `<div style="background:#18191c;border-radius:8px;padding:10px 14px;margin-bottom:8px;display:flex;align-items:center;justify-content:space-between;">
      <div><b>${item.name}</b>${stat}</div>
      <div><span style="color:gold;font-weight:bold;">${item.price} Gold</span> <button onclick="buySpecialSellerItem(${idx})" style="margin-left:10px;background:#ffba3a;color:#23252a;border:none;border-radius:6px;padding:6px 18px;font-weight:bold;cursor:pointer;">Buy</button></div>
    </div>`;
  });
  window._specialSellerItems = specialItems;
  document.getElementById('special-seller-items').innerHTML = html;
  document.getElementById('special-seller-popup').style.display = 'flex';
}
function closeSpecialSeller() {
  document.getElementById('special-seller-popup').style.display = 'none';
}
function buySpecialSellerItem(itemIndex) {
  let item = window._specialSellerItems[itemIndex];
  if (!item) return;
  if (player.gold < item.price) {
    logMsg('Not enough gold!');
    return;
  }
  player.gold -= item.price;
  addItem(JSON.parse(JSON.stringify(item)));
  logMsg(`Bought ${item.name} for ${item.price} gold from the Special Seller.`);
  renderPlayerStats();
  closeSpecialSeller();
}
// --- Save/Load Game as JSON File ---
// Save button logic: only save UI/player state, not map
document.getElementById('main-save-btn').onclick = function() {
  // Only save player, visitedTowns, playerPosition, inventory, bag, equipment, bank, gold, experience, level, health, bankGold
  const saveData = {
    player: {
      name: player.name,
      health: player.health,
      maxHealth: player.maxHealth,
      gold: player.gold,
      experience: player.experience,
      level: player.level,
      bankGold: player.bankGold,
      inventory: player.inventory,
      bag: player.bag,
      equipment: player.equipment,
      bank: player.bank
    },
    visitedTowns: {...visitedTowns},
    playerPosition: {...playerPosition}
    // Exclude mapData, discovered, towns, chests
  };
  const blob = new Blob([JSON.stringify(saveData, null, 2)], {type: "application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  const dateStr = new Date().toISOString().replace(/[:.]/g, '-');
  a.href = url;
  a.download = `game-ui-save-${dateStr}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  alert('Save data saved!');
};

// Add a file input for loading (used by overlay Load button)
if (!document.getElementById('main-load-input')) {
  const loadInput = document.createElement('input');
  loadInput.type = 'file';
  loadInput.accept = '.json,application/json';
  loadInput.style.display = 'none';
  loadInput.id = 'main-load-input';
  document.body.appendChild(loadInput);

  loadInput.addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(evt) {
      try {
        const saveData = JSON.parse(evt.target.result);
        if (saveData.player && saveData.visitedTowns && saveData.playerPosition) {
          // Defensive deep assignment to avoid undefined errors
          initMap(); // Ensure mapData, discovered, towns, chests are initialized
          player.name = saveData.player.name || "Hero";
          player.health = typeof saveData.player.health === "number" ? saveData.player.health : 100;
          player.maxHealth = typeof saveData.player.maxHealth === "number" ? saveData.player.maxHealth : 100;
          player.gold = typeof saveData.player.gold === "number" ? saveData.player.gold : 0;
          player.experience = typeof saveData.player.experience === "number" ? saveData.player.experience : 0;
          player.level = typeof saveData.player.level === "number" ? saveData.player.level : 1;
          player.bankGold = typeof saveData.player.bankGold === "number" ? saveData.player.bankGold : 0;
          player.inventory = Array.isArray(saveData.player.inventory) ? JSON.parse(JSON.stringify(saveData.player.inventory)) : [];
          player.bag = Array.isArray(saveData.player.bag) ? JSON.parse(JSON.stringify(saveData.player.bag)) : [];
          player.equipment = typeof saveData.player.equipment === "object" && saveData.player.equipment !== null
            ? JSON.parse(JSON.stringify(saveData.player.equipment))
            : { helmet: null, weapon: null, armor: null, ring: null, arrows: null, cloak: null, shield: null, amulet: null, gloves: null, boots: null };
          player.bank = Array.isArray(saveData.player.bank) ? JSON.parse(JSON.stringify(saveData.player.bank)) : [];
          Object.keys(visitedTowns).forEach(k => delete visitedTowns[k]);
          Object.assign(visitedTowns, saveData.visitedTowns);
          playerPosition.x = typeof saveData.playerPosition.x === "number" ? saveData.playerPosition.x : Math.floor(mapSize/2);
          playerPosition.y = typeof saveData.playerPosition.y === "number" ? saveData.playerPosition.y : Math.floor(mapSize/2);
          // Ensure discovered array is properly sized
          if (!Array.isArray(discovered) || discovered.length !== mapSize) {
            discovered = [];
            for (let y = 0; y < mapSize; ++y) {
              let drow = [];
              for (let x = 0; x < mapSize; ++x) drow.push(false);
              discovered.push(drow);
            }
          }
          if (!Array.isArray(discovered[playerPosition.y])) {
            discovered[playerPosition.y] = [];
            for (let x = 0; x < mapSize; ++x) discovered[playerPosition.y][x] = false;
          }
          discovered[playerPosition.y][playerPosition.x] = true;
          // Do not load mapData, discovered, towns, chests
          renderPlayerStats();
          renderDerivedStats();
          renderEquipment();
          renderBagInv();
          renderMap();
          alert('Game loaded from file!');
          // Hide overlay if loading from overlay
          if (document.getElementById('username-overlay').style.display !== 'none') {
            document.getElementById('username-overlay').style.display = 'none';
            // Also hide overlay load button after load
            const overlayLoadBtn2 = document.getElementById('overlay-load-btn2');
            if (overlayLoadBtn2) overlayLoadBtn2.style.display = 'none';
          }
        } else {
          alert('Invalid save file.');
        }
      } catch (err) {
        alert('Failed to load save: ' + err);
      }
    };
    reader.readAsText(file);
    // Reset input so you can load the same file again if needed
    e.target.value = '';
  });
}

// Overlay Load UI in overlay, right below Stop Music
if (document.getElementById('username-overlay')) {
  const overlayDiv = document.querySelector('#username-overlay > div');
  if (overlayDiv && !document.getElementById('overlay-load-btn2')) {
    // Create Load UI
    const saveLoadDiv = document.createElement('div');
    saveLoadDiv.id = 'overlay-save-load-ui';
    saveLoadDiv.style.display = 'flex';
    saveLoadDiv.style.gap = '8px';
    saveLoadDiv.style.alignItems = 'center';
    saveLoadDiv.style.marginBottom = '18px';

    // Load button (triggers file input)
    const loadBtn = document.createElement('button');
    loadBtn.id = 'overlay-load-btn2';
    loadBtn.textContent = 'Load';
    loadBtn.style.fontWeight = 'bold';
    loadBtn.style.fontSize = '1em';
    loadBtn.style.background = '#35373e';
    loadBtn.style.color = '#ffba3a';
    loadBtn.style.border = 'none';
    loadBtn.style.borderRadius = '6px';
    loadBtn.style.padding = '6px 18px';
    loadBtn.style.cursor = 'pointer';
    loadBtn.onclick = function() {
      document.getElementById('main-load-input').click();
    };

    saveLoadDiv.appendChild(loadBtn);

    // Insert right below Stop Music button (after the two music buttons)
    const musicBtns = overlayDiv.querySelectorAll('button');
    if (musicBtns.length >= 2) {
      musicBtns[1].after(saveLoadDiv);
    } else {
      overlayDiv.prepend(saveLoadDiv);
    }
  }
}

// Hide overlay load button after starting game
const usernameSubmitBtn = document.getElementById('username-submit');
if (usernameSubmitBtn) {
  usernameSubmitBtn.addEventListener('click', function() {
    const overlayLoadBtn = document.getElementById('overlay-load-btn2');
    if (overlayLoadBtn) overlayLoadBtn.style.display = 'none';
  });
}
/* --- MUSIC BUTTON IN MAIN UI (top left, by Save) --- */
if (!document.getElementById('main-music-btn')) {
  // Create music button
  const musicBtn = document.createElement('button');
  musicBtn.id = 'main-music-btn';
  musicBtn.title = 'Toggle Music';
  musicBtn.style.fontWeight = 'bold';
  musicBtn.style.fontSize = '1.2em';
  musicBtn.style.background = '#35373e';
  musicBtn.style.color = '#ffba3a';
  musicBtn.style.border = 'none';
  musicBtn.style.borderRadius = '6px';
  musicBtn.style.padding = '6px 12px';
  musicBtn.style.cursor = 'pointer';
  musicBtn.style.marginRight = '6px';
  musicBtn.innerHTML = '🎵';

  // Insert before Save button in #main-save-ui
  const saveUi = document.getElementById('main-save-ui');
  if (saveUi && saveUi.firstChild) {
    saveUi.insertBefore(musicBtn, saveUi.firstChild);
  }

  // Toggle music play/pause
  musicBtn.onclick = function() {
    // Prefer uploaded audio if loaded and visible
    const uploadedAudio = document.getElementById('uploaded-audio');
    const music = document.getElementById('username-music');
    let audioToControl = null;
    if (uploadedAudio && uploadedAudio.src && uploadedAudio.style.display !== "none") {
      audioToControl = uploadedAudio;
    } else if (music) {
      audioToControl = music;
    }
    if (!audioToControl) return;
    if (audioToControl.paused) {
      audioToControl.play().catch(() => {
        document.body.addEventListener('click', () => audioToControl.play(), { once: true });
      });
      musicBtn.style.background = '#ffba3a';
      musicBtn.style.color = '#23252a';
    } else {
      audioToControl.pause();
      musicBtn.style.background = '#35373e';
      musicBtn.style.color = '#ffba3a';
    }
  };

  // Set initial state based on music
  const uploadedAudio = document.getElementById('uploaded-audio');
  const music = document.getElementById('username-music');
  if ((uploadedAudio && uploadedAudio.src && uploadedAudio.style.display !== "none" && !uploadedAudio.paused) ||
      (music && !music.paused)) {
    musicBtn.style.background = '#ffba3a';
    musicBtn.style.color = '#23252a';
  }
}



// Helper: generate tooltip HTML for an item
function getItemTooltip(item) {
  let lines = [];
  lines.push(`<b>${item.name}</b>`);
  if (item.description) lines.push(`<span style="color:#aaa;">${item.description}</span>`);
  if (item.attackPower) lines.push(`ATK: <b>+${item.attackPower}</b>`);
  if (item.defense) lines.push(`DEF: <b>+${item.defense}</b>`);
  if (item.health) lines.push(`HP: <b>+${item.health}</b>`);
  if (item.heal) lines.push(`Heals: <b>+${item.heal}</b>`);
  if (item.count && item.type === "arrows") lines.push(`Arrows: <b>x${item.count}</b>`);
  if (item.type) lines.push(`<span style="color:#ffba3a;">Type: ${item.type.charAt(0).toUpperCase() + item.type.slice(1)}</span>`);
  return lines.join('<br>');
}

// Patch renderBagInv to add tooltip to each item-card
const origRenderBagInv = renderBagInv;
renderBagInv = function() {
  origRenderBagInv();
  // Add tooltip event listeners to all .item-card
  const cards = document.querySelectorAll('#baginv-content .item-card');
  let itemsArr = baginvTab === "inventory" ? player.inventory : player.bag;
  cards.forEach((card, idx) => {
    // Remove any existing tooltip
    let oldTip = card.querySelector('.item-tooltip');
    if (oldTip) oldTip.remove();

    // Create tooltip div
    const tooltip = document.createElement('div');
    tooltip.className = 'item-tooltip';
    tooltip.style.display = 'none';
    tooltip.style.position = 'absolute';
    tooltip.style.left = '110%';
    tooltip.style.top = '50%';
    tooltip.style.transform = 'translateY(-50%)';
    tooltip.style.background = '#18191c';
    tooltip.style.color = '#eee';
    tooltip.style.padding = '7px 13px';
    tooltip.style.borderRadius = '8px';
    tooltip.style.border = '1px solid #444';
    tooltip.style.whiteSpace = 'nowrap';
    tooltip.style.fontSize = '0.98em';
    tooltip.style.boxShadow = '0 2px 10px #0007';
    tooltip.style.zIndex = '10';
    tooltip.style.minWidth = '160px';
    tooltip.innerHTML = getItemTooltip(itemsArr[idx]);
    card.appendChild(tooltip);

    // Show/hide on hover
    card.onmouseenter = () => { tooltip.style.display = 'block'; };
    card.onmouseleave = () => { tooltip.style.display = 'none'; };
    card.onmousemove = (e) => {
      // Optional: move tooltip with mouse
      tooltip.style.left = (e.offsetX + 30) + 'px';
      tooltip.style.top = (e.offsetY - 10) + 'px';
    };
  });
};

// Add tooltip CSS
const style = document.createElement('style');
style.textContent = `
  .item-card { position: relative; }
  .item-tooltip {
    pointer-events: none;
    opacity: 0.98;
    transition: opacity 0.12s;
  }
`;
document.head.appendChild(style);

/*
  --- AUTO ATTACK BUTTON FOR ENEMY ENCOUNTER ---
  Adds a button (⚔️⚔️) to auto-attack the enemy until one side is defeated or the player cancels.
*/

// Add the auto-attack button to the enemy controls UI
function addAutoAttackButton() {
  const controls = document.getElementById('enemy-controls');
  if (!controls) return;
  // Prevent duplicate button
  if (document.getElementById('auto-attack-btn')) return;
  const btn = document.createElement('button');
  btn.className = 'enemy-action-btn';
  btn.id = 'auto-attack-btn';
  btn.innerHTML = '⚔️ Auto Attack ⚔️';
  btn.style.fontWeight = 'bold';
  btn.onclick = startAutoAttack;
  controls.appendChild(btn);
}

// Remove the auto-attack button (e.g., after combat ends)
function removeAutoAttackButton() {
  const btn = document.getElementById('auto-attack-btn');
  if (btn && btn.parentNode) btn.parentNode.removeChild(btn);
}

// Auto-attack logic
let autoAttackActive = false;
function startAutoAttack() {
  if (!currentEnemy || !inCombat) return;
  autoAttackActive = true;
  // Change button to "Cancel Auto"
  const btn = document.getElementById('auto-attack-btn');
  if (btn) {
    btn.textContent = '❌ Cancel Auto';
    btn.onclick = stopAutoAttack;
    btn.style.background = '#ff4444';
    btn.style.color = '#fff';
  }
  autoAttackLoop();
}
function stopAutoAttack() {
  autoAttackActive = false;
  // Restore button
  const btn = document.getElementById('auto-attack-btn');
  if (btn) {
    btn.textContent = '⚔️⚔️ Auto Attack';
    btn.onclick = startAutoAttack;
    btn.style.background = '';
    btn.style.color = '';
  }
}

// Loop: attack, wait, repeat if still in combat and autoAttackActive
function autoAttackLoop() {
  if (!autoAttackActive || !currentEnemy || !inCombat) {
    stopAutoAttack();
    return;
  }
  // Only attack if enemy and player are alive
  if (currentEnemy.health > 0 && player.health > 0) {
    attackEnemy();
    // Wait for enemy attack animation, then repeat
    setTimeout(() => {
      if (currentEnemy && currentEnemy.health > 0 && player.health > 0 && inCombat && autoAttackActive) {
        autoAttackLoop();
      } else {
        stopAutoAttack();
      }
    }, 900);
  } else {
    stopAutoAttack();
  }
}

// Patch renderEnemyEncounter to add/remove the button
const origRenderEnemyEncounter = renderEnemyEncounter;
renderEnemyEncounter = function() {
  origRenderEnemyEncounter();
  if (currentEnemy && inCombat) {
    addAutoAttackButton();
  } else {
    removeAutoAttackButton();
    autoAttackActive = false;
  }
};

// Also stop auto-attack if player runs away or dies
const origClearEnemy = clearEnemy;
clearEnemy = function() {
  autoAttackActive = false;
  removeAutoAttackButton();
  origClearEnemy();
};
/*
  --- PATCH: Robust Save/Load Error Handling ---
  Ensures save files are saved and loaded correctly, with user-friendly error messages.
*/

// Patch save button to catch errors
const origMainSaveBtn = document.getElementById('main-save-btn').onclick;
document.getElementById('main-save-btn').onclick = function() {
  try {
    origMainSaveBtn && origMainSaveBtn();
  } catch (e) {
    alert('Failed to save game: ' + (e && e.message ? e.message : e));
  }
};

// Patch load input to catch errors and validate file structure
const mainLoadInput = document.getElementById('main-load-input');
if (mainLoadInput) {
  const origLoadHandler = mainLoadInput.onchange || null;
  mainLoadInput.onchange = function(e) {
    try {
      const file = e.target.files[0];
      if (!file) throw new Error('No file selected.');
      const reader = new FileReader();
      reader.onload = function(evt) {
        try {
          const saveData = JSON.parse(evt.target.result);
          if (
            !saveData.player ||
            typeof saveData.player !== 'object' ||
            !saveData.visitedTowns ||
            typeof saveData.visitedTowns !== 'object' ||
            !saveData.playerPosition ||
            typeof saveData.playerPosition !== 'object'
          ) {
            throw new Error('Invalid save file structure.');
          }
          // --- RESET MAP: all towns unvisited, everything reset ---
          initMap();
          Object.keys(visitedTowns).forEach(k => delete visitedTowns[k]);
          // Defensive assignment as before
          player.name = saveData.player.name || "Hero";
          player.health = typeof saveData.player.health === "number" ? saveData.player.health : 100;
          player.maxHealth = typeof saveData.player.maxHealth === "number" ? saveData.player.maxHealth : 100;
          player.gold = typeof saveData.player.gold === "number" ? saveData.player.gold : 0;
          player.experience = typeof saveData.player.experience === "number" ? saveData.player.experience : 0;
          player.level = typeof saveData.player.level === "number" ? saveData.player.level : 1;
          player.bankGold = typeof saveData.player.bankGold === "number" ? saveData.player.bankGold : 0;
          player.inventory = Array.isArray(saveData.player.inventory) ? JSON.parse(JSON.stringify(saveData.player.inventory)) : [];
          player.bag = Array.isArray(saveData.player.bag) ? JSON.parse(JSON.stringify(saveData.player.bag)) : [];
          player.equipment = typeof saveData.player.equipment === "object" && saveData.player.equipment !== null
            ? JSON.parse(JSON.stringify(saveData.player.equipment))
            : { helmet: null, weapon: null, armor: null, ring: null, arrows: null, cloak: null, shield: null, amulet: null, gloves: null, boots: null };
          player.bank = Array.isArray(saveData.player.bank) ? JSON.parse(JSON.stringify(saveData.player.bank)) : [];
          // Always default player to central town on load
          playerPosition.x = Math.floor(mapSize/2);
          playerPosition.y = Math.floor(mapSize/2);
          discovered[playerPosition.y][playerPosition.x] = true;
          renderPlayerStats();
          renderDerivedStats();
          renderEquipment();
          renderBagInv();
          renderMap();
          alert('Game loaded from file! Map has been reset and player is at Central Town.');
          if (document.getElementById('username-overlay').style.display !== 'none') {
            document.getElementById('username-overlay').style.display = 'none';
            const overlayLoadBtn2 = document.getElementById('overlay-load-btn2');
            if (overlayLoadBtn2) overlayLoadBtn2.style.display = 'none';
          }
        } catch (err) {
          alert('Failed to load save: ' + (err && err.message ? err.message : err));
        }
      };
      reader.readAsText(file);
      e.target.value = '';
    } catch (err) {
      alert('Failed to load save: ' + (err && err.message ? err.message : err));
    }
    if (origLoadHandler) origLoadHandler.call(this, e);
  };
}

// Always default player to central town on refresh
window.addEventListener('DOMContentLoaded', function() {
  playerPosition.x = Math.floor(mapSize/2);
  playerPosition.y = Math.floor(mapSize/2);
  if (Array.isArray(discovered) && Array.isArray(discovered[playerPosition.y])) {
    discovered[playerPosition.y][playerPosition.x] = true;
  }
  renderMap && renderMap();
});

/*
  --- PANEL LOCATION UI ---
  Adds a button to show a popup listing all panels and their current column (Left, Center, Right).
  Allows moving panels between columns via a dropdown, and updates the UI live.
*/

// Helper: panel IDs and display names
const panelLocations = [
  { id: 'player-stats', name: 'Player Stats' },
  { id: 'equipment', name: 'Equipment' },
  { id: 'baginv', name: 'Inventory/Bag' },
  { id: 'derived-stats', name: 'Current Stats' },
  { id: 'bank', name: 'Bank' },
  { id: 'map', name: 'Map' },
  { id: 'shop', name: 'Shop' },
  { id: 'log-panel', name: 'Game Log' },
  { id: 'prayer-panel', name: 'Prayer Panel' }
];

// Add the "Panel Locations" button to the bottom left of the main UI
(function() {
  if (!document.getElementById('panel-locations-btn')) {
    const btn = document.createElement('button');
    btn.id = 'panel-locations-btn';
    btn.textContent = 'Panel Locations';
    btn.style.fontWeight = 'bold';
    btn.style.fontSize = '1em';
    btn.style.background = '#35373e';
    btn.style.color = '#ffba3a';
    btn.style.border = 'none';
    btn.style.borderRadius = '6px';
    btn.style.padding = '6px 18px';
    btn.style.cursor = 'pointer';
    btn.style.position = 'fixed';
    btn.style.left = '10px';
    btn.style.bottom = '10px';
    btn.style.zIndex = '2100';
    document.body.appendChild(btn);
    btn.onclick = showPanelLocationsPopup;
  }
})();

// Panel Locations Popup logic
function showPanelLocationsPopup() {
  let popup = document.getElementById('panel-locations-popup');
  if (!popup) {
    popup = document.createElement('div');
    popup.id = 'panel-locations-popup';
    popup.style = 'display:flex;position:fixed;z-index:6000;top:0;left:0;width:100vw;height:100vh;background:#191a1ecc;align-items:center;justify-content:center;';
    popup.innerHTML = `
      <div style="background:#23252a;padding:38px 44px 32px 44px;border-radius:18px;box-shadow:0 2px 24px #000a;display:flex;flex-direction:column;align-items:center;min-width:340px;">
        <div style="color:#ffba3a;font-size:1.3em;margin-bottom:18px;">Panel Locations</div>
        <div id="panel-locations-list" style="margin-bottom:18px;width:100%;"></div>
        <button id="panel-locations-close" style="font-size:1.1em;font-weight:bold;background:#35373e;color:#ffba3a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">Close</button>
      </div>
    `;
    document.body.appendChild(popup);
    document.getElementById('panel-locations-close').onclick = function() {
      popup.style.display = 'none';
    };
  }
  renderPanelLocationsList();
  popup.style.display = 'flex';
}

// Helper: get column name for a panel
function getPanelColumn(panelId) {
  const panel = document.getElementById(panelId);
  if (!panel || !panel.parentNode) return 'Unknown';
  if (panel.parentNode.id === 'left-col') return 'Left';
  if (panel.parentNode.id === 'center-col') return 'Center';
  if (panel.parentNode.id === 'right-col') return 'Right';
  return 'Unknown';
}

// Helper: move panel to column
function movePanelToColumn(panelId, colName) {
  const panel = document.getElementById(panelId);
  let targetCol = null;
  if (colName === 'Left') targetCol = document.getElementById('left-col');
  else if (colName === 'Center') targetCol = document.getElementById('center-col');
  else if (colName === 'Right') targetCol = document.getElementById('right-col');
  if (panel && targetCol && panel.parentNode !== targetCol) {
    targetCol.appendChild(panel);
    // Reset position if it was being dragged
    panel.style.position = '';
    panel.style.left = '';
    panel.style.top = '';
    panel.style.right = '';
    panel.style.bottom = '';
    panel.style.zIndex = '';
  }
  renderPanelLocationsList();
}

// Render the panel locations list with dropdowns
function renderPanelLocationsList() {
  const listDiv = document.getElementById('panel-locations-list');
  if (!listDiv) return;
  let html = '<table style="width:100%;color:#fff;font-size:1em;">';
  html += '<tr><th style="text-align:left;">Panel</th><th style="text-align:left;">Location</th><th style="text-align:left;">Move</th></tr>';
  panelLocations.forEach(panel => {
    const col = getPanelColumn(panel.id);
    html += `<tr>
      <td>${panel.name}</td>
      <td>${col}</td>
      <td>
        <select onchange="movePanelToColumn('${panel.id}', this.value)">
          <option value="Left"${col==='Left'?' selected':''}>Left</option>
          <option value="Center"${col==='Center'?' selected':''}>Center</option>
          <option value="Right"${col==='Right'?' selected':''}>Right</option>
        </select>
      </td>
    </tr>`;
  });
  html += '</table>';
  listDiv.innerHTML = html;
}

// Expose movePanelToColumn globally for dropdown onchange
window.movePanelToColumn = movePanelToColumn;
/*
  --- PRAYER STAT & UI PANEL ---
  Adds a prayer stat (default 50/50) to player stats, and a separate prayer panel (menu) below player stats.
  Adds two prayers: Deflect (🗡️) and Heal (+). Heal prayer restores +10 health after each enemy turn.
*/

// 1. Add prayer stat to player object (default 50/50)
if (typeof player.prayer !== "number") player.prayer = 50;
if (typeof player.maxPrayer !== "number") player.maxPrayer = 50;

// 2. Patch renderPlayerStats to always show prayer stat in the stats list (no clickable UI here)
const origRenderPlayerStats = renderPlayerStats;
renderPlayerStats = function() {
  origRenderPlayerStats();
  // Add or update prayer stat row (just numbers, no button)
  const ul = document.getElementById('player-stats-ul');
  let prayerLi = ul ? ul.querySelector('.prayer-li') : null;
  if (!prayerLi && ul) {
    prayerLi = document.createElement('li');
    prayerLi.className = 'prayer-li';
    prayerLi.innerHTML = `<span class="prayer" style="color:#6cf;font-weight:bold;">Prayer:</span> <span id="prayer-label">${player.prayer}/${player.maxPrayer}</span>`;
    ul.appendChild(prayerLi);
  } else if (prayerLi) {
    const prayerLabel = prayerLi.querySelector('#prayer-label');
    if (prayerLabel) prayerLabel.textContent = `${player.prayer}/${player.maxPrayer}`;
  }
};

// 3. Add separate Prayer Panel below player stats panel (like a menu/panel)
(function() {
  if (!document.getElementById('prayer-panel')) {
    const prayerPanel = document.createElement('div');
    prayerPanel.id = 'prayer-panel';
    prayerPanel.className = 'panel';
    prayerPanel.style = 'margin-top:8px;background:#292c31;border-radius:10px;padding:16px;box-shadow:0 2px 10px #000a;';
    prayerPanel.innerHTML = `
      <h2 style="color:#6cf;">Prayer</h2>
      <div style="display:flex;align-items:center;gap:14px;">
        <button id="prayer-deflect-btn" title="Deflect Attack" style="background:#23252a;border:none;border-radius:50%;width:38px;height:38px;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:1.5em;transition:background 0.18s;">
          <span id="prayer-deflect-icon" style="color:#aaa;">🗡️</span>
        </button>
        <button id="prayer-heal-btn" title="Heal Over Time" style="background:#23252a;border:none;border-radius:50%;width:38px;height:38px;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:1.5em;transition:background 0.18s;">
          <span id="prayer-heal-icon" style="color:#aaa;">+</span>
        </button>
        <span id="prayer-countdown" style="color:#6cf;font-weight:bold;font-size:1.1em;">${player.prayer}/${player.maxPrayer}</span>
        <span id="prayer-status-label" style="color:#aaa;font-size:0.98em;"></span>
      </div>
    `;
    // Insert after player stats panel
    const statsPanel = document.getElementById('player-stats');
    if (statsPanel && statsPanel.parentNode) {
      statsPanel.parentNode.insertBefore(prayerPanel, statsPanel.nextSibling);
    }
  }
})();

// 4. Prayer logic
let prayerDeflectActive = false;
let prayerHealActive = false;
let prayerInterval = null;

// Tooltip logic for prayers
function showPrayerTooltip(btnId, text) {
  let btn = document.getElementById(btnId);
  if (!btn) return;
  let tip = document.createElement('div');
  tip.className = 'prayer-tooltip';
  tip.style.position = 'absolute';
  tip.style.left = '50%';
  tip.style.top = '110%';
  tip.style.transform = 'translateX(-50%)';
  tip.style.background = '#18191c';
  tip.style.color = '#eee';
  tip.style.padding = '8px 16px';
  tip.style.borderRadius = '8px';
  tip.style.border = '1px solid #444';
  tip.style.whiteSpace = 'nowrap';
  tip.style.fontSize = '1em';
  tip.style.boxShadow = '0 2px 10px #0007';
  tip.style.zIndex = '9999';
  tip.innerHTML = text;
  btn.appendChild(tip);
  btn._prayerTip = tip;
}
function hidePrayerTooltip(btnId) {
  let btn = document.getElementById(btnId);
  if (btn && btn._prayerTip) {
    btn.removeChild(btn._prayerTip);
    btn._prayerTip = null;
  }
}

function getPrayerDrainRate() {
  let activeCount = (prayerDeflectActive ? 1 : 0) + (prayerHealActive ? 1 : 0);
  return activeCount === 2 ? "1%" : activeCount === 1 ? "0.5%" : "0%";
}

function updatePrayerUI() {
  // Update prayer panel layout and status
  const panel = document.getElementById('prayer-panel');
  if (!panel) return;
  panel.innerHTML = `
    <h2 style="color:#6cf;">Prayer</h2>
    <div style="display:flex;align-items:center;gap:14px;margin-bottom:8px;position:relative;">
      <button id="prayer-deflect-btn" title="Deflect Attack" style="background:${prayerDeflectActive ? '#232' : '#23252a'};border:none;border-radius:50%;width:38px;height:38px;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:1.5em;transition:background 0.18s;position:relative;">
        <span id="prayer-deflect-icon" style="color:${prayerDeflectActive ? '#2ecc40' : '#aaa'};">🗡️</span>
      </button>
      <button id="prayer-heal-btn" title="Heal Over Time" style="background:${prayerHealActive ? '#232' : '#23252a'};border:none;border-radius:50%;width:38px;height:38px;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:1.5em;transition:background 0.18s;position:relative;">
        <span id="prayer-heal-icon" style="color:${prayerHealActive ? '#2ecc40' : '#aaa'};">❤️</span>
      </button>
      <span id="prayer-countdown" style="color:${(prayerDeflectActive||prayerHealActive) ? '#2ecc40' : '#6cf'};font-weight:bold;font-size:1.1em;">
        ${player.prayer}/${player.maxPrayer}
      </span>
      <span id="prayer-status-label" style="color:#aaa;font-weight:bold;font-size:1.1em;">
        ${prayerDeflectActive ? 'Deflect Active' : ''}${prayerDeflectActive && prayerHealActive ? ' & ' : ''}${prayerHealActive ? 'Heal Active' : ''}
        ${!prayerDeflectActive && !prayerHealActive ? 'Inactive' : ''}
      </span>
    </div>
    <div style="color:#aaa;font-size:0.98em;">
      Prayer drain rate: <b>${getPrayerDrainRate()}</b> per tick
    </div>
  `;
  // Remove old tooltips if any
  hidePrayerTooltip('prayer-deflect-btn');
  hidePrayerTooltip('prayer-heal-btn');
  // Attach hover logic for tooltips
  const deflectBtn = document.getElementById('prayer-deflect-btn');
  const healBtn = document.getElementById('prayer-heal-btn');
  if (deflectBtn) {
    deflectBtn.onmouseenter = function() {
      showPrayerTooltip('prayer-deflect-btn', `Deflect: Negates half enemy damage.<br>Drain rate: 0.5% per tick if active.`);
    };
    deflectBtn.onmouseleave = function() {
      hidePrayerTooltip('prayer-deflect-btn');
    };
  }
  if (healBtn) {
    healBtn.onmouseenter = function() {
      showPrayerTooltip('prayer-heal-btn', `Heal: Restores 50 health after each enemy turn.<br>Drain rate: 0.5% per tick if active.`);
    };
    healBtn.onmouseleave = function() {
      hidePrayerTooltip('prayer-heal-btn');
    };
  }
  // Toggle logic
  if (deflectBtn) deflectBtn.onclick = function() {
    prayerDeflectActive = !prayerDeflectActive;
    if (prayerDeflectActive && prayerHealActive && player.prayer <= 0) {
      prayerDeflectActive = false;
      prayerHealActive = false;
    }
    updatePrayerUI();
    handlePrayerInterval();
  };
  if (healBtn) healBtn.onclick = function() {
    prayerHealActive = !prayerHealActive;
    if (prayerDeflectActive && prayerHealActive && player.prayer <= 0) {
      prayerDeflectActive = false;
      prayerHealActive = false;
    }
    updatePrayerUI();
    handlePrayerInterval();
  };
  // Also update player stats prayer label
  const prayerLabel = document.getElementById('prayer-label');
  if (prayerLabel) prayerLabel.textContent = `${player.prayer}/${player.maxPrayer}`;
}
function handlePrayerInterval() {
  // Only drain prayer if any prayer is active
  if ((prayerDeflectActive || prayerHealActive) && player.prayer > 0) {
    if (!prayerInterval) {
      prayerInterval = setInterval(() => {
        if (!(prayerDeflectActive || prayerHealActive)) return;
        if (player.prayer > 0) {
          // Drain rate: 0.5% per prayer per tick
          let drain = 0;
          if (prayerDeflectActive) drain += 0.5;
          if (prayerHealActive) drain += 0.5;
          // Convert percent to actual prayer points (maxPrayer * drain%)
          let drainAmount = Math.max(1, Math.floor(player.maxPrayer * (drain / 100)));
          player.prayer = Math.max(0, player.prayer - drainAmount);
          updatePrayerUI();
          checkPrayerZero();
        }
        if (player.prayer <= 0) {
          prayerDeflectActive = false;
          prayerHealActive = false;
          updatePrayerUI();
          clearInterval(prayerInterval);
          prayerInterval = null;
        }
      }, 700);
    }
  } else {
    if (prayerInterval) {
      clearInterval(prayerInterval);
      prayerInterval = null;
    }
  }
}
updatePrayerUI();

// 5. Patch enemyAttack to deflect half damage if prayerDeflectActive and heal +10 if prayerHealActive
const origEnemyAttack = enemyAttack;
enemyAttack = function() {
  if (!currentEnemy || !inCombat) return;
  let pDef = getTotalDefense();
  let min = currentEnemy.minAttack;
  let max = currentEnemy.maxAttack;
  let eHit = Math.max(0, Math.floor(min + Math.random()*(max-min+1)) - Math.floor(pDef/3));
  // Prayer deflect logic
  if (prayerDeflectActive && player.prayer > 0) {
    let deflected = Math.ceil(eHit / 2);
    eHit = eHit - deflected;
    logMsg(`<span style="color:#2ecc40;font-weight:bold;">Prayer Deflect: Negated ${deflected} damage!</span>`);
    updatePrayerUI();
    checkPrayerZero();
  }
  player.health = Math.max(0, player.health - eHit);
  logMsg(`<span style="color:#f66">The ${currentEnemy.name} hits you for <b>${eHit}</b>!</span>`);
  // Heal prayer logic: heal 50 after enemy turn
  if (prayerHealActive && player.prayer > 0 && player.health > 0) {
    let maxHeal = getTotalMaxHealth();
    let healed = Math.min(50, maxHeal - player.health);
    if (healed > 0) {
      player.health += healed;
      logMsg(`<span style="color:#2ecc40;font-weight:bold;">Prayer Heal: Restored ${healed} health!</span>`);
    }
    updatePrayerUI();
    checkPrayerZero();
  }
  renderPlayerStats();
  if (player.health <= 0) {
    logMsg(`<span style="color:#f44;font-weight:bold;">You died! Respawning at town...</span>`);
    respawnPlayer();
    clearEnemy();
  }
};

// 6. Restore prayer only on respawn (not after every battle or level up)
const origRespawnPlayer = respawnPlayer;
respawnPlayer = function() {
  player.prayer = player.maxPrayer;
  prayerDeflectActive = false;
  prayerHealActive = false;
  updatePrayerUI();
  origRespawnPlayer();
};
// Do NOT reset prayer on level up
const origCheckLevelUp = checkLevelUp;
checkLevelUp = function() {
  origCheckLevelUp();
  updatePrayerUI();
};

// 7. Update prayer UI on game load/start
window.addEventListener('DOMContentLoaded', updatePrayerUI);
document.getElementById('username-submit').addEventListener('click', updatePrayerUI);

// 8. Add logic to ensure prayer does not reset after each explore, and reacts appropriately at 0

// Remove any code that resets prayer on explore or movement
// (No code in your explore/movePlayer/doExplore resets prayer, so nothing to remove)

// Patch explore, movePlayer, doExplore to NOT reset prayer
// Already handled: prayer only resets on respawn/level up

// Ensure prayer reacts appropriately at 0 (disable prayers, update UI)
function checkPrayerZero() {
  if (player.prayer <= 0) {
    player.prayer = 0;
    prayerDeflectActive = false;
    prayerHealActive = false;
    updatePrayerUI();
    if (prayerInterval) { clearInterval(prayerInterval); prayerInterval = null; }
    logMsg('<span style="color:#6cf;font-weight:bold;">Prayer depleted! All prayers disabled.</span>');
  }
}

// Patch all places where prayer is decremented to call checkPrayerZero
let enemyTurnCounter = 0;
const origEnemyAttack2 = enemyAttack;
enemyAttack = function() {
  if (!currentEnemy || !inCombat) return;
  let pDef = getTotalDefense();
  let min = currentEnemy.minAttack;
  let max = currentEnemy.maxAttack;
  let eHit = Math.max(0, Math.floor(min + Math.random()*(max-min+1)) - Math.floor(pDef/3));
  // Prayer deflect logic
  if (prayerDeflectActive && player.prayer > 0) {
    let deflected = Math.ceil(eHit / 2);
    eHit = eHit - deflected;
    logMsg(`<span style="color:#2ecc40;font-weight:bold;">Prayer Deflect: Negated ${deflected} damage!</span>`);
    updatePrayerUI();
    checkPrayerZero();
  }
  player.health = Math.max(0, player.health - eHit);
  logMsg(`<span style="color:#f66">The ${currentEnemy.name} hits you for <b>${eHit}</b>!</span>`);
  // Heal prayer logic: heal 50 after every 5 enemy turns
  if (prayerHealActive && player.prayer > 0 && player.health > 0) {
    enemyTurnCounter = (enemyTurnCounter || 0) + 1;
    if (enemyTurnCounter % 5 === 0) {
      let maxHeal = getTotalMaxHealth();
      let healed = Math.min(50, maxHeal - player.health);
      if (healed > 0) {
        player.health += healed;
        logMsg(`<span style="color:#2ecc40;font-weight:bold;">Prayer Heal: Restored ${healed} health!</span>`);
      }
      updatePrayerUI();
      checkPrayerZero();
    }
  }
  renderPlayerStats();
  if (player.health <= 0) {
    logMsg(`<span style="color:#f44;font-weight:bold;">You died! Respawning at town...</span>`);
    respawnPlayer();
    clearEnemy();
    enemyTurnCounter = 0;
  }
};

// Patch prayerInterval drain to call checkPrayerZero
function handlePrayerInterval() {
  // Only drain prayer if any prayer is active
  if ((prayerDeflectActive || prayerHealActive) && player.prayer > 0) {
    if (!prayerInterval) {
      prayerInterval = setInterval(() => {
        if (!(prayerDeflectActive || prayerHealActive)) return;
        if (player.prayer > 0) {
          // Drain rate: 0.5% per prayer per tick
          let drain = 0;
          if (prayerDeflectActive) drain += 0.5;
          if (prayerHealActive) drain += 0.5;
          let drainAmount = Math.max(1, Math.floor(player.maxPrayer * (drain / 100)));
          player.prayer = Math.max(0, player.prayer - drainAmount);
          updatePrayerUI();
          checkPrayerZero();
        }
        if (player.prayer <= 0) {
          prayerDeflectActive = false;
          prayerHealActive = false;
          updatePrayerUI();
          clearInterval(prayerInterval);
          prayerInterval = null;
        }
      }, 700);
    }
  } else {
    if (prayerInterval) {
      clearInterval(prayerInterval);
      prayerInterval = null;
    }
  }
}

// Prayer only resets on respawn/level up (already handled above)
(function() {
  const style = document.createElement('style');
  style.textContent = `
    #prayer-panel { margin-top:8px; }
    #prayer-deflect-btn, #prayer-heal-btn { transition:background 0.18s; }
    #prayer-deflect-btn:active, #prayer-heal-btn:active { box-shadow:0 0 8px #2ecc40; }
    #prayer-deflect-icon, #prayer-heal-icon { transition:color 0.18s; }
    #prayer-countdown { font-weight:bold; }
    .prayer-tooltip {
      pointer-events: none;
      opacity: 0.98;
      transition: opacity 0.12s;
    }
  `;
  document.head.appendChild(style);

  // --- PRAYER ALTAR UI ---
  if (!document.getElementById('prayer-altar-panel')) {
    const altarPanel = document.createElement('div');
    altarPanel.id = 'prayer-altar-panel';
    altarPanel.className = 'panel';
    altarPanel.style = 'margin-top:12px;background:#292c31;border-radius:10px;padding:16px;box-shadow:0 2px 10px #000a;display:flex;flex-direction:column;align-items:center;';
    altarPanel.innerHTML = `
      <div style="margin-bottom:10px;">
        <img src="assets/images/altar.png" alt="Prayer Altar" style="width:300px;height:90px;object-fit:cover;border-radius:8px;box-shadow:0 2px 12px #0007;">
      </div>
      <button id="renew-prayer-btn" style="font-weight:bold;font-size:1.1em;background:#6cf;color:#23252a;border:none;border-radius:8px;padding:8px 32px;cursor:pointer;box-shadow:0 2px 8px #0004;">Renew Prayer</button>
      <div id="renew-prayer-msg" style="margin-top:10px;color:#6cf;font-size:1em;display:none;"></div>
      <audio id="prayer-renew-audio" src="assets/audio/prayer.mp3" preload="auto"></audio>
    `;
    // Insert below prayer panel
    const prayerPanel = document.getElementById('prayer-panel');
    if (prayerPanel && prayerPanel.parentNode) {
      prayerPanel.parentNode.insertBefore(altarPanel, prayerPanel.nextSibling);
    }
    // Renew Prayer button logic
    document.getElementById('renew-prayer-btn').onclick = function() {
      player.prayer = player.maxPrayer;
      updatePrayerUI();
      renderPlayerStats();
      const msg = document.getElementById('renew-prayer-msg');
      msg.textContent = 'Your prayer has been renewed!';
      msg.style.display = 'block';
      setTimeout(() => { msg.style.display = 'none'; }, 1800);
      // Play sound
      const audio = document.getElementById('prayer-renew-audio');
      if (audio) {
        audio.currentTime = 0;
        audio.play().catch(() => {
          document.body.addEventListener('click', () => audio.play(), { once: true });
        });
      }
    };
  }



})();
</script>
</body>
</html>
