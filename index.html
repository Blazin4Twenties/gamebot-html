<!DOCTYPE html>
<html lang="en">
<head>
<link href="favicon.ico" rel="icon" type="image/x-icon"/>
<meta charset="utf-8"/>
<style>
  #character-select-overlay {
    position: fixed;
    z-index: 5000;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    background: linear-gradient(135deg, #191a1e 60%, #23252a 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    background-image:
      url('https://images.unsplash.com/photo-1506744038136-46273834b3fb?auto=format&fit=crop&w=1200&q=80');
    background-size: cover;
    background-position: center;
    box-shadow: 0 0 120px #23252a inset;
  }
  #character-select-overlay > div {
    position: relative;
    z-index: 2;
    background: #23252ae6;
    padding: 48px 54px 38px 54px;
    border-radius: 28px;
    box-shadow: 0 4px 32px #ffba3a33, 0 2px 24px #000a;
    display: flex;
    flex-direction: column;
    align-items: center;
    max-width: 680px;
    width: 90vw;
    backdrop-filter: blur(2px);
  }
  .char-class-options {
    display: flex;
    gap: 32px;
    margin: 24px 0 18px 0;
    justify-content: center;
  }
  .char-class-card {
    background: #18191c;
    border-radius: 16px;
    box-shadow: 0 2px 12px #0007;
    padding: 24px 22px 18px 22px;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-width: 160px;
    cursor: pointer;
    border: 2.5px solid #444;
    transition: border-color 0.18s, box-shadow 0.18s;
    position: relative;
  }
  .char-class-card.selected, .char-class-card:hover {
    border-color: #ffba3a;
    box-shadow: 0 0 18px #ffba3a99;
    z-index: 2;
  }
  .char-class-icon {
    font-size: 2.5em;
    margin-bottom: 10px;
  }
  .char-class-title {
    color: #ffba3a;
    font-weight: bold;
    font-size: 1.18em;
    margin-bottom: 7px;
    letter-spacing: 1px;
  }
  .char-class-desc {
    color: #eee;
    font-size: 1em;
    text-align: center;
    margin-bottom: 7px;
    min-height: 48px;
  }
  #char-select-btn {
    font-size: 1.15em;
    font-weight: bold;
    background: linear-gradient(90deg,#ffba3a 70%,#23252a 100%);
    color: #23252a;
    border: none;
    border-radius: 9px;
    padding: 12px 38px;
    cursor: pointer;
    box-shadow: 0 2px 14px #ffba3a88;
    transition: background 0.18s, color 0.18s;
    margin-top: 18px;
    letter-spacing: 1.5px;
    position: relative;
    animation: fateGlow 1.5s infinite alternate;
  }
  #char-select-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    background: #444;
    color: #aaa;
    box-shadow: none;
    animation: none;
  }

  /* --- Hitsplat Styles for Player and Enemy Damage --- */
  .hitsplat {
    position: absolute;
    font-size: 1.5em;
    font-weight: bold;
    pointer-events: none;
    animation: hitsplat-move 1s ease-out forwards;
  }
  .hitsplat.player {
    color: blue;
  }
  .hitsplat.enemy {
    color: red;
  }
  @keyframes hitsplat-move {
    0% {
      opacity: 1;
      transform: translateY(0);
    }
    100% {
      opacity: 0;
      transform: translateY(-50px);
    }
  }
  
  #mystery-bag-ui {
    /* ...existing code... */
    display: none;
    position: fixed;
    z-index: 12000;
    top: 0; left: 0; right: 0; bottom: 0;
    width: 100vw;
    height: 100vh;
    background: radial-gradient(circle, rgba(25,26,30,0.93) 60%, rgba(0,0,0,0.8) 100%);
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }

  #mystery-bag-ui::before {
    /* Removed the yellow spinning box effect */
    display: none;
  }

  @keyframes swirlEffect {
    0% { transform: scale(1) rotate(0deg); opacity: 0.8; }
    50% { transform: scale(1.2) rotate(180deg); opacity: 0.6; }
    100% { transform: scale(1) rotate(360deg); opacity: 0.8; }
  }

  #mystery-bag-ui-inner {
    /* ...existing code... */
    background: linear-gradient(135deg,#23252a 80%,#191a1e 100%);
    border-radius: 22px;
    box-shadow: 0 4px 32px #000a, 0 0 32px #ffba3a55;
    padding: 44px 54px 38px 54px;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-width: 340px;
    max-width: 96vw;
    max-height: 90vh;
    position: relative;
    border: 2.5px solid #ffba3a;
    animation: bagPopupMenace 0.7s cubic-bezier(.59,.22,.44,1.36);
    z-index: 2;
  }
  @keyframes bagPopupMenace {
    0% { transform: scale(0.8) rotate(-2deg); box-shadow: 0 0 0 #0000; }
    60% { transform: scale(1.08) rotate(2deg); box-shadow: 0 0 32px #ffba3a88; }
    100% { transform: scale(1) rotate(0deg); }
  }
  #mystery-bag-ui-inner .bag-icon {
    /* ...existing code... */
    font-size: 3.2em;
    margin-bottom: 12px;
    animation: bagIconPulse 1.2s infinite alternate, bagBounce 2s infinite;
    filter: drop-shadow(0 0 12px #ffba3a88);
  }
  @keyframes bagIconPulse {
    0% { filter: drop-shadow(0 0 12px #ffba3a88); }
    100% { filter: drop-shadow(0 0 32px #ffd36bcc); }
  }
  @keyframes bagBounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
  }
  #mystery-bag-ui-inner .bag-title {
    color: #ffba3a;
    font-size: 1.5em;
    font-weight: bold;
    margin-bottom: 12px;
    text-shadow: 0 2px 8px #23252a88,0 0 4px #fff;
    letter-spacing: 1.5px;
  }
  #mystery-bag-ui-inner .bag-desc {
    color: #ffd36b;
    font-size: 1.1em;
    margin-bottom: 18px;
    text-align: center;
  }
  #mystery-bag-ui-inner .bag-warning {
    color: #ff4444;
    font-size: 1.08em;
    margin-bottom: 18px;
    text-align: center;
    font-weight: bold;
    letter-spacing: 1px;
    text-shadow: 0 0 8px #ff444488;
  }
  #mystery-bag-ui-inner .bag-open-btn {
    /* ...existing code... */
    font-size: 1.15em;
    font-weight: bold;
    background: linear-gradient(90deg, #ffba3a, #ffd36b);
    color: #23252a;
    border: none;
    border-radius: 9px;
    padding: 12px 38px;
    cursor: pointer;
    box-shadow: 0 0 20px #ffba3a88, 0 0 40px #ffd36bcc;
    transition: background 0.18s, color 0.18s, transform 0.2s, box-shadow 0.2s;
    margin-top: 18px;
    letter-spacing: 1.5px;
    position: relative;
    animation: fateGlow 1.5s infinite alternate;
  }
  #mystery-bag-ui-inner .bag-open-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 0 30px #ffba3a, 0 0 60px #ffd36b;
  }
  #mystery-bag-ui-inner .bag-close-btn {
    /* ...existing code... */
    font-size: 1em;
    background: linear-gradient(90deg, #444, #555);
    color: #ffba3a;
    border: none;
    border-radius: 7px;
    padding: 6px 24px;
    cursor: pointer;
    margin-top: 18px;
    font-weight: bold;
    box-shadow: 0 0 10px #444, 0 0 20px #555;
    transition: transform 0.2s, box-shadow 0.2s;
  }
  #mystery-bag-ui-inner .bag-close-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 0 20px #666, 0 0 40px #777;
  }
</style>
<div id="character-select-overlay">
  <div>
    <div id="char-select-title" style="color:#ffba3a;font-size:2em;font-weight:bold;margin-bottom:18px;text-align:center;">Choose Your Path</div>
    <div style="color:#eee;font-size:1.1em;margin-bottom:18px;text-align:center;">
      Select your starting class. Each path begins with unique gear and a different story.
    </div>
    <div class="char-class-options">
      <div class="char-class-card" data-class="melee" tabindex="0">
        <div class="char-class-icon">üó°Ô∏è</div>
        <div class="char-class-title">Melee</div>
        <div class="char-class-desc">A warrior skilled in close combat. Starts with a sword, shield, and sturdy armor.</div>
      </div>
      <div class="char-class-card" data-class="ranger" tabindex="0">
        <div class="char-class-icon">üèπ</div>
        <div class="char-class-title">Ranger</div>
        <div class="char-class-desc">A master of ranged attacks. Starts with a bow, arrows, and light gear.</div>
      </div>
      <div class="char-class-card" data-class="mage" tabindex="0">
        <div class="char-class-icon">ü™Ñ</div>
        <div class="char-class-title">Mage</div>
        <div class="char-class-desc">A wielder of arcane power. Starts with a magic staff and enchanted robe.</div>
      </div>
    </div>
    <button id="char-select-btn" disabled>Begin Your Legend</button>
  </div>
</div>
<div id="mystery-bag-ui" style="position:fixed;z-index:4000;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.8);display:none;align-items:center;justify-content:center;">
  <div id="mystery-bag-ui-inner" style="background:#23252a;border-radius:20px;padding:40px;box-shadow:0 10px 40px rgba(0,0,0,0.6);text-align:center;max-width:500px;width:90%;color:#fff;">
    <div class="bag-icon" style="font-size:4em;margin-bottom:20px;">üéí</div>
    <div class="bag-title" style="color:#ffba3a;font-size:2em;font-weight:bold;margin-bottom:15px;">The Mystery Bag</div>
    <div class="bag-details" style="color:#ccc;margin-bottom:20px;line-height:1.6;"></div>
    <div class="bag-desc" style="color:#eee;margin-bottom:15px;line-height:1.5;">A chill runs down your spine as you gaze upon the bag. Its contents are unknown, its power... undeniable.</div>
    <div class="bag-warning" style="color:#ffba3a;margin-bottom:25px;font-weight:bold;">Are you ready to reveal your fate?</div>
    <button class="bag-open-btn" style="background:#ffba3a;color:#23252a;border:none;padding:12px 30px;border-radius:8px;font-size:1.1em;font-weight:bold;cursor:pointer;margin-right:10px;">Open Bag</button>
    <button class="bag-close-btn" style="background:#444;color:#fff;border:none;padding:12px 30px;border-radius:8px;font-size:1.1em;font-weight:bold;cursor:pointer;display:none;">Close</button>
  </div>
</div>
<script>
  // Character selection logic
  let selectedClass = null;
  let classIntroStories = {
    melee: `
      <p>
        You are a <b>Melee Warrior</b>, forged in the fires of battle. Your sword and shield are your closest allies, and your armor bears the scars of countless fights. The world awaits your strength and courage.
      </p>
    `,
    ranger: `
      <p>
        You are a <b>Ranger</b>, swift and silent. Your bow finds its mark from the shadows, and your arrows never miss. The wilds are your home, and adventure calls you to explore the unknown.
      </p>
    `,
    mage: `
      <p>
        You are a <b>Mage</b>, student of the arcane. The mysteries of magic bend to your will, and your staff crackles with power. The world is full of secrets, and you are ready to uncover them.
      </p>
    `
  };
  // Starter gear for each class (now only used for mystery bag contents)
  let starterGear = {
    melee: [
      { name: "Starter Sword", type: "weapon", attackPower: 12, price: 0, description: "A basic sword for melee combat." },
      { name: "Starter Shield", type: "shield", defense: 8, price: 0, description: "A basic shield for blocking attacks." },
      { name: "Starter Armor", type: "chestplate", defense: 10, price: 0, description: "Sturdy armor for protection." },
      { name: "Starter Helmet", type: "helmet", defense: 5, health: 10, price: 0, description: "A simple helmet." },
      { name: "Potion", type: "consumable", healing: 50, count: 5 }
    ],
    ranger: [
      { name: "Starter Bow", type: "weapon", attackPower: 10, isBow: true, price: 0, description: "A basic bow for ranged attacks." },
      { name: "Arrows", type: "arrows", attackPower: 3, count: 50, price: 0, description: "A bundle of arrows." },
      { name: "Starter Cloak", type: "cape", defense: 6, health: 8, price: 0, description: "A light cloak for agility." },
      { name: "Starter Boots", type: "boots", defense: 4, health: 8, price: 0, description: "Light boots for quick movement." },
      { name: "Potion", type: "consumable", healing: 50, count: 5 }
    ],
    mage: [
      { name: "Starter Staff", type: "weapon", attackPower: 11, price: 0, description: "A basic staff for casting spells."},
      { name: "Starter Amulet", type: "amulet", defense: 4, price: 0, description: "A magical amulet." },
      { name: "Starter Ring", type: "ring", attackPower: 2, health: 6, price: 0, description: "A ring that boosts magic." },
      { name: "Potion", type: "consumable", healing: 50, count: 5 },
      // Add runes for mage
      { name: "Fire Rune", type: "material", count: 100, description: "A rune for fire spells." },
      { name: "Air Rune", type: "material", count: 100, description: "A rune for air spells." },
      { name: "Water Rune", type: "material", count: 100, description: "A rune for water spells." }
    ]
  };
  // Card selection UI
  document.querySelectorAll('.char-class-card').forEach(card => {
    card.onclick = function() {
      document.querySelectorAll('.char-class-card').forEach(c => c.classList.remove('selected'));
      card.classList.add('selected');
      selectedClass = card.getAttribute('data-class');
      document.getElementById('char-select-btn').disabled = false;
    };
    card.onkeydown = function(e) {
      if (e.key === "Enter" || e.key === " ") card.click();
    };
  });
  // On Begin button
  document.getElementById('char-select-btn').onclick = function() {
    if (!selectedClass) return;
    // Set starter gear for later use
    window._selectedClass = selectedClass;
    window._starterGear = starterGear[selectedClass];
    // Hide character select, show intro overlay with class-specific story
    document.getElementById('character-select-overlay').style.display = 'none';
    // Set intro story
    let introOverlay = document.getElementById('intro-overlay');
    if (introOverlay) {
      let storyDiv = introOverlay.querySelector('#intro-story');
      if (storyDiv) {
        // Replace first paragraph with class intro
        let html = classIntroStories[selectedClass] +
          `<p>
            In a world torn by ancient wars and forgotten magic, you awaken in the heart of the realm‚ÄîCentral Town. The lands around you are shrouded in mystery, with forests, mountains, deserts, and ruins waiting to be discovered. Towns bustle with life, each holding secrets, rare sellers, and unique events. Chests glimmer in hidden corners, promising gold and treasures to the bold.
          </p>
          <p>
            As you journey, you will face a host of enemies‚Äîfrom cunning goblins to legendary bosses. Equip powerful weapons, armor, rings, and more to survive. Manage your inventory and bag, deposit valuables in the bank, and seek out the shop for ever-changing wares. Special sellers in towns offer rare items for those who explore bravely.
          </p>
          <p>
            Harness the power of Prayer to deflect attacks or heal in battle. Visit the Prayer Altar to renew your strength. Level up, gain experience, and unlock the ancient set for unmatched power. Auto-explore the world, auto-attack foes, and shape your fate.
          </p>
          <p>
            <b>Features:</b>
            <ul style="margin-left:18px;">
              <li>18x18 grid map with towns, chests, and areas</li>
              <li>Dynamic inventory, bag, equipment, and bank system</li>
              <li>Shop with rotating items and full armor sets</li>
              <li>Special sellers in towns with rare items</li>
              <li>Prayer system: Deflect & Heal, with altar renewal</li>
              <li>Auto-explore and auto-attack options</li>
              <li>Ancient Boss with unique rewards and set bonuses</li>
              <li>Save/load your progress and upload custom music</li>
              <li>More to come!</li>
            </ul>
          </p>
          <p>
            Your destiny awaits. Will you accept your fate and begin your Journey?
          </p>`;
        storyDiv.innerHTML = html;
      }
      introOverlay.style.display = 'flex';
    }
  };
  // On page load, show only character select overlay
  document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('character-select-overlay').style.display = 'flex';
    let intro = document.getElementById('intro-overlay');
    let usernameOverlay = document.getElementById('username-overlay');
    let mainContainer = document.getElementById('container');
    if (intro) intro.style.display = 'none';
    if (usernameOverlay) usernameOverlay.style.display = 'none';
    if (mainContainer) mainContainer.style.display = 'none';
    [
      'bank-modal-bg', 'special-seller-popup', 'town-popup', 'ancient-boss-popup', 'multi-use-popup', 'panel-locations-popup', 'prayer-panel', 'prayer-altar-panel',
      'main-save-ui', 'explore-bar', 'direction-select-bar', 'panel-locations-btn', 'top-left-bar'
    ].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.style.display = 'none';
    });
  });

  // --- Mystery Bag logic ---
  // Helper: returns the mystery bag item for the selected class
  function getMysteryBagForClass(classKey) {
    let bagContents = [];
    if (classKey === "mage") {
      // Mage: ensure runes included
      bagContents = starterGear.mage.slice();
    } else if (classKey === "ranger") {
      bagContents = starterGear.ranger.slice();
    } else {
      bagContents = starterGear.melee.slice();
    }
    return {
      name: "<span style='color:#e53935;font-weight:bold;'>??????</span>",
      type: "mystery",
      description: "Dare to open it?",
      _mysteryBagContents: bagContents
    };
  }

  // Patch renderBagInv to show "Open" button for mystery bag
  document.addEventListener('DOMContentLoaded', function() {
    if (typeof renderBagInv === "function") {
      const origRenderBagInvMystery = renderBagInv;
      window.renderBagInv = function() {
        origRenderBagInvMystery();
        // Add "Open" button for mystery bag
        const content = document.getElementById('baginv-content');
        if (!content) return;
        let itemsArr = baginvTab === "inventory" ? player.inventory : player.bag;
        content.querySelectorAll('.item-card').forEach((card, idx) => {
          const item = itemsArr[idx];
          if (item && item.type === "mystery") {
            // Add Open button if not already present
            if (!card.querySelector('.mystery-bag-open-btn')) {
              const btn = document.createElement('button');
              btn.className = 'item-action-btn mystery-bag-open-btn';
              btn.textContent = 'Open';
              btn.style.background = '#ffba3a';
              btn.style.color = '#23252a';
              btn.style.fontWeight = 'bold';
              btn.style.marginTop = '6px';
              btn.onclick = function(e) {
                e.stopPropagation();
                showMysteryBagUI(item, idx, itemsArr);
              };
              card.appendChild(btn);
            }
          }
        });
      };
    }
  });

  function showMysteryBagUI(item, idx, itemsArr) {
    const ui = document.getElementById('mystery-bag-ui');
    const inner = document.getElementById('mystery-bag-ui-inner');
    if (!ui || !inner) return;
    // Reset UI state
    inner.querySelector('.bag-icon').textContent = "üéí";
    inner.querySelector('.bag-title').textContent = "The Mystery Bag";
     inner.querySelector('.bag-details').textContent = "Your father whom you only seen once left you with his prime possessions, including this bag. It is said to contain powerful items for those who seek adventure.";
    inner.querySelector('.bag-desc').textContent = "A chill runs down your spine as you gaze upon the bag. Its contents are unknown, its power... undeniable.";
    inner.querySelector('.bag-warning').textContent = "Are you ready to reveal your fate?";
    inner.querySelector('.bag-open-btn').style.display = "";
    inner.querySelector('.bag-close-btn').style.display = "none";
    ui.style.display = "flex";

    // Open logic
    inner.querySelector('.bag-open-btn').onclick = function() {
      // Remove bag from inventory/bag
      itemsArr.splice(idx, 1);
      // Add all contents to inventory/bag as appropriate
      const contents = item._mysteryBagContents || [];
      contents.forEach(gear => {
        // If arrows, stack or add to bag
        if (gear.type === "arrows") {
          let found = false;
          for (let i = 0; i < player.bag.length; i++) {
            if (player.bag[i].type === "arrows") {
              player.bag[i].count = (player.bag[i].count || 0) + (gear.count || 0);
              found = true;
              break;
            }
          }
          if (!found) player.bag.push({...gear});
        }
        // If runes/materials, stack in inventory
        else if (gear.type === "material") {
          let found = false;
          for (let i = 0; i < player.inventory.length; i++) {
            if (player.inventory[i].name === gear.name && player.inventory[i].type === "material") {
              player.inventory[i].count = (player.inventory[i].count || 0) + (gear.count || 0);
              found = true;
              break;
            }
          }
          if (!found) player.inventory.push({...gear});
        }
        // Potions/consumables to inventory
        else if (gear.type === "potion" || gear.type === "consumable") {
          player.inventory.push({...gear});
        }
        // Equip first weapon/armor/helmet/shield/amulet/ring/cloak/boots/arrows if not equipped, else bag
        else if (gear.type === "weapon" && !player.equipment.weapon) player.equipment.weapon = {...gear};
        else if (gear.type === "armor" && !player.equipment.armor) player.equipment.armor = {...gear};
        else if (gear.type === "helmet" && !player.equipment.helmet) player.equipment.helmet = {...gear};
        else if (gear.type === "shield" && !player.equipment.shield) player.equipment.shield = {...gear};
        else if (gear.type === "amulet" && !player.equipment.amulet) player.equipment.amulet = {...gear};
        else if (gear.type === "ring" && !player.equipment.ring) player.equipment.ring = {...gear};
        else if (gear.type === "cloak" && !player.equipment.cloak) player.equipment.cloak = {...gear};
        else if (gear.type === "boots" && !player.equipment.boots) player.equipment.boots = {...gear};
        else player.bag.push({...gear});
      });
      // Show a little animation or message
      inner.querySelector('.bag-title').textContent = "The Bag Opens...";
      inner.querySelector('.bag-desc').textContent = "A surge of energy bursts forth as you open the bag, revealing your starting gear!";
      inner.querySelector('.bag-warning').textContent = "";
      inner.querySelector('.bag-icon').textContent = "‚ú®";
      inner.querySelector('.bag-details').textContent = ""; 
      inner.querySelector('.bag-open-btn').style.display = "none";
      inner.querySelector('.bag-close-btn').style.display = "";
      if (typeof renderBagInv === "function") renderBagInv();
      if (typeof renderEquipment === "function") renderEquipment();
      if (typeof renderPlayerStats === "function") renderPlayerStats();
    };
    // Close logic
    inner.querySelector('.bag-close-btn').onclick = function() {
      ui.style.display = "none";
    };
    // Also close if user clicks outside the inner box
    ui.onclick = function(e) {
      if (e.target === ui) ui.style.display = "none";
    };
  }
</script>
<div id="top-left-bar" style="display:flex;position:fixed;top:10px;left:10px;z-index:2200;align-items:center;gap:10px;border-radius:10px;padding:7px 16px;font-size:1em;min-width:220px;user-select:none;background:#23252a;"></div>
<div id="date-overlay-ui" style="position:fixed;top:10px;right:10px;z-index:2200;background:#23252a;border-radius:10px;padding:7px 16px;box-shadow:0 2px 12px #0007;display:flex;align-items:center;">
  <span id="update-date-label"></span>
  <select id="update-date-dropdown" style="margin-left:10px;">
    <option value="">Select a date...</option>
    <option value="__add__" style="color:#ffba3a;">‚ûï Add Date...</option>
  </select>
  <label style="margin-left:10px;font-size:0.98em;">
    <input type="checkbox" id="enable-remove-dates" style="vertical-align:middle;margin-right:4px;">
    Remove Dates
  </label>
</div>
<script>
  // Date overlay logic: show only on intro overlay, hide on all others
  function updateDateOverlayVisibility() {
    var dateOverlay = document.getElementById('date-overlay-ui');
    var introOverlay = document.getElementById('intro-overlay');
    // List of overlays that should hide the date overlay
    var overlays = [
      'username-overlay', 'bank-modal-bg', 'special-seller-popup', 'town-popup',
      'ancient-boss-popup', 'multi-use-popup', 'panel-locations-popup'
    ];
    var otherVisible = overlays.some(function(id) {
      var el = document.getElementById(id);
      return el && el.style.display !== 'none' && el.style.display !== '';
    });
    if (dateOverlay) {
      if (introOverlay && introOverlay.style.display !== 'none' && introOverlay.style.display !== '' && !otherVisible) {
        dateOverlay.style.display = '';
      } else {
        dateOverlay.style.display = 'none';
      }
    }
  }

  // Helper: load/save dates from localStorage
  function getSavedDates() {
    try {
      return JSON.parse(localStorage.getItem('customDates') || '[]');
    } catch {
      return [];
    }
  }
  function saveDates(dates) {
    localStorage.setItem('customDates', JSON.stringify(dates));
  }
  function renderDateDropdown() {
    var dateDropdown = document.getElementById('update-date-dropdown');
    if (!dateDropdown) return;
    // Save current value
    var currentValue = dateDropdown.value;
    // Remove all except the default and add option
    while (dateDropdown.options.length > 0) dateDropdown.remove(0);
    var defaultOpt = document.createElement('option');
    defaultOpt.value = '';
    defaultOpt.textContent = 'Code update dates click to view';
    dateDropdown.appendChild(defaultOpt);
    var dates = getSavedDates();
    dates.forEach(function(date) {
      var opt = document.createElement('option');
      opt.value = date;
      opt.textContent = date;
      dateDropdown.appendChild(opt);
    });
    var addOpt = document.createElement('option');
    addOpt.value = '__add__';
    addOpt.style.color = '#ffba3a';
    addOpt.textContent = '‚ûï Add Date...';
    dateDropdown.appendChild(addOpt);
    // Restore value if possible
    if (dates.includes(currentValue)) dateDropdown.value = currentValue;
    else dateDropdown.value = '';
  }

  // Show password prompt, callback(true/false)
  function showDatePasswordPrompt(action, cb) {
    // Remove old popup if exists
    let old = document.getElementById('date-password-popup');
    if (old) old.remove();
    // Create popup
    const popup = document.createElement('div');
    popup.id = 'date-password-popup';
    popup.style = 'position:fixed;z-index:100001;top:0;left:0;width:100vw;height:100vh;background:#191a1ecc;display:flex;align-items:center;justify-content:center;';
    popup.innerHTML = `
      <div style="background:#23252a;padding:32px 38px 24px 38px;border-radius:18px;box-shadow:0 2px 24px #000a;display:flex;flex-direction:column;align-items:center;min-width:320px;">
        <div style="color:#ffba3a;font-size:1.1em;margin-bottom:18px;">Enter password to ${action} date</div>
        <input id="date-password-input" type="password" placeholder="Password..." style="font-size:1.1em;padding:6px 18px;border-radius:7px;border:1.5px solid #444;background:#18191c;color:#fff;margin-bottom:18px;width:180px;outline:none;">
        <div id="date-password-error" style="color:#ff4444;margin-bottom:10px;display:none;font-size:1em;"></div>
        <div style="display:flex;gap:18px;">
          <button id="date-password-ok" style="font-size:1.1em;font-weight:bold;background:#ffba3a;color:#23252a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">OK</button>
          <button id="date-password-cancel" style="font-size:1.1em;font-weight:bold;background:#35373e;color:#ffba3a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">Cancel</button>
        </div>
      </div>
    `;
    document.body.appendChild(popup);
    document.getElementById('date-password-ok').onclick = function() {
      const val = document.getElementById('date-password-input').value;
      if (val === DATE_PASSWORD) {
        popup.remove();
        cb(true);
      } else {
        document.getElementById('date-password-error').textContent = "Incorrect password.";
        document.getElementById('date-password-error').style.display = 'block';
      }
    };
    document.getElementById('date-password-cancel').onclick = function() {
      popup.remove();
      cb(false);
    };
    document.getElementById('date-password-input').addEventListener('keydown', function(e) {
      if (e.key === 'Enter') document.getElementById('date-password-ok').click();
    });
    setTimeout(() => document.getElementById('date-password-input').focus(), 100);
  }

  document.addEventListener('DOMContentLoaded', function() {
    updateDateOverlayVisibility();
    renderDateDropdown();
    // Observe overlays for display changes
    [
      'intro-overlay', 'username-overlay', 'bank-modal-bg', 'special-seller-popup', 'town-popup',
      'ancient-boss-popup', 'multi-use-popup', 'panel-locations-popup'
    ].forEach(function(id) {
      var el = document.getElementById(id);
      if (el) {
        var observer = new MutationObserver(updateDateOverlayVisibility);
        observer.observe(el, { attributes: true, attributeFilter: ['style'] });
      }
    });

    var dateDropdown = document.getElementById('update-date-dropdown');
    var removeDatesCheckbox = document.getElementById('enable-remove-dates');
    let removeMode = false;

    if (removeDatesCheckbox) {
      removeDatesCheckbox.addEventListener('change', function() {
        removeMode = removeDatesCheckbox.checked;
        // Optionally, visually indicate remove mode
        if (removeMode) {
          dateDropdown.style.background = '#ff4444';
          dateDropdown.style.color = '#fff';
        } else {
          dateDropdown.style.background = '';
          dateDropdown.style.color = '';
        }
      });
    }

    if (dateDropdown) {
      dateDropdown.addEventListener('change', function() {
        if (removeMode && dateDropdown.value && dateDropdown.value !== '' && dateDropdown.value !== '__add__') {
          // Prompt for password before removing
          showDatePasswordPrompt("remove", function(success) {
            if (!success) {
              dateDropdown.value = '';
              return;
            }
            var dates = getSavedDates();
            var idx = dates.indexOf(dateDropdown.value);
            if (idx !== -1) {
              if (confirm('Remove date "' + dateDropdown.value + '"?')) {
                dates.splice(idx, 1);
                saveDates(dates);
                renderDateDropdown();
                dateDropdown.value = '';
              } else {
                // If cancelled, reset dropdown
                dateDropdown.value = '';
              }
            } else {
              dateDropdown.value = '';
            }
          });
          return; // Prevent further logic if in remove mode
        }
        if (dateDropdown.value === '__add__') {
          // Prompt for password before adding
          showDatePasswordPrompt("add", function(success) {
            if (!success) {
              dateDropdown.value = '';
              return;
            }
            var newDate = prompt('Enter a new date (e.g. 2024-06-01):');
            if (newDate && newDate.trim()) {
              var dates = getSavedDates();
              if (!dates.includes(newDate)) {
                dates.push(newDate);
                saveDates(dates);
                renderDateDropdown();
                dateDropdown.value = newDate;
              } else {
                alert('Date already exists.');
                dateDropdown.value = '';
              }
            } else {
              dateDropdown.value = '';
            }
          });
        }
      });
    }
  });
</script>
<div id="intro-overlay">
  <div>
    <div id="intro-title">Fate's Awakening</div>
    <div id="intro-story">
    </div>
    <button id="accept-fate-btn" class="accept-fate-pulse">Accept Fate</button>
  </div>
</div>
<style>
  #intro-overlay {
    position: fixed;
    z-index: 5000;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, #191a1e 60%, #23252a 100%);
    background-image:
      url('https://images.unsplash.com/photo-1506744038136-46273834b3fb?auto=format&fit=crop&w=1200&q=80');
    background-size: cover;
    background-position: center;
    box-shadow: 0 0 120px #23252a inset;
  }
  #intro-overlay > div {
    position: relative;
    z-index: 2;
    background: #23252af2;
    padding: 32px 32px 28px 32px;
    border-radius: 32px;
    box-shadow: 0 8px 48px #ffba3a66, 0 2px 32px #000a;
    display: flex;
    flex-direction: column;
    align-items: center;
    max-width: 520px;
    width: 96vw;
    min-width: 320px;
    min-height: 340px;
}
#accept-fate-btn.accept-fate-pulse {
  font-size: 1.45em;
  font-weight: bold;
  background: linear-gradient(90deg,#ffba3a 70%,#ffd36b 100%);
  color: #23252a;
  border: none;
  border-radius: 14px;
  padding: 20px 64px;
  cursor: pointer;
  box-shadow: 0 4px 32px #ffba3a99, 0 0 18px #ffd36b88;
  letter-spacing: 2px;
  margin-top: 28px;
  margin-bottom: 8px;
  transition: background 0.18s, color 0.18s, transform 0.18s;
  animation: fatePulseGlow 1.1s infinite alternate;
  outline: 3px solid #ffba3a44;
}
#accept-fate-btn.accept-fate-pulse:hover {
  background: linear-gradient(90deg,#ffd36b 70%,#ffba3a 100%);
  color: #191a1e;
  transform: scale(1.08);
  box-shadow: 0 0 48px #ffd36bcc, 0 0 24px #ffba3a;
}
@keyframes fatePulseGlow {
  0% {
    box-shadow: 0 0 18px #ffba3a99, 0 0 8px #ffd36b88;
    transform: scale(1);
    opacity: 1;
  }
  60% {
    box-shadow: 0 0 48px #ffd36bcc, 0 0 24px #ffba3a;
    transform: scale(1.09);
    opacity: 0.97;
  }
  100% {
    box-shadow: 0 0 18px #ffba3a99, 0 0 8px #ffd36b88;
    transform: scale(1);
    opacity: 1;
  }
}
  
</style>
<script>
  // Hide all overlays and main UI until Accept Fate is clicked
</script>
<script>
  // Hide all overlays and main UI until Accept Fate is clicked
  // Function to start the game (called from Accept Fate button)
  function startGame() {
    // Show main game UI
    let mainContainer = document.getElementById('container');
    if (mainContainer) mainContainer.style.display = '';
    
    // Show all game UI elements
    [
      'main-save-ui', 'explore-bar', 'direction-select-bar', 'prayer-panel', 'prayer-altar-panel', 'panel-locations-btn'
    ].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.style.display = '';
    });
    
    // Initialize map and player position before rendering
    if (typeof initMap === "function") {
      initMap();
      playerPosition = { x: Math.floor(mapSize/2), y: Math.floor(mapSize/2) };
      discovered[playerPosition.y][playerPosition.x] = true;
    }
    
    // Render all game UI components
    if (typeof renderPlayerStats === "function") renderPlayerStats();
    if (typeof renderDerivedStats === "function") renderDerivedStats();
    if (typeof renderEquipment === "function") renderEquipment();
    if (typeof renderBagInv === "function") {
      renderBagInv();
      // Add mystery bag open buttons after rendering
      setTimeout(addMysteryBagOpenButton, 100);
    }
    if (typeof renderMap === "function") renderMap();
    
    // Continue playing background music if it was loaded
    if (backgroundAudio && musicLoaded) {
      backgroundAudio.play().catch(() => {
        document.body.addEventListener('click', () => backgroundAudio.play(), { once: true });
      });
    }
    
    // Log welcome message
    if (typeof logMsg === "function") {
      logMsg(`Welcome, ${player.name} the ${player.class || 'Adventurer'}! Your journey begins...`);
      logMsg(`You notice a mysterious bag in your inventory. Perhaps you should open it!`);
    }
  }

  document.addEventListener('DOMContentLoaded', function() {
    // Accept Fate button logic - now starts the game directly
    document.getElementById('accept-fate-btn').onclick = function() {
      // Hide intro overlay
      document.getElementById('intro-overlay').style.display = 'none';
      
      // Show the main game UI
      startGame();
    };
    // Patch username submit to give mystery bag and show game UI
    let usernameSubmit = document.getElementById('username-submit');
    if (usernameSubmit) {
      usernameSubmit.onclick = function() {
        const input = document.getElementById('username-input');
        const error = document.getElementById('username-error');
        const val = input.value.trim();
        if (!val) {
          error.textContent = 'Please enter a username.';
          error.style.display = 'block';
          return;
        }
        player.name = val;
        error.style.display = 'none';
        document.getElementById('username-overlay').style.display = 'none';
        // Set player class based on selected class
        if (window._selectedClass) {
          player.class = window._selectedClass.charAt(0).toUpperCase() + window._selectedClass.slice(1);
        } else {
          player.class = '';
        }
        // Give only the mystery bag (not direct starter gear)
        if (window._selectedClass) {
          // Reset inventory, bag, equipment
          player.inventory = [];
          player.bag = [];
          player.equipment = {
            helmet: null, weapon: null, armor: null, ring: null, arrows: null,
            cloak: null, shield: null, amulet: null, gloves: null, boots: null
          };
          // Add mystery bag to inventory
          player.inventory.push(getMysteryBagForClass(window._selectedClass));
        }
        // Show main game UI
        let mainContainer = document.getElementById('container');
        if (mainContainer) mainContainer.style.display = '';
        [
          'main-save-ui', 'explore-bar', 'direction-select-bar', 'prayer-panel', 'prayer-altar-panel', 'panel-locations-btn'
        ].forEach(id => {
          const el = document.getElementById(id);
          if (el) el.style.display = '';
        });
        // Initialize map and player position before rendering
        if (typeof initMap === "function") {
          initMap();
          playerPosition = { x: Math.floor(mapSize/2), y: Math.floor(mapSize/2) };
          discovered[playerPosition.y][playerPosition.x] = true;
        }
        // Render stats, including class in player stats UI
        if (typeof renderPlayerStats === "function") renderPlayerStats();
        // Insert class row in player stats UI if not present
        const ul = document.getElementById('player-stats-ul');
        if (ul && player.class) {
          let classLi = ul.querySelector('.class-li');
          if (!classLi) {
            classLi = document.createElement('li');
            classLi.className = 'class-li';
            classLi.innerHTML = `<span class="player-class" style="color:#ffd36b;font-weight:bold;">Class:</span> ${player.class}`;
            // Insert after Name row (first li)
            if (ul.children.length > 0) {
              ul.insertBefore(classLi, ul.children[1]);
            } else {
              ul.appendChild(classLi);
            }
          } else {
            classLi.innerHTML = `<span class="player-class" style="color:#ffd36b;font-weight:bold;">Class:</span> ${player.class}`;
          }
        }
        if (typeof renderDerivedStats === "function") renderDerivedStats();
        if (typeof renderEquipment === "function") renderEquipment();
        if (typeof renderBagInv === "function") renderBagInv();
        if (typeof renderMap === "function") renderMap();
        // Play music if available
        const music = document.getElementById('username-music');
        if (music) {
          music.currentTime = 0;
          music.play().catch(() => {
            document.body.addEventListener('click', () => music.play(), { once: true });
          });
        }
      };
    }
  });

  // Patch renderPlayerStats to show class if present
  renderPlayerStats = function() {
    if (typeof origRenderPlayerStats === "function") origRenderPlayerStats();
    // Add class row if player.class is set
    const ul = document.getElementById('player-stats-ul');
    if (!ul) return;
    let classLi = ul.querySelector('.class-li');
    if (!classLi && player.class) {
      classLi = document.createElement('li');
      classLi.className = 'class-li';
      classLi.innerHTML = `<span class="player-class" style="color:#ffd36b;font-weight:bold;">Class:</span> ${player.class}`;
      // Insert after Name row (first li)
      if (ul.children.length > 0) {
        ul.insertBefore(classLi, ul.children[1]);
      } else {
        ul.appendChild(classLi);
      }
    } else if (classLi) {
      classLi.innerHTML = `<span class="player-class" style="color:#ffd36b;font-weight:bold;">Class:</span> ${player.class || ''}`;
    }
  };
</script>

<title>Legend of III Game Web Interface</title>
<style>
  
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: #202124;
      color: #eee;
      margin: 0;
      padding: 0;
    }
    #container {
      display: grid;
      grid-template-columns: 420px 1fr 420px;
      gap: 18px;
      padding: 26px;
      max-width: 2200px;
      margin: auto;
    }
    #explore-bar {
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 28px;
      margin-top: 10px;
    }
    #explore-btn-top {
      background: #ffba3a;
      color: #23252a;
      border-radius: 12px;
      border: none;
      padding: 14px 52px;
      font-weight: bold;
      font-size: 1.47em;
      cursor: pointer;
      box-shadow: 0 2px 14px #0006;
      letter-spacing: 1.5px;
      transition: background 0.18s, color 0.18s;
    }
    #explore-btn-top:hover {
      background: #ffd36b;
      color: #111;
    }
    #direction-select-bar {
      display: none;
      justify-content: center;
      align-items: center;
      margin-bottom: 18px;
      gap: 10px;
    }
    #direction-select-bar.active {
      display: flex;
    }
    .direction-btn {
      background: #35373e;
      color: #ffba3a;
      border: none;
      border-radius: 8px;
      padding: 10px 22px;
      font-weight: bold;
      font-size: 1.1em;
      cursor: pointer;
      margin: 0 4px;
      transition: background 0.17s;
    }
    .direction-btn:hover {
      background: #ffba3a;
      color: #23252a;
    }
    #left-col {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .panel {
      background: #292c31;
      border-radius: 10px;
      padding: 16px;
      box-shadow: 0 2px 10px #000a;
      margin-bottom: 0;
      min-width: 370px;
    }
    .panel h2 {
      margin-top: 0;
      color: #ffba3a;
      font-size: 1.19em;
      letter-spacing: 1px;
      margin-bottom: 9px;
      text-shadow: 0 0 3px #222, 0 2px 1px #1919195c;
    }
    #player-stats-ul {
      list-style: none; margin: 0; padding: 0;
      font-size: 1.05em;
    }
    #player-stats-ul li { margin-bottom: 3px; }
    .gold { color: gold; }
    .health { color: #90ee90; }
    .level { color: #61dafb; }
    #equipment-panel {
      position: relative;
      overflow: visible;
      padding-bottom: 0;
    }
    #equipment-ui {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: flex-start;
      gap: 10px;
      min-height: 320px;
      margin-bottom: 10px;
    }
    .equipment-side {
      display: flex;
      flex-direction: column;
      gap: 35px;
      min-width: 150px;
    }
    .equipment-side.left {
      align-items: flex-end;
    }
    .equipment-side.right {
      align-items: flex-start;
    }
#char-portrait-box {
  width: 100%;
  max-width: 320px;
  height: 40vw;
  max-height: 480px;
}

#char-portrait {
  width: 100%;
  height: 100%;
}
    .equip-slot {
      width: 150px;
      height: 48px;
      margin: 5px 0;
      background: #23252a;
      border-radius: 6px;
      border: 2.5px solid #353841;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      position: relative;
      cursor: pointer;
      transition: border-color 0.2s;
      font-size: 1.12em;
      color: #ffba3a;
      font-weight: bold;
      padding-left: 14px;
      overflow: visible;
      min-width: 150px;
      max-width: 180px;
      white-space: nowrap;
    }
    .equip-slot.selected, .equip-slot:hover {
      border-color: #ffba3a;
      box-shadow: 0 0 6px #ffba3a90;
      z-index: 4;
    }
    .equip-slot .slot-tooltip {
      display: none;
      position: absolute;
      left: 110%;
      top: 50%;
      transform: translateY(-50%);
      background: #18191c;
      color: #eee;
      padding: 10px 16px;
      border-radius: 10px;
      border: 1.5px solid #444;
      white-space: nowrap;
      font-size: 1.05em;
      box-shadow: 0 2px 12px #0007;
      z-index: 10;
      pointer-events: none;
      min-width: 180px;
    }
    .equip-slot:hover .slot-tooltip {
      display: block;
    }
    #equipment-legend {
      margin-top: 14px;
      color: #aaa;
      font-size: 1.05em;
      text-align: center;
    }
    #baginv-panel {
      min-height: 155px;
    }
    #baginv-tabs {
      display: flex;
      gap: 7px;
      margin-bottom: 12px;
    }
    .baginv-tab {
      font-weight: 600;
      font-size: 1em;
      border: none;
      background: #23252a;
      color: #fff;
      border-radius: 6px 6px 0 0;
      padding: 7px 20px;
      cursor: pointer;
      transition: background 0.22s, color 0.22s;
      outline: none;
      border-bottom: 2px solid transparent;
    }
    .baginv-tab.active, .baginv-tab:hover {
      background: #34373e;
      color: #ffba3a;
      border-bottom: 2px solid #ffba3a;
    }
    #baginv-content {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      min-height: 70px;
      margin-bottom: 2px;
      justify-content: flex-start;
    }
    .item-card {
      background: #23252a;
      border-radius: 7px;
      border: 2px solid #353841;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 7px 10px 7px 10px;
      width: 110px;
      cursor: pointer;
      position: relative;
      transition: border-color 0.18s;
      min-height: 85px;
      font-size: 1em;
      color: #ffba3a;
      font-weight: bold;
      justify-content: center;
      word-break: break-word;
      max-width: 140px;
    }
    .item-card.selected, .item-card:hover {
      border-color: #ffba3a;
      box-shadow: 0 0 7px #ffba3a7c;
      z-index: 5;
    }
    .item-name {
      font-size: 1em;
      color: #fff;
      text-align: center;
      margin-bottom: 2.5px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: normal;
      width: 100%;
      max-width: 120px;
      word-break: break-word;
    }
    .item-actions {
      display: flex;
      gap: 3px;
      margin-top: 1px;
    }
    .item-action-btn {
      font-size: 0.98em;
      border: none;
      background: #35373e;
      color: #fff;
      border-radius: 4px;
      padding: 2px 8px;
      cursor: pointer;
      margin: 0 1px;
      transition: background 0.14s;
    }
    .item-action-btn:hover {
      background: #ffba3a;
      color: #101015;
    }
    .bag-x-remove-btn {
      position: absolute;
      top: 3px;
      left: 4px;
      background: #ff4444;
      color: #fff;
      border: none;
      border-radius: 50%;
      font-size: 1.05em;
      width: 22px;
      height: 22px;
      cursor: pointer;
      z-index: 7;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.12s;
    }
    .bag-x-remove-btn:hover {
      background: #ff0000;
      color: #fff;
    }
    .bag-equip-btn {
      margin-top: 2px;
      font-size: 1.01em;
      border: none;
      background: #35373e;
      color: #fff;
      border-radius: 4px;
      padding: 2px 12px;
      cursor: pointer;
      font-weight: bold;
      width: 90%;
      transition: background 0.14s;
      display: block;
      margin-left: auto;
      margin-right: auto;
    }
    .bag-equip-btn:hover {
      background: #ffba3a;
      color: #101015;
    }
    #center-col {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: start;
      position: relative;
      min-height: 520px;
    }
    #enemy-encounter {
      display: none;
      align-items: center;
      flex-direction: column;
      justify-content: center;
      min-height: 450px;
      width: 355px;
      background: #1b1c23;
      border-radius: 14px;
      box-shadow: 0 4px 28px #000a;
      margin-top: 24px;
      margin-bottom: 18px;
      position: relative;
      z-index: 12;
      border: 2.5px solid #3d3b2f;
      animation: popin 0.38s;
    }
    #chest-encounter {
      display: none;
      align-items: center;
      flex-direction: column;
      justify-content: center;
      min-height: 220px;
      width: 355px;
      background: #1b1c23;
      border-radius: 14px;
      box-shadow: 0 4px 28px #000a;
      margin-top: 24px;
      margin-bottom: 18px;
      position: relative;
      z-index: 13;
      border: 2.5px solid #3d3b2f;
      animation: popin 0.38s;
    }
    #chest-encounter h3 {
      color: #ffba3a;
      margin-top: 18px;
      margin-bottom: 10px;
      font-size: 1.3em;
    }
    #chest-encounter .chest-reward {
      color: gold;
      font-size: 1.2em;
      margin-bottom: 12px;
    }
    #chest-encounter .chest-btn {
      background: #ffba3a;
      color: #23252a;
      border-radius: 10px;
      border: none;
      padding: 10px 32px;
      font-weight: bold;
      font-size: 1.1em;
      cursor: pointer;
      margin-top: 10px;
      transition: background 0.18s, color 0.18s;
    }
    #chest-encounter .chest-btn:hover {
      background: #ffd36b;
      color: #111;
    }
    @keyframes popin {
      0% { opacity: 0; transform: scale(0.82);}
      100% { opacity: 1; transform: scale(1);}
    }
    #enemy-health-top {
      margin-top: 12px;
      margin-bottom: 0;
      width: 130px;
      margin-left: auto;
      margin-right: auto;
      display: block;
    }
    #enemy-hp-bar {
      width: 110px;
      height: 16px;
      background: #2d2222;
      border-radius: 7px;
      border: 1px solid #555;
      margin: 0 7px 0 0;
      position: relative;
      overflow: hidden;
      display: inline-block;
      vertical-align: middle;
    }
    #enemy-hp-bar-inner {
      background: linear-gradient(90deg, #ff6060 60%, #ffd700 100%);
      height: 100%;
      transition: width 0.22s;
      border-radius: 7px;
      position: absolute; left: 0; top: 0;
    }
    #enemy-hp-bar-text {
      color: #fff;
      font-size: 0.95em;
      position: absolute;
      width: 100%;
      text-align: center;
      left: 0; top: 0;
      pointer-events: none;
      text-shadow: 0 0 3px #000;
    }
    #attack-label {
      font-family: 'Oswald', 'Segoe UI', Arial, sans-serif;
      font-weight: bold;
      color: #ffba3a;
      text-shadow: 0 2px 6px #000, 0 0 2px #fff8;
      font-size: 2.1em;
      letter-spacing: 2px;
      margin-bottom: 0;
      text-align: center;
      margin-top: 6px;
      margin-bottom: 5px;
      user-select: none;
    }
    #enemy-image {
      width: 158px;
      height: 158px;
      margin: 25px auto 5px auto;
      background: #23252a;
      border-radius: 10px;
      box-shadow: 0 2px 14px #0007, 0 0 8px #ff55552a;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      border: 2px solid #444;
      z-index: 2;
      font-size: 1.44em;
      color: #ffba3a;
      font-weight: bold;
      text-align: center;
      justify-content: center;
    }
    #enemy-name-label {
      font-size: 1.05em;
      font-weight: bold;
      color: #ffba3a;
      text-align: center;
      margin-bottom: 10px;
    }
    #enemy-controls {
      margin: 8px 0 19px 0;
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 19px;
      justify-content: center;
    }
    .enemy-action-btn {
      font-size: 1.04em;
      border: none;
      background: #35373e;
      color: #fff;
      border-radius: 7px;
      padding: 4px 18px;
      cursor: pointer;
      font-weight: bold;
      transition: background 0.19s;
      margin: 0 2px;
      min-width: 78px;
    }
    .enemy-action-btn#attack-enemy-btn {
      order: -1;
      margin-right: 10px;
    }
    .enemy-action-btn#run-enemy-btn {
      order: 1;
    }
    .enemy-action-btn:hover { background: #ffba3a; color: #191717;}
    .hitsplat {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        top: 14px;
        background: #ff4444;
        color: #fff;
        font-weight: bold;
        padding: 4px 16px;
        border-radius: 11px;
        font-size: 1.3em;
        box-shadow: 0 1px 6px #a00a;
        opacity: 0.93;
        animation: splat 0.9s cubic-bezier(.59,.22,.44,1.36);
        pointer-events: none;
        z-index: 5;
        border: 2.2px solid #fff3;
      }
      @keyframes splat {
        0% { top: 34px; opacity: 0.01;}
        17% { opacity: 1;}
        50% { top: -16px; opacity: 0.95;}
        90% { opacity: 0.95;}
        100% { top: -32px; opacity: 0;}
      }
      @keyframes hitsplatFade {
        0% { transform: translateY(0) scale(1); opacity: 1; }
        100% { transform: translateY(-50px) scale(0.8); opacity: 0; }
      }
      .hitsplat {
        font-size: 1.5em;
        font-weight: bold;
        pointer-events: none;
        text-shadow: 0 0 8px rgba(0,0,0,0.5);
      }
    #right-col {
      display: flex;
      flex-direction: column;
      gap: 16px;
      min-width:650px;
    }
    
    #map-panel {
      padding-bottom: 9px;
    }
    #map-container {
      background: linear-gradient(135deg, #23252a 60%, #18191c 100%);
      border-radius: 18px;
      border: 3px solid #444;
      width: 700px;
      min-width: 700px;
      max-width: 100vw;
      margin: 0 auto;
      padding: 18px 0 12px 0;
      box-shadow: 0 0 24px #000a, 0 2px 18px #23252a88;
      position: relative;
      overflow: visible;
    }
    #map-container::before {
      content: "";
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
      border-radius: 18px;
      box-shadow: 0 0 80px #ffba3a22, 0 0 120px #3887e022 inset;
      z-index: 1;
    }
    #map-index {
      display: flex;
      flex-wrap: wrap;
      gap: 10px 18px;
      margin: 10px 0 18px 0;
      justify-content: center;
      font-size: 1.05em;
      position: relative;
      z-index: 2;
      background: #23252a88;
      border-radius: 8px;
      padding: 6px 0;
      box-shadow: 0 1px 8px #0003;
    }
    .map-index-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-weight: bold;
      filter: drop-shadow(0 0 2px #0008);
    }
    .map-index-color {
      display: inline-block;
      width: 18px;
      height: 18px;
      border-radius: 4px;
      border: 2px solid #444;
      margin-right: 4px;
      vertical-align: middle;
      box-shadow: 0 0 6px #0006;
    }
    #game-map {
      display: grid;
      grid-template-columns: repeat(18, 34px);
      grid-template-rows: repeat(18, 34px);
      gap: 3px;
      background: linear-gradient(120deg, #23252a 80%, #18191c 100%);
      border-radius: 14px;
      border: 2.5px solid #444;
      width: 646px;
      min-width: 646px;
      max-width: 100vw;
      margin: auto;
      box-shadow: 0 0 24px #000a, 0 2px 18px #23252a88;
      position: relative;
      z-index: 2;
      overflow: visible;
    }
    .map-cell {
      width: 34px;
      height: 34px;
      background: #222;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1em;
      color: #fff;
      position: relative;
      overflow: visible;
      border: 1.5px solid #292c31;
      font-weight: bold;
      text-align: center;
      cursor: pointer;
      transition: background 0.18s, color 0.18s, box-shadow 0.18s;
      user-select: none;
      box-shadow: 0 0 8px #0004;
      filter: drop-shadow(0 0 2px #0008);
    }
    .map-cell.player {
      outline: 3px solid #ffe066;
      z-index: 3;
      box-shadow: 0 0 18px #ffe06699, 0 0 8px #fff;
      animation: playerPulse 1.2s infinite alternate;
    }
    @keyframes playerPulse {
      0% { box-shadow: 0 0 18px #ffe06699, 0 0 8px #fff; }
      100% { box-shadow: 0 0 32px #ffe066cc, 0 0 16px #fff; }
    }
    .map-cell.central-town {
      background: radial-gradient(circle at 60% 40%, #e53935 80%, #a00 100%);
      color: #fff;
      font-weight: bold;
      box-shadow: 0 0 18px #e5393593, 0 0 8px #fff3;
      z-index: 2;
      border: 2px solid #e53935;
      animation: townGlow 1.5s infinite alternate;
    }
    @keyframes townGlow {
      0% { box-shadow: 0 0 18px #e5393593, 0 0 8px #fff3; }
      100% { box-shadow: 0 0 32px #e53935cc, 0 0 16px #fff6; }
    }
    .map-cell.town {
      background: radial-gradient(circle at 60% 40%, #3887e0 80%, #1a4a8a 100%);
      color: #fff;
      font-weight: bold;
      box-shadow: 0 0 18px #3887e093, 0 0 8px #fff3;
      z-index: 2;
      border: 2px solid #3887e0;
      animation: townGlow 1.5s infinite alternate;
    }
    .map-cell.area {
      background: linear-gradient(135deg, #ffe066 80%, #bfae44 100%);
      color: #23252a;
      font-weight: bold;
      border: 1.5px solid #ffe066;
      box-shadow: 0 0 8px #ffe06644;
    }
    .map-cell.discovered {
      background: linear-gradient(135deg, #2e7d32 80%, #90ee90 100%);
      color: #fff;
      border: 1.5px solid #2e7d32;
      box-shadow: 0 0 8px #2e7d3244;
      animation: discoveredPulse 1.2s infinite alternate;
    }
    @keyframes discoveredPulse {
      0% { box-shadow: 0 0 8px #2e7d3244; }
      100% { box-shadow: 0 0 16px #90ee9099; }
    }
    .map-cell.chest {
      background: linear-gradient(135deg, #bfae44 80%, #ffe066 100%);
      color: #23252a;
      border: 2px solid #bfae44;
      box-shadow: 0 0 18px #bfae44cc, 0 0 8px #ffe06666;
      animation: chestPulse 1.2s infinite alternate;
    }
    @keyframes chestPulse {
      0% { box-shadow: 0 0 18px #bfae44cc, 0 0 8px #ffe06666; }
      100% { box-shadow: 0 0 32px #ffe066cc, 0 0 16px #bfae44cc; }
    }
    .map-cell.undiscovered {
      background: repeating-linear-gradient(135deg, #444 0 8px, #23252a 8px 16px);
      color: #888;
      font-style: italic;
      border: 1.5px dashed #444;
      box-shadow: 0 0 4px #444;
      filter: grayscale(0.7);
    }
    
    #game-map::before {
      content: "";
      position: absolute;
      left: -12px; top: -12px; right: -12px; bottom: -12px;
      pointer-events: none;
      border-radius: 18px;
      box-shadow: 0 0 80px #ffba3a22, 0 0 120px #3887e022 inset;
      z-index: 1;
    }
    #game-map::after {
      content: "";
      position: absolute;
      left: 0; top: 0; right: 0; bottom: 0;
      pointer-events: none;
      border-radius: 14px;
     
      opacity: 0.08;
      z-index: 2;
      mix-blend-mode: lighten;
    }
    
    .map-cell:hover {
      box-shadow: 0 0 24px #ffba3a99, 0 0 12px #fff;
      border-color: #ffba3a;
      z-index: 10;
      transform: scale(1.08);
    }
    .map-cell.player:hover {
      outline: 3px solid #fff;
      box-shadow: 0 0 32px #ffe066cc, 0 0 16px #fff;
    }
    
    #map-controls {
      text-align: center;
      margin-top: 8px;
      z-index: 3;
      position: relative;
    }
    .map-move-btn {
      margin: 2px 8px;
      background: linear-gradient(135deg, #35373e 80%, #23252a 100%);
      color: #eee;
      border: none;
      border-radius: 6px;
      padding: 6px 16px;
      cursor: pointer;
      font-size: 1.18em;
      font-weight: bold;
      box-shadow: 0 2px 8px #0004;
      transition: background 0.18s, color 0.18s, box-shadow 0.18s;
    }
    .map-move-btn:hover {
      background: #ffba3a;
      color: #23252a;
      box-shadow: 0 0 12px #ffba3a99;
    }
    #map-area-label {
      margin-top: 12px;
      font-size: 1.08em;
      color: #ffba3a;
      text-align: center;
      font-weight: bold;
      letter-spacing: 1px;
      text-shadow: 0 0 6px #23252a88;
      background: #23252a88;
      border-radius: 8px;
      padding: 4px 0;
      box-shadow: 0 1px 8px #0003;
      z-index: 2;
      position: relative;
    }
    
    #map-container .map-overlay-effect {
      position: absolute;
      pointer-events: none;
      z-index: 10;
      left: 0; top: 0; width: 100%; height: 100%;
      border-radius: 18px;
      mix-blend-mode: lighten;
      opacity: 0.18;
      animation: mapOverlayAnim 6s linear infinite;
      
    }
    @keyframes mapOverlayAnim {
      0% { background-position: 0 0; }
      100% { background-position: 120px 80px; }
    }
    
    @media (max-width: 1100px) {
      #map-container { width: 370px; min-width: 370px; }
      #game-map { grid-template-columns: repeat(18, 18px); grid-template-rows: repeat(18, 18px); width: 342px; min-width: 342px; }
      .map-cell { width: 18px; height: 18px; font-size: 0.55em; }
    
    }
    #bank-panel {
      margin-top: 6px;
      margin-bottom: 0;
      padding-bottom: 10px;
    }
    #bank-open-btn {
      background: #35373e;
      color: #ffba3a;
      border-radius: 8px;
      border: none;
      padding: 6px 20px;
      font-weight: 600;
      font-size: 1.08em;
      cursor: pointer;
      margin: 0 auto 5px auto;
      display: block;
      transition: background 0.17s;
    }
    #bank-open-btn:hover {
      background: #ffba3a;
      color: #26221c;
    }
    #bank-modal-bg {
      display: none;
      position: fixed;
      z-index: 1200;
      top: 0; left: 0; width: 100vw; height: 100vh;
      background: #18191cbb;
      align-items: center;
      justify-content: center;
    }
    #bank-modal {
      background: #23252a;
      border-radius: 18px;
      box-shadow: 0 0 44px #000c, 0 5px 32px #2b2a2a45;
      padding: 32px 29px 24px 29px;
      min-width: 450px;
      min-height: 320px;
      position: relative;
      z-index: 1211;
      display: flex;
      flex-direction: column;
    }
    #bank-modal h2 {
      margin-bottom: 10px;
      color: #ffba3a;
    }
    #bank-close-btn {
      position: absolute; top: 12px; right: 16px;
      font-size: 1.38em;
      background: none;
      border: none;
      color: #fff;
      cursor: pointer;
    }
    #bank-content {
      display: flex;
      flex-direction: row;
      gap: 32px;
      margin-top: 14px;
      justify-content: center;
      align-items: flex-start;
    }
    .bank-section {
      min-width: 180px;
    }
    .bank-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 110px;
    }
    .bank-item-card {
      display: flex;
      align-items: center;
      gap: 8px;
      background: #18191c;
      border-radius: 7px;
      border: 1px solid #444;
      padding: 4px 8px;
      font-size: 0.97em;
      min-width: 120px;
      min-height: 36px;
      color: #ffba3a;
      font-weight: bold;
    }
    .bank-action-btn {
      background: #35373e;
      color: #ffba3a;
      border: none;
      border-radius: 5px;
      padding: 2px 10px;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.98em;
      margin-left: 6px;
      transition: background 0.14s;
    }
    .bank-action-btn:hover { background: #ffba3a; color: #26221c;}
    #bank-empty-msg { color: #888; font-size: 0.95em; text-align: center; margin-top: 13px; }
    #log-panel {
      min-height: 130px;
      margin-top: 7px;
      grid-column:1/4;
      max-width:none;
      width:100%;
      margin-top:24px;
    }
    #game-log {
      height: 142px;
      overflow-y: auto;
      background: #181818;
      padding: 7px 7px;
      border-radius: 4px;
      font-size: 0.99em;
      font-family: 'Fira Mono', 'Consolas', monospace;
      max-height: 142px;
      border: 1.2px solid #333;
      margin-bottom: 1px;
    }
    #derived-stats-panel {
      margin-top: 0;
      margin-bottom: 0;
      padding-bottom: 5px;
    }
    #derived-stats-list {
      list-style: none; margin: 0; padding: 0; font-size: 1em;
    }
    #derived-stats-list li { margin-bottom: 3px; }
    .derived-label { color: #ffba3a; font-weight: bold; margin-right: 5px;}
    #left-col #derived-stats-panel {
      order: 4;
      margin-top: 0;
      margin-bottom: 0;
      min-width: 310px;
    }
    #right-col #derived-stats-panel {
      display: none !important;
    }
    #actions-panel .action-btn:first-child {
      display: none !important;
    }
    @media (max-width: 1400px) {
      #container { grid-template-columns: 1fr; grid-template-rows: auto; }
      #left-col, #right-col { min-width: 175px; }
      #center-col { min-width: 280px;}
      #explore-bar { margin-bottom: 10px; }
      #map-container { width: 370px; min-width: 370px; }
      #game-map { grid-template-columns: repeat(18, 18px); grid-template-rows: repeat(18, 18px); width: 342px; min-width: 342px; }
      #map-index { font-size: 0.85em; }
      .map-index-color { width: 12px; height: 12px; }
    }
    
#map-container {
  background: #1a1b1e;
  border-radius: 9px;
  border: 2px solid #444;
  width: 620px;
  min-width: 620px;
  max-width: 100vw;
  margin: 0 auto;
  padding: 7px 0 4px 0;
  box-shadow: 0 0 8px #0007;
  position: relative;
}

#game-map {
  display: grid;
  grid-template-columns: repeat(18, 32px);
  grid-template-rows: repeat(18, 32px);
  gap: 2px;
  background: #23252a;
  border-radius: 7px;
  border: 2px solid #444;
  width: 596px;
  min-width: 596px;
  max-width: 100vw;
  margin: auto;
}

.map-cell {
  width: 32px;
  height: 32px;
  background: #222;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.75em;
  color: #fff;
  position: relative;
  overflow: hidden;
  border: 1px solid #292c31;
  font-weight: bold;
  text-align: center;
  cursor: pointer;
  transition: background 0.18s, color 0.18s;
  user-select: none;
}

@media (max-width: 1100px) {
  #map-container { width: 370px; min-width: 370px; }
  #game-map { grid-template-columns: repeat(18, 18px); grid-template-rows: repeat(18, 18px); width: 342px; min-width: 342px; }
  .map-cell { width: 18px; height: 18px; font-size: 0.55em; }
}
    .panel-draggable-handle {
      cursor: grab;
      background: #191a1e;
      color: #ffba3a;
      font-weight: bold;
      padding: 4px 0 4px 10px;
      border-radius: 8px 8px 0 0;
      user-select: none;
      margin: -16px -18px 8px -18px;
      font-size: 1.05em;
      letter-spacing: 1px;
    }
    .panel.dragging {
      opacity: 0.6;
    }
    .drop-target {
      outline: 3px dashed #ffba3a;
      background: #23252a44;
    }
    #username-overlay {
      position: fixed;
      z-index: 3000;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #191a1e;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #username-overlay > div {
      background: #23252a;
      padding: 38px 44px 32px 44px;
      border-radius: 18px;
      box-shadow: 0 2px 24px #000a;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #username-overlay h2 {
      color: #ffba3a;
      margin-bottom: 18px;
    }
    #username-input {
      font-size: 1.2em;
      padding: 8px 18px;
      border-radius: 7px;
      border: 1.5px solid #444;
      background: #18191c;
      color: #fff;
      margin-bottom: 18px;
      width: 220px;
      outline: none;
    }
    #username-submit {
      font-size: 1.1em;
      font-weight: bold;
      background: #ffba3a;
      color: #23252a;
      border: none;
      border-radius: 7px;
      padding: 8px 32px;
      cursor: pointer;
    }
    #username-error {
      color: #ff4444;
      margin-top: 10px;
      display: none;
      font-size: 1em;
    }
    #overlay-save-load-ui {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 18px;
    }
    #overlay-save-btn {
      font-weight: bold;
      font-size: 1em;
      background: #ffba3a;
      color: #23252a;
      border: none;
      border-radius: 6px;
      padding: 6px 18px;
      cursor: pointer;
    }
    #overlay-load-btn {
      font-weight: bold;
      font-size: 1em;
      background: #35373e;
      color: #ffba3a;
      border: none;
      border-radius: 6px;
      padding: 6px 18px;
      cursor: pointer;
      display: none;
    }
    #overlay-save-list {
      display: none;
      margin-left: 8px;
      font-size: 1em;
      padding: 4px 8px;
      border-radius: 5px;
    }
    
    #main-save-ui {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 2100;
      background: #23252a;
      border-radius: 10px;
      padding: 8px 16px;
      box-shadow: 0 2px 12px #0007;
      display: flex;
      gap: 8px;
      align-items: center;
    }
    #overlay-load-delete-ui {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 18px;
    }
    #overlay-delete-btn {
      font-weight: bold;
      font-size: 1em;
      background: #ff4444;
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 6px 18px;
      cursor: pointer;
      display: none;
    }
    #delete-save-ui {
      display: none;
      flex-direction: column;
      align-items: center;
      margin-bottom: 10px;
    }
    #delete-save-list {
      margin-bottom: 8px;
      font-size: 1em;
      padding: 4px 8px;
      border-radius: 5px;
    }
    #confirm-delete-btn {
      background: #ff4444;
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 6px 18px;
      cursor: pointer;
    }
    #flame-bg {
      position: fixed;
      top: 0; left: 0; width: 100vw; height: 100vh;
      z-index: 0;
      pointer-events: none;
      display: block;
      background: #191a1e;
    }
    body > *:not(#flame-bg) {
      position: relative;
      z-index: 1;
    }
  </style>
  <script>
    // Show date overlay UI only on intro overlay, hide on all other overlays
    function updateDateOverlayVisibility() {
      var dateOverlay = document.getElementById('date-overlay-ui');
      var introOverlay = document.getElementById('intro-overlay');
      // List of overlays that should hide the date overlay
      var overlays = [
        'username-overlay', 'bank-modal-bg', 'special-seller-popup', 'town-popup',
        'ancient-boss-popup', 'multi-use-popup', 'panel-locations-popup'
      ];
      var otherVisible = overlays.some(function(id) {
        var el = document.getElementById(id);
        return el && el.style.display !== 'none' && el.style.display !== '';
      });
      if (dateOverlay) {
        if (introOverlay && introOverlay.style.display !== 'none' && !otherVisible) {
          dateOverlay.style.display = '';
        } else {
          dateOverlay.style.display = 'none';
        }
      }
    }
    document.addEventListener('DOMContentLoaded', updateDateOverlayVisibility);
    // Observe overlays for display changes
    [
      'intro-overlay', 'username-overlay', 'bank-modal-bg', 'special-seller-popup', 'town-popup',
      'ancient-boss-popup', 'multi-use-popup', 'panel-locations-popup'
    ].forEach(function(id) {
      var el = document.getElementById(id);
      if (el) {
        var observer = new MutationObserver(updateDateOverlayVisibility);
        observer.observe(el, { attributes: true, attributeFilter: ['style'] });
      }
    });
  </script>
</head>
<body style="margin:0;padding:0;">
<canvas id="flame-bg"></canvas>
<div id="main-save-ui" style="position:fixed;top:10px;left:10px;z-index:2100;background:#23252a;border-radius:10px;padding:8px 16px;box-shadow:0 2px 12px #0007;display:flex;gap:8px;align-items:center;">
  <button id="main-save-btn" style="font-weight:bold;font-size:1em;background:#ffba3a;color:#23252a;border:none;border-radius:6px;padding:6px 18px;cursor:pointer;">Save</button>
  <button id="main-load-btn" style="font-weight:bold;font-size:1em;background:#35373e;color:#ffba3a;border:none;border-radius:6px;padding:6px 18px;cursor:pointer;">Load Save State</button>
  <input type="file" id="main-load-input" accept=".json,application/json" style="display:none;" multiple>
  <input type="file" id="validation-load-input" accept=".json,application/json" style="display:none;">
</div>
<div id="main-intro-overlay" style="position:fixed;z-index:3000;top:0;left:0;width:100vw;height:100vh;display:flex;align-items:center;justify-content:center;color:#fff;font-family:'Arial',sans-serif;background:linear-gradient(135deg, #191a1e 60%, #23252a 100%);background-image:url('https://images.unsplash.com/photo-1506744038136-46273834b3fb?auto=format&fit=crop&w=1200&q=80');background-size:cover;background-position:center;box-shadow:0 0 120px #23252a inset;">
  
  <!-- Load Save button in top-left corner of overlay -->
  <button id="load-save-btn" style="position:absolute;top:20px;left:20px;z-index:3100;background:#9c27b0;color:#fff;border:none;padding:12px 20px;border-radius:8px;cursor:pointer;font-size:1em;transition:all 0.3s;font-weight:bold;box-shadow:0 4px 12px rgba(156,39,176,0.3);">Load Save</button>
  
  <div style="position:relative;z-index:2;background:rgba(35,37,42,0.95);border-radius:25px;padding:40px;box-shadow:0 10px 40px rgba(0,0,0,0.6);text-align:center;max-width:600px;width:90%;backdrop-filter:blur(10px);">
    
    <div style="margin-bottom:35px;">
      <h3 id="music-title" style="color:#ffba3a;margin:0 0 20px 0;text-align:center;font-size:1.3em;">Background Music</h3>
      <div style="display:flex;gap:12px;justify-content:center;align-items:center;">
        <button id="play-music-btn" disabled style="background:#4caf50;color:#fff;border:none;padding:10px 18px;border-radius:8px;cursor:pointer;font-size:0.95em;transition:all 0.3s;font-weight:bold;opacity:0.5;">Play</button>
        <button id="load-music-btn" style="background:#2196f3;color:#fff;border:none;padding:10px 18px;border-radius:8px;cursor:pointer;font-size:0.95em;transition:all 0.3s;font-weight:bold;">Load Music</button>
        <button id="stop-music-btn" disabled style="background:#f44336;color:#fff;border:none;padding:10px 18px;border-radius:8px;cursor:pointer;font-size:0.95em;transition:all 0.3s;font-weight:bold;opacity:0.5;">Stop</button>
      </div>
      <input type="file" id="music-file-input" accept="audio/*" style="display:none;">
      <input type="file" id="save-file-input" accept=".json,application/json" style="display:none;">
      <audio id="background-audio" loop style="display:none;"></audio>
    </div>

    <div style="margin-bottom:35px;">
      <h2 style="color:#ffba3a;margin:0 0 15px 0;font-size:2em;text-shadow:2px 2px 4px rgba(0,0,0,0.5);">Choose Your Path</h2>
      <p style="color:#ccc;margin:0 0 25px 0;font-size:1.1em;line-height:1.4;">Select your starting class. Each path begins with unique gear and a different story.</p>
      
      <div style="display:flex;gap:20px;justify-content:center;flex-wrap:wrap;">
        <div class="character-class" data-class="melee" style="background:rgba(42,42,62,0.8);border:3px solid transparent;border-radius:15px;padding:25px 20px;cursor:pointer;transition:all 0.3s;text-align:center;min-width:160px;backdrop-filter:blur(5px);">
          <div style="font-size:3.5em;margin-bottom:12px;">‚öîÔ∏è</div>
          <h3 style="color:#ffba3a;margin:0 0 12px 0;font-size:1.3em;font-weight:bold;">Melee</h3>
          <p style="color:#ccc;margin:0;font-size:0.9em;line-height:1.4;">A warrior skilled in close combat. Starts with a sword, shield, and sturdy armor.</p>
        </div>
        
        <div class="character-class" data-class="ranger" style="background:rgba(42,42,62,0.8);border:3px solid transparent;border-radius:15px;padding:25px 20px;cursor:pointer;transition:all 0.3s;text-align:center;min-width:160px;backdrop-filter:blur(5px);">
          <div style="font-size:3.5em;margin-bottom:12px;">üèπ</div>
          <h3 style="color:#ffba3a;margin:0 0 12px 0;font-size:1.3em;font-weight:bold;">Ranger</h3>
          <p style="color:#ccc;margin:0;font-size:0.9em;line-height:1.4;">A master of ranged attacks. Starts with a bow, arrows, and light gear.</p>
        </div>
        
        <div class="character-class" data-class="mage" style="background:rgba(42,42,62,0.8);border:3px solid transparent;border-radius:15px;padding:25px 20px;cursor:pointer;transition:all 0.3s;text-align:center;min-width:160px;backdrop-filter:blur(5px);">
          <div style="font-size:3.5em;margin-bottom:12px;">‚ú®</div>
          <h3 style="color:#ffba3a;margin:0 0 12px 0;font-size:1.3em;font-weight:bold;">Mage</h3>
          <p style="color:#ccc;margin:0;font-size:0.9em;line-height:1.4;">A wielder of arcane power. Starts with a magic staff and enchanted robes.</p>
        </div>
      </div>
    </div>

    <div style="margin-bottom:35px;">
      <h3 style="color:#ffba3a;margin:0 0 15px 0;font-size:1.5em;">Enter Username</h3>
      <input type="text" id="username-input-field" placeholder="Your name..." maxlength="18" style="background:rgba(42,42,62,0.9);color:#fff;border:2px solid #555;border-radius:10px;padding:15px 20px;font-size:1.1em;width:280px;text-align:center;outline:none;transition:all 0.3s;backdrop-filter:blur(5px);">
      <div id="username-error-main" style="color:#ff4444;margin-top:12px;display:none;font-size:0.95em;"></div>
    </div>

    <button id="begin-legend-btn" style="background:linear-gradient(135deg, #ffba3a 0%, #ff8f00 100%);color:#000;border:none;padding:18px 45px;border-radius:12px;font-size:1.4em;font-weight:bold;cursor:pointer;transition:all 0.3s;box-shadow:0 6px 20px rgba(255,186,58,0.4);text-transform:uppercase;letter-spacing:1px;text-shadow:1px 1px 2px rgba(0,0,0,0.2);">Begin Your Legend</button>
  </div>
</div>
<script>
  // Load button logic for main UI
  document.getElementById('main-load-btn').onclick = function() {
    document.getElementById('main-load-input').click();
  };

  // Main intro overlay JavaScript
  let selectedClassMain = null;
  let backgroundAudio = null;
  let musicLoaded = false;

  // Character class selection
  document.addEventListener('DOMContentLoaded', function() {
    const characterClasses = document.querySelectorAll('.character-class');
    characterClasses.forEach(function(classCard) {
      classCard.addEventListener('click', function() {
        // Remove selection from all cards
        characterClasses.forEach(function(card) {
          card.style.border = '3px solid transparent';
          card.classList.remove('selected');
        });
        
        // Add selection to clicked card
        this.style.border = '3px solid #ffba3a';
        this.classList.add('selected');
        selectedClassMain = this.getAttribute('data-class');
      });
    });

    // Music controls
    const loadMusicBtn = document.getElementById('load-music-btn');
    const loadSaveBtn = document.getElementById('load-save-btn');
    const playMusicBtn = document.getElementById('play-music-btn');
    const stopMusicBtn = document.getElementById('stop-music-btn');
    const musicFileInput = document.getElementById('music-file-input');
    const saveFileInput = document.getElementById('save-file-input');
    backgroundAudio = document.getElementById('background-audio');

    loadMusicBtn.addEventListener('click', function() {
      musicFileInput.click();
    });

    loadSaveBtn.addEventListener('click', function() {
      saveFileInput.click();
    });

    musicFileInput.addEventListener('change', function() {
      const file = musicFileInput.files[0];
      const musicTitle = document.getElementById('music-title');
      
      if (file && file.type.startsWith('audio/')) {
        const url = URL.createObjectURL(file);
        backgroundAudio.src = url;
        musicLoaded = true;
        playMusicBtn.disabled = false;
        stopMusicBtn.disabled = false;
        
        // Update the title to show the loaded file name
        const fileName = file.name.length > 30 ? file.name.substring(0, 27) + '...' : file.name;
        musicTitle.textContent = `Background Music: ${fileName}`;
        musicTitle.title = file.name; // Show full name on hover
        
        // Enable buttons and reset their appearance
        playMusicBtn.disabled = false;
        stopMusicBtn.disabled = false;
        playMusicBtn.style.opacity = '1';
        stopMusicBtn.style.opacity = '1';
        playMusicBtn.style.cursor = 'pointer';
        stopMusicBtn.style.cursor = 'pointer';
      } else if (file) {
        alert('Please select a valid audio file.');
        // Reset title if invalid file
        musicTitle.textContent = 'Background Music';
        musicTitle.title = '';
      }
    });

    playMusicBtn.addEventListener('click', function() {
      if (musicLoaded && backgroundAudio) {
        backgroundAudio.play();
        playMusicBtn.textContent = 'Playing...';
        playMusicBtn.disabled = true;
        
        // Re-enable play button when music ends or is paused
        backgroundAudio.addEventListener('ended', function() {
          playMusicBtn.textContent = 'Play';
          playMusicBtn.disabled = false;
        });
        
        backgroundAudio.addEventListener('pause', function() {
          if (backgroundAudio.currentTime === 0) { // Only if stopped, not just paused
            playMusicBtn.textContent = 'Play';
            playMusicBtn.disabled = false;
          }
        });
      }
    });

    stopMusicBtn.addEventListener('click', function() {
      if (backgroundAudio) {
        backgroundAudio.pause();
        backgroundAudio.currentTime = 0;
        
        // Reset the title when music is stopped
        const musicTitle = document.getElementById('music-title');
        if (musicTitle) {
          musicTitle.textContent = 'Background Music';
          musicTitle.title = '';
        }
        
        // Reset music loaded state and disable buttons
        musicLoaded = false;
        playMusicBtn.disabled = true;
        stopMusicBtn.disabled = true;
        playMusicBtn.style.opacity = '0.5';
        stopMusicBtn.style.opacity = '0.5';
        playMusicBtn.style.cursor = 'not-allowed';
        stopMusicBtn.style.cursor = 'not-allowed';
        playMusicBtn.textContent = 'Play'; // Reset button text
        
        // Clear the audio source
        backgroundAudio.src = '';
      }
    });

    // Load save file functionality
    saveFileInput.addEventListener('change', function(e) {
      try {
        const file = e.target.files[0];
        if (!file) throw new Error('No file selected.');
        const reader = new FileReader();
        reader.onload = function(evt) {
          try {
            const saveData = JSON.parse(evt.target.result);
            if (
              !saveData.player ||
              typeof saveData.player !== 'object' ||
              !saveData.visitedTowns ||
              typeof saveData.visitedTowns !== 'object' ||
              !saveData.playerPosition ||
              typeof saveData.playerPosition !== 'object'
            ) {
              throw new Error('Invalid save file structure.');
            }
            
            // Load the save data
            loadSaveData(saveData);
            
            // Hide intro overlay and start the game
            document.getElementById('main-intro-overlay').style.display = 'none';
            startGame();
            
            alert('Game loaded from file! Welcome back, ' + (saveData.player.name || 'Hero') + '!');
          } catch (err) {
            alert('Failed to load save: ' + (err && err.message ? err.message : err));
          }
        };
        reader.readAsText(file);
      } catch (err) {
        alert('Error reading file: ' + (err && err.message ? err.message : err));
      }
      // Clear the input for future loads
      e.target.value = '';
    });

    // Begin Your Legend button
    const beginLegendBtn = document.getElementById('begin-legend-btn');
    const usernameField = document.getElementById('username-input-field');
    const usernameError = document.getElementById('username-error-main');

    beginLegendBtn.addEventListener('click', function() {
      const username = usernameField.value.trim();
      
      if (!username) {
        usernameError.textContent = 'Please enter a username.';
        usernameError.style.display = 'block';
        return;
      }
      
      if (!selectedClassMain) {
        usernameError.textContent = 'Please select a character class.';
        usernameError.style.display = 'block';
        return;
      }

      // Hide error and proceed
      usernameError.style.display = 'none';
      
      // Set up player with selected class and username
      setupPlayerClass(selectedClassMain, username);
      
      // Hide main intro overlay and show character-specific intro
      document.getElementById('main-intro-overlay').style.display = 'none';
      showClassIntro(selectedClassMain);
    });

    // Handle Enter key in username field
    usernameField.addEventListener('keydown', function(event) {
      if (event.key === 'Enter') {
        beginLegendBtn.click();
      }
    });

    // Clear error when typing
    usernameField.addEventListener('input', function() {
      usernameError.style.display = 'none';
    });
  });

  // Function to load save data
  function loadSaveData(saveData) {
    // Reset map first
    if (typeof initMap === "function") {
      initMap();
    }
    
    // Clear visited towns
    if (typeof visitedTowns === "object") {
      Object.keys(visitedTowns).forEach(k => delete visitedTowns[k]);
      // Restore visited towns from save
      if (saveData.visitedTowns) {
        Object.assign(visitedTowns, saveData.visitedTowns);
      }
    }
    
    // Load player data
    player.name = saveData.player.name || "Hero";
    player.class = saveData.player.class || "";
    player.health = typeof saveData.player.health === "number" ? saveData.player.health : 100;
    player.maxHealth = typeof saveData.player.maxHealth === "number" ? saveData.player.maxHealth : 100;
    player.gold = typeof saveData.player.gold === "number" ? saveData.player.gold : 0;
    player.experience = typeof saveData.player.experience === "number" ? saveData.player.experience : 0;
    player.level = typeof saveData.player.level === "number" ? saveData.player.level : 1;
    player.attack = typeof saveData.player.attack === "number" ? saveData.player.attack : 10;
    player.defense = typeof saveData.player.defense === "number" ? saveData.player.defense : 5;
    player.bankGold = typeof saveData.player.bankGold === "number" ? saveData.player.bankGold : 0;
    player.prayer = typeof saveData.player.prayer === "number" ? saveData.player.prayer : 50;
    player.maxPrayer = typeof saveData.player.maxPrayer === "number" ? saveData.player.maxPrayer : 50;
    
    // Load inventory and equipment
    player.inventory = Array.isArray(saveData.player.inventory) ? JSON.parse(JSON.stringify(saveData.player.inventory)) : [];
    player.bag = Array.isArray(saveData.player.bag) ? JSON.parse(JSON.stringify(saveData.player.bag)) : [];
    player.equipment = typeof saveData.player.equipment === "object" && saveData.player.equipment !== null
      ? JSON.parse(JSON.stringify(saveData.player.equipment))
      : { helmet: null, chestplate: null, leggings: null, boots: null, weapon: null, shield: null, gloves: null, cape: null, amulet: null, ring: null, arrows: null };
    player.bank = Array.isArray(saveData.player.bank) ? JSON.parse(JSON.stringify(saveData.player.bank)) : [];
    
    // Set player position (default to central town)
    playerPosition.x = Math.floor(mapSize/2);
    playerPosition.y = Math.floor(mapSize/2);
    if (discovered && discovered[playerPosition.y]) {
      discovered[playerPosition.y][playerPosition.x] = true;
    }
  }

  // Function to set up player based on selected class
  function setupPlayerClass(playerClass, username) {
    // Starter gear for each class (for mystery bag contents)
    let starterGear = {
      melee: [
        { name: "Starter Sword", type: "weapon", attack: 12, rarity: "common", description: "A basic sword for melee combat." },
        { name: "Starter Shield", type: "shield", defense: 8, rarity: "common", description: "A basic shield for blocking attacks." },
        { name: "Starter Armor", type: "chestplate", defense: 10, rarity: "common", description: "Sturdy armor for protection." },
        { name: "Starter Helmet", type: "helmet", defense: 5, maxHealth: 10, rarity: "common", description: "A simple helmet." },
        { name: "Health Potion", type: "consumable", healing: 50, count: 5, rarity: "common" }
      ],
      ranger: [
        { name: "Starter Bow", type: "weapon", attack: 10, rarity: "common", description: "A basic bow for ranged attacks." },
        { name: "Arrows", type: "arrows", attack: 3, count: 50, rarity: "common", description: "A bundle of arrows." },
        { name: "Starter Cloak", type: "cape", defense: 6, maxHealth: 8, rarity: "common", description: "A light cloak for agility." },
        { name: "Starter Boots", type: "boots", defense: 4, maxHealth: 8, rarity: "common", description: "Light boots for quick movement." },
        { name: "Health Potion", type: "consumable", healing: 50, count: 5, rarity: "common" }
      ],
      mage: [
        { name: "Starter Staff", type: "weapon", attack: 11, rarity: "common", description: "A basic staff for casting spells." },
        { name: "Starter Robe", type: "chestplate", defense: 7, rarity: "common", description: "An enchanted robe for mages." },
        { name: "Starter Amulet", type: "amulet", defense: 4, rarity: "common", description: "A magical amulet." },
        { name: "Starter Ring", type: "ring", attack: 2, maxHealth: 6, rarity: "common", description: "A ring that boosts magic." },
        { name: "Health Potion", type: "consumable", healing: 50, count: 5, rarity: "common" },
        { name: "Fire Rune", type: "material", count: 100, rarity: "common", description: "A rune for fire spells." },
        { name: "Air Rune", type: "material", count: 100, rarity: "common", description: "A rune for air spells." },
        { name: "Water Rune", type: "material", count: 100, rarity: "common", description: "A rune for water spells." }
      ]
    };

    // Reset player to base stats
    player = {
      name: username,
      class: playerClass.charAt(0).toUpperCase() + playerClass.slice(1), // Capitalize class name
      level: 1,
      experience: 0,
      health: 100,
      maxHealth: 100,
      attack: 10,
      defense: 5,
      gold: 100,
      inventory: [],
      bag: [],
      equipment: {
        helmet: null, chestplate: null, leggings: null, boots: null,
        weapon: null, shield: null, gloves: null, cape: null,
        amulet: null, ring: null, arrows: null
      },
      position: { x: Math.floor(mapSize/2), y: Math.floor(mapSize/2) },
      prayer: 50,
      maxPrayer: 50
    };

    // Create and add mystery bag with class-specific contents
    const mysteryBag = {
      name: "<span style='color:#e53935;font-weight:bold;'>??????</span>",
      type: "mystery",
      description: "Dare to open it?",
      _mysteryBagContents: starterGear[playerClass] || []
    };
    
    // Add mystery bag to inventory
    player.inventory.push(mysteryBag);

    // Store selected class for later use
    window._selectedClass = playerClass;
    window._starterGear = starterGear[playerClass];
  }

  // Mystery bag functionality
  function showMysteryBagUI(item, idx, itemsArr) {
    const ui = document.getElementById('mystery-bag-ui');
    const inner = document.getElementById('mystery-bag-ui-inner');
    if (!ui || !inner) return;
    
    // Reset UI state
    inner.querySelector('.bag-icon').textContent = "üéí";
    inner.querySelector('.bag-title').textContent = "The Mystery Bag";
    inner.querySelector('.bag-details').textContent = "Your father whom you only seen once left you with his prime possessions, including this bag. It is said to contain powerful items for those who seek adventure.";
    inner.querySelector('.bag-desc').textContent = "A chill runs down your spine as you gaze upon the bag. Its contents are unknown, its power... undeniable.";
    inner.querySelector('.bag-warning').textContent = "Are you ready to reveal your fate?";
    inner.querySelector('.bag-open-btn').style.display = "";
    inner.querySelector('.bag-close-btn').style.display = "none";
    ui.style.display = "flex";

    // Open logic
    inner.querySelector('.bag-open-btn').onclick = function() {
      // Remove bag from inventory/bag
      itemsArr.splice(idx, 1);
      
      // Add all contents to inventory/bag as appropriate
      const contents = item._mysteryBagContents || [];
      contents.forEach(gear => {
        // If arrows, stack or add to bag
        if (gear.type === "arrows") {
          let found = false;
          for (let i = 0; i < player.bag.length; i++) {
            if (player.bag[i].type === "arrows") {
              player.bag[i].count = (player.bag[i].count || 0) + (gear.count || 0);
              found = true;
              break;
            }
          }
          if (!found) player.bag.push({...gear});
        }
        // If runes/materials, stack in inventory
        else if (gear.type === "material") {
          let found = false;
          for (let i = 0; i < player.inventory.length; i++) {
            if (player.inventory[i].name === gear.name && player.inventory[i].type === "material") {
              player.inventory[i].count = (player.inventory[i].count || 0) + (gear.count || 0);
              found = true;
              break;
            }
          }
          if (!found) player.inventory.push({...gear});
        }
        // Potions/consumables to inventory
        else if (gear.type === "consumable") {
          player.inventory.push({...gear});
        }
        // Equip first weapon/armor/helmet/shield/amulet/ring/cape/boots if not equipped, else bag
        else if (gear.type === "weapon" && !player.equipment.weapon) player.equipment.weapon = {...gear};
        else if (gear.type === "chestplate" && !player.equipment.chestplate) player.equipment.chestplate = {...gear};
        else if (gear.type === "helmet" && !player.equipment.helmet) player.equipment.helmet = {...gear};
        else if (gear.type === "shield" && !player.equipment.shield) player.equipment.shield = {...gear};
        else if (gear.type === "amulet" && !player.equipment.amulet) player.equipment.amulet = {...gear};
        else if (gear.type === "ring" && !player.equipment.ring) player.equipment.ring = {...gear};
        else if (gear.type === "cape" && !player.equipment.cape) player.equipment.cape = {...gear};
        else if (gear.type === "boots" && !player.equipment.boots) player.equipment.boots = {...gear};
        else player.bag.push({...gear});
      });
      
      // Show completion message
      inner.querySelector('.bag-title').textContent = "The Bag Opens...";
      inner.querySelector('.bag-desc').textContent = "A surge of energy bursts forth as you open the bag, revealing your starting gear!";
      inner.querySelector('.bag-warning').textContent = "";
      inner.querySelector('.bag-icon').textContent = "‚ú®";
      inner.querySelector('.bag-details').textContent = ""; 
      inner.querySelector('.bag-open-btn').style.display = "none";
      inner.querySelector('.bag-close-btn').style.display = "";
      
      // Update all UI components
      if (typeof renderBagInv === "function") renderBagInv();
      if (typeof renderEquipment === "function") renderEquipment();
      if (typeof renderPlayerStats === "function") renderPlayerStats();
      if (typeof renderDerivedStats === "function") renderDerivedStats();
    };
    
    // Close logic
    inner.querySelector('.bag-close-btn').onclick = function() {
      ui.style.display = "none";
    };
    
    // Also close if user clicks outside the inner box
    ui.onclick = function(e) {
      if (e.target === ui) ui.style.display = "none";
    };
  }

  // Function to add mystery bag open button to inventory items
  function addMysteryBagOpenButton() {
    const content = document.getElementById('baginv-content');
    if (!content) return;
    
    let itemsArr = baginvTab === "inventory" ? player.inventory : player.bag;
    content.querySelectorAll('.item-card').forEach((card, idx) => {
      const item = itemsArr[idx];
      if (item && item.type === "mystery") {
        // Add Open button if not already present
        if (!card.querySelector('.mystery-bag-open-btn')) {
          const btn = document.createElement('button');
          btn.className = 'item-action-btn mystery-bag-open-btn';
          btn.textContent = 'Open';
          btn.style.background = '#ffba3a';
          btn.style.color = '#23252a';
          btn.style.fontWeight = 'bold';
          btn.style.marginTop = '6px';
          btn.style.border = 'none';
          btn.style.borderRadius = '4px';
          btn.style.padding = '4px 12px';
          btn.style.cursor = 'pointer';
          btn.onclick = function(e) {
            e.stopPropagation();
            showMysteryBagUI(item, idx, itemsArr);
          };
          card.appendChild(btn);
        }
      }
    });
  }

  // Function to show class-specific intro
  function showClassIntro(playerClass) {
    const introOverlay = document.getElementById('intro-overlay');
    const introTitle = document.getElementById('intro-title');
    const introStory = document.getElementById('intro-story');
    
    // Define class intro stories
    let classIntroStories = {
      melee: `
        <p style="color:#eee;line-height:1.6;margin-bottom:15px;">
          You are a <b>Melee Warrior</b>, forged in the fires of battle. Your sword and shield are your closest allies, and your armor bears the scars of countless fights. The world awaits your strength and courage.
        </p>
      `,
      ranger: `
        <p style="color:#eee;line-height:1.6;margin-bottom:15px;">
          You are a <b>Ranger</b>, swift and silent. Your bow finds its mark from the shadows, and your arrows never miss. The wilds are your home, and adventure calls you to explore the unknown.
        </p>
      `,
      mage: `
        <p style="color:#eee;line-height:1.6;margin-bottom:15px;">
          You are a <b>Mage</b>, student of the arcane. The mysteries of magic bend to your will, and your staff crackles with power. The world is full of secrets, and you are ready to uncover them.
        </p>
      `
    };
    
    // Set class-specific title
    switch (playerClass) {
      case 'melee':
        introTitle.textContent = "The Warrior's Calling";
        break;
      case 'ranger':
        introTitle.textContent = "The Hunter's Path";
        break;
      case 'mage':
        introTitle.textContent = "The Arcane Awakening";
        break;
      default:
        introTitle.textContent = "Fate's Awakening";
    }
    
    // Set comprehensive intro story
    let html = classIntroStories[playerClass] +
      `<p style="color:#eee;line-height:1.6;margin-bottom:15px;">
        In a world torn by ancient wars and forgotten magic, you awaken in the heart of the realm‚ÄîCentral Town. The lands around you are shrouded in mystery, with forests, mountains, deserts, and ruins waiting to be discovered. Towns bustle with life, each holding secrets, rare sellers, and unique events. Chests glimmer in hidden corners, promising gold and treasures to the bold.
      </p>
      <p style="color:#eee;line-height:1.6;margin-bottom:15px;">
        As you journey, you will face a host of enemies‚Äîfrom cunning goblins to legendary bosses. Equip powerful weapons, armor, rings, and more to survive. Manage your inventory and bag, deposit valuables in the bank, and seek out the shop for ever-changing wares. Special sellers in towns offer rare items for those who explore bravely.
      </p>
      <p style="color:#eee;line-height:1.6;margin-bottom:15px;">
        Harness the power of Prayer to deflect attacks or heal in battle. Visit the Prayer Altar to renew your strength. Level up, gain experience, and unlock the ancient set for unmatched power. Auto-explore the world, auto-attack foes, and shape your fate.
      </p>
      <p style="color:#eee;line-height:1.6;margin-bottom:15px;">
        <b style="color:#ffba3a;">Features:</b>
        <ul style="margin-left:18px;color:#ccc;">
          <li>18x18 grid map with towns, chests, and areas</li>
          <li>Dynamic inventory, bag, equipment, and bank system</li>
          <li>Shop with rotating items and full armor sets</li>
          <li>Special sellers in towns with rare items</li>
          <li>Prayer system: Deflect & Heal, with altar renewal</li>
          <li>Auto-explore and auto-attack options</li>
          <li>Ancient Boss with unique rewards and set bonuses</li>
          <li>Save/load your progress and upload custom music</li>
          <li>More to come!</li>
        </ul>
      </p>
      <p style="color:#ffba3a;line-height:1.6;font-weight:bold;text-align:center;">
        Your destiny awaits. Will you accept your fate and begin your Journey?
      </p>`;
    
    introStory.innerHTML = html;
    introOverlay.style.display = 'flex';
  }
</script>

<script>
  // Set initial display state - show main intro overlay on load
  window.addEventListener('DOMContentLoaded', function() {
    // Hide the old character select overlay since we have it integrated in main intro
    const oldCharSelect = document.getElementById('character-select-overlay');
    if (oldCharSelect) oldCharSelect.style.display = 'none';
    
    // Hide intro overlay initially
    const introOverlay = document.getElementById('intro-overlay');
    if (introOverlay) introOverlay.style.display = 'none';
    
    // Show main intro overlay
    const mainIntroOverlay = document.getElementById('main-intro-overlay');
    if (mainIntroOverlay) mainIntroOverlay.style.display = 'flex';
    
    // Hide game UI initially
    const mainContainer = document.getElementById('container');
    if (mainContainer) mainContainer.style.display = 'none';
    
    [
      'main-save-ui', 'explore-bar', 'direction-select-bar', 'prayer-panel', 'prayer-altar-panel', 'panel-locations-btn'
    ].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.style.display = 'none';
    });
  });
</script>

<style>
  /* Main intro overlay styles */
  .character-class:hover {
    background: rgba(58,58,94,0.9) !important;
    transform: translateY(-3px);
    box-shadow: 0 8px 25px rgba(255,186,58,0.3);
    border-color: rgba(255,186,58,0.5) !important;
  }
  
  .character-class.selected {
    border: 3px solid #ffba3a !important;
    background: rgba(58,58,94,0.9) !important;
    box-shadow: 0 0 20px rgba(255,186,58,0.4);
  }
  
  #username-input-field:focus {
    border-color: #ffba3a;
    box-shadow: 0 0 0 3px rgba(255,186,58,0.2);
  }
  
  #begin-legend-btn:hover {
    background: linear-gradient(135deg, #ff8f00 0%, #ffba3a 100%);
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(255,186,58,0.5);
  }
  
  #begin-legend-btn:active {
    transform: translateY(0);
  }
  
  #play-music-btn:hover, #load-music-btn:hover, #load-save-btn:hover, #stop-music-btn:hover {
    opacity: 0.9;
    transform: translateY(-1px);
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
  }
  
  #play-music-btn:disabled, #stop-music-btn:disabled {
    opacity: 0.5 !important;
    cursor: not-allowed !important;
    transform: none !important;
    box-shadow: none !important;
  }
  
  #play-music-btn:hover:not(:disabled) {
    background: #45a049;
  }
  
  #load-music-btn:hover {
    background: #1976d2;
  }
  
  #load-save-btn:hover {
    background: #7b1fa2;
  }
  
  #stop-music-btn:hover:not(:disabled) {
    background: #d32f2f;
  }
</style>

<div id="explore-bar">
<button id="explore-btn-top" onclick="startExplore()">Explore</button>
</div>
<div id="direction-select-bar">
<span style="color:#ffba3a;font-weight:bold;">Pick a direction:</span>
<button class="direction-btn" onclick="chooseExploreDir(0,-1)">North</button>
<button class="direction-btn" onclick="chooseExploreDir(1,0)">East</button>
<button class="direction-btn" onclick="chooseExploreDir(0,1)">South</button>
<button class="direction-btn" onclick="chooseExploreDir(-1,0)">West</button>
</div>
<div id="container">
<div id="left-col">
<div class="panel" id="player-stats">
<h2>Player Stats</h2>
<ul id="player-stats-ul"></ul>
</div>
<div class="panel" id="equipment">
<h2>Equipment</h2>
<div id="equipment-ui">
<div class="equipment-side left" id="equipment-slots-left"></div>
<div id="char-portrait-box">
<div id="char-portrait"></div>
</div>
<div class="equipment-side right" id="equipment-slots-right"></div>
</div>
<div id="equipment-legend"></div>
</div>
<div class="panel" id="baginv">
<div id="baginv-tabs">
<button class="baginv-tab active" id="tab-inventory" onclick="switchBagInv('inventory')">Inventory</button>
<button class="baginv-tab" id="tab-bag" onclick="switchBagInv('bag')">Bag</button>
</div>
<div id="baginv-content"></div>
</div>
<div class="panel" id="derived-stats">
<h2>Current Stats</h2>
<ul id="derived-stats-list"></ul>
</div>
<div class="panel" id="bank">
<button id="bank-open-btn" onclick="openBank()">Open Bank</button>
</div>
</div>
<div id="center-col">
<div id="enemy-encounter">
<div id="attack-label">ATTACK</div>
<div id="enemy-health-top">
<div id="enemy-hp-bar">
<div id="enemy-hp-bar-inner"></div>
<div id="enemy-hp-bar-text"></div>
</div>
</div>
<div id="enemy-image"></div>
<div id="enemy-name-label"></div>
<div id="enemy-controls">
<button class="enemy-action-btn" id="attack-enemy-btn" onclick="attackEnemy()">Attack</button>
<button class="enemy-action-btn" id="run-enemy-btn" onclick="runFromEnemy()">Run</button>
</div>
</div>
<div id="chest-encounter">
<h3>Chest Found!</h3>
<div class="chest-reward" id="chest-reward"></div>
<button class="chest-btn" onclick="closeChest()">Close</button>
</div>
</div>
<div id="right-col">
<div class="panel" id="map">
<div id="map-container">
<div id="map-index">
<div class="map-index-item"><span class="map-index-color" style="background:#e53935"></span>Central Town</div>
<div class="map-index-item"><span class="map-index-color" style="background:#3887e0"></span>Town</div>
<div class="map-index-item"><span class="map-index-color" style="background:#444"></span>Area (Undiscovered)</div>
<div class="map-index-item"><span class="map-index-color" style="background:#2e7d32"></span>Area (Discovered)</div>
<div class="map-index-item"><span class="map-index-color" style="background:#bfae44"></span>Chest</div>

</div>
<div id="game-map"></div>
<div id="map-controls">

</div>
</script>
<div id="map-area-label"></div>
</div>
</div>
<!-- SHOP PANEL OVERHAUL -->
<div class="panel" id="shop" style="margin-top:18px; position:relative; overflow:visible;">
  <!-- Shop Banner (shown by default) -->
  <div id="shop-banner" style="display:flex;flex-direction:column;align-items:center;justify-content:center;padding:32px 0;">
    <div style="font-size:2em;color:#ffba3a;font-weight:bold;margin-bottom:18px;">Welcome to the Shop</div>
    <button id="open-shop-btn" style="font-size:1.15em;background:#ffba3a;color:#23252a;border:none;border-radius:10px;padding:12px 38px;cursor:pointer;box-shadow:0 2px 14px #0006;font-weight:bold;letter-spacing:1.5px;transition:background 0.18s, color 0.18s;">Open Shop</button>
  </div>
  <!-- Curtain effect overlay (horizontal animation) -->
  <div id="shop-curtain" style="display:none;position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(90deg,#23252a 80%,#ffba3a 100%);z-index:100;pointer-events:none;opacity:1;transition:opacity 1.1s cubic-bezier(.59,.22,.44,1.36);"></div>
  <!-- Shop Items List (hidden by default) -->
  <div id="shop-items-list" style="margin-top:12px;display:none;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:18px;">
    <!-- Shop items will be rendered here -->
  </div>
  <div id="shop-controls" style="display:none;margin-top:12px;">
    <button id="refresh-shop-btn" style="font-size:1em;background:#35373e;color:#ffba3a;border:none;border-radius:6px;padding:6px 18px;cursor:pointer;box-shadow:0 2px 8px #0004;">Refresh</button>
  </div>
  <style>
    #shop {
      position: relative;
    }
    #shop-curtain {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(90deg,#23252a 80%,#ffba3a 100%);
      z-index: 100;
      pointer-events: none;
      opacity: 1;
      transition: opacity 1.1s cubic-bezier(.59,.22,.44,1.36);
      /* For horizontal effect, animate transform: translateX */
      transform: translateX(0);
    }
  </style>
  <script>
    // Shop open logic with horizontal curtain effect
    const shopBanner = document.getElementById('shop-banner');
    const shopCurtain = document.getElementById('shop-curtain');
    const shopItemsList = document.getElementById('shop-items-list');
    const shopControls = document.getElementById('shop-controls');
    const openShopBtn = document.getElementById('open-shop-btn');
    const DATE_PASSWORD = "legend2025";
    openShopBtn.onclick = function() {
      shopCurtain.style.display = 'block';
      shopCurtain.style.opacity = '1';
      shopCurtain.style.transform = 'translateX(0)';
      // Animate curtain sliding to the right (horizontal)
      const anim = shopCurtain.animate([
        { opacity: 1, transform: 'translateX(0)' },
        { opacity: 1, transform: 'translateX(0)' },
        { opacity: 0, transform: 'translateX(100%)' }
      ], {
        duration: 1100,
        easing: 'cubic-bezier(.59,.22,.44,1.36)',
        fill: 'forwards'
      });
      anim.onfinish = function() {
        shopCurtain.style.display = 'none';
        shopBanner.style.display = 'none';
        shopItemsList.style.display = 'grid';
        shopControls.style.display = 'block';
        shopCurtain.style.transform = 'translateX(0)';
      };
    };
  </script>
</div>
<div class="panel" id="log-panel" style="grid-column:1/4;max-width:none;width:100%;margin-top:0;">
  <div id="game-log"></div>
</div>
</div>
</div>
<div id="bank-modal-bg" style="display:none;position:fixed;z-index:1200;top:0;left:0;width:100vw;height:100vh;background:#18191cbb;align-items:center;justify-content:center;">
  <div id="bank" style="background:#23252a;border-radius:18px;box-shadow:0 0 44px #000c,0 5px 32px #2b2a2a45;padding:32px 29px 24px 29px;min-width:450px;min-height:320px;position:relative;z-index:1211;display:flex;flex-direction:column;">
    <button id="bank-close-btn" onclick="closeBank()" style="position:absolute;top:12px;right:16px;font-size:1.38em;background:none;border:none;color:#fff;cursor:pointer;">√ó</button>
    <div id="bank-content" style="display:flex;flex-direction:column;gap:18px;margin-top:14px;justify-content:center;align-items:flex-start;">
      <!-- Bank Gold and Deposit section (top row) -->
      <div style="display:flex;align-items:center;gap:18px;">
        <div style="font-weight:bold;color:#ffba3a;">Bank Gold: <span id="bank-gold-label"></span></div>
        <div>
          <input type="number" id="deposit-gold-amount" min="1" placeholder="Gold to deposit" style="width:120px;padding:4px 8px;border-radius:5px;border:1px solid #444;background:#18191c;color:#fff;">
          <button id="deposit-gold-btn" style="background:#ffba3a;color:#23252a;border:none;border-radius:6px;padding:6px 18px;font-weight:bold;cursor:pointer;">Deposit Gold</button>
        </div>
        <div>
          <input type="number" id="withdraw-gold-amount" min="1" placeholder="Gold to withdraw" style="width:120px;padding:4px 8px;border-radius:5px;border:1px solid #444;background:#18191c;color:#fff;">
          <button id="withdraw-gold-btn" style="background:#35373e;color:#ffba3a;border:none;border-radius:6px;padding:6px 18px;font-weight:bold;cursor:pointer;">Withdraw Gold</button>
        </div>
      </div>
      <!-- Inventory/Bag section (below bank gold/deposit) -->
      <div class="bank-section">
        <div style="font-weight:bold;color:#ffba3a;margin-bottom:7px;">Inventory/Bag</div>
        <div class="bank-list" id="bank-inv-list"></div>
      </div>
      <div class="bank-section">
        <div style="font-weight:bold;color:#ffba3a;margin-bottom:7px;">Bank Items</div>
        <div class="bank-list" id="bank-list"></div>
      </div>
    </div>
    <script>
      function updateBankGoldLabels() {
        // Ensure bankGold is a valid number
        if (typeof player.bankGold !== 'number' || isNaN(player.bankGold)) {
          player.bankGold = 0;
        }
        document.getElementById('bank-gold-label').textContent = player.bankGold;
        renderPlayerStats();
      }
      document.getElementById('deposit-gold-btn').onclick = function() {
        const amt = parseInt(document.getElementById('deposit-gold-amount').value, 10);
        if (isNaN(amt) || amt <= 0) {
          alert('Enter a valid amount.');
          return;
        }
        if (player.gold < amt) {
          alert('Not enough gold to deposit.');
          return;
        }
        // Ensure bankGold is a number before operation
        if (typeof player.bankGold !== 'number' || isNaN(player.bankGold)) {
          player.bankGold = 0;
        }
        player.gold -= amt;
        player.bankGold += amt;
        updateBankGoldLabels();
        logMsg(`Deposited ${amt} gold to the bank.`);
        document.getElementById('deposit-gold-amount').value = '';
      };
      document.getElementById('withdraw-gold-btn').onclick = function() {
        const amt = parseInt(document.getElementById('withdraw-gold-amount').value, 10);
        if (isNaN(amt) || amt <= 0) {
          alert('Enter a valid amount.');
          return;
        }
        // Ensure bankGold is a number before operation
        if (typeof player.bankGold !== 'number' || isNaN(player.bankGold)) {
          player.bankGold = 0;
        }
        // Track failed withdrawal attempts
        if (!window._bankFailedAttempts) window._bankFailedAttempts = 0;
        if (!window._bankPenalty) window._bankPenalty = 10;
        if (!window._bankLockedUntil) window._bankLockedUntil = null;
        if (!window._bankLockedUser) window._bankLockedUser = null;

        // Bank lock logic: check both time and username
        if (
          window._bankLockedUntil &&
          Date.now() < window._bankLockedUntil &&
          window._bankLockedUser &&
          player.name === window._bankLockedUser
        ) {
          showBankLockedPopup();
          return;
        }

        if (player.bankGold < amt) {
          window._bankFailedAttempts++;
          let penalty = 0;
          if (window._bankFailedAttempts === 3) {
            penalty = 10;
            window._bankPenalty = 20;
            player.gold = Math.max(0, player.gold - penalty);
            alert(`The banker got fed up with you and took ${penalty} gold from your pocket!`);
            logMsg(`<span style="color:#ff4444;">The banker got fed up and took ${penalty} gold from you!</span>`);
            renderPlayerStats();
          } else if (window._bankFailedAttempts === 4) {
            penalty = 20;
            window._bankPenalty = 30;
            player.gold = Math.max(0, player.gold - penalty);
            alert(`The banker is furious and takes ${penalty} gold from you!`);
            logMsg(`<span style="color:#ff4444;">The banker is furious and takes ${penalty} gold from you!</span>`);
            renderPlayerStats();
          } else if (window._bankFailedAttempts === 5) {
            penalty = 30;
            player.gold = Math.max(0, player.gold - penalty);
            alert(`The banker shouts "Get lost, ${player.name}!" and takes ${penalty} gold. He slams the door in your face. The bank is now closed for 24 hours.`);
            logMsg(`<span style="color:#ff4444;">The banker shouts "Get lost, ${player.name}!" and takes ${penalty} gold. The bank is closed for 24 hours.</span>`);
            renderPlayerStats();
            // Lock the bank for 24 hours (in ms) and remember the user
            window._bankLockedUntil = Date.now() + 24 * 60 * 60 * 1000;
            window._bankLockedUser = player.name;
            window._bankFailedAttempts = 0;
            window._bankPenalty = 10;
            showBankLockedPopup();
          } else {
            alert('The bank keeper gives you a stern look: "This isn\'t free money, fool. Try to steal from me again and you\'ll regret it."');
          }
          return;
        } else {
          window._bankFailedAttempts = 0; // Reset on successful withdrawal
          window._bankPenalty = 10;
        }
        player.bankGold -= amt;
        player.gold += amt;
        updateBankGoldLabels();
        logMsg(`Withdrew ${amt} gold from the bank.`);
        document.getElementById('withdraw-gold-amount').value = '';

        // Helper: show bank locked popup with countdown and username
        function showBankLockedPopup() {
          let oldPopup = document.getElementById('bank-locked-popup');
          if (oldPopup) oldPopup.remove();
          const popup = document.createElement('div');
          popup.id = 'bank-locked-popup';
          popup.style = 'position:fixed;z-index:9999;top:0;left:0;width:100vw;height:100vh;background:#191a1ecc;display:flex;align-items:center;justify-content:center;';
          let remaining = Math.max(0, window._bankLockedUntil - Date.now());
          let hours = Math.floor(remaining / (1000 * 60 * 60));
          let mins = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
          let secs = Math.floor((remaining % (1000 * 60)) / 1000);
          popup.innerHTML = `
            <div style="background:#23252a;padding:38px 44px 32px 44px;border-radius:18px;box-shadow:0 2px 24px #000a;display:flex;flex-direction:column;align-items:center;min-width:340px;">
              <div style="color:#ff4444;font-size:1.5em;margin-bottom:18px;">Bank Closed!</div>
              <div style="margin-bottom:18px;color:#ffd36b;font-size:1.1em;">
          <b>The banker has locked the doors for 24 hours.</b><br>
          <span style="color:#ffba3a;">${window._bankLockedUser ? `Sorry ${window._bankLockedUser}, you are not welcome right now.` : ""}</span><br>
          Try again later.<br>
          <span style="color:#ffba3a;">Time remaining:</span>
          <span id="bank-locked-countdown" style="color:#ff4444;font-weight:bold;">${hours.toString().padStart(2,'0')}:${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}</span>
              </div>
              <button onclick="document.getElementById('bank-locked-popup').remove()" style="font-size:1.1em;font-weight:bold;background:#ff4444;color:#fff;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">OK</button>
            </div>
          `;
          document.body.appendChild(popup);

          // Countdown timer
          let interval = setInterval(() => {
            let remaining = Math.max(0, window._bankLockedUntil - Date.now());
            let hours = Math.floor(remaining / (1000 * 60 * 60));
            let mins = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
            let secs = Math.floor((remaining % (1000 * 60)) / 1000);
            let label = document.getElementById('bank-locked-countdown');
            if (label) {
              label.textContent = `${hours.toString().padStart(2,'0')}:${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}`;
            }
            if (remaining <= 0) {
              clearInterval(interval);
              window._bankLockedUntil = null;
              window._bankLockedUser = null;
              let popup = document.getElementById('bank-locked-popup');
              if (popup) popup.remove();
            }
          }, 1000);
        }

        // Patch openBank to show locked popup if bank is locked for this user
        window._origOpenBank = window._origOpenBank || openBank;
        openBank = function() {
          if (
            window._bankLockedUntil &&
            Date.now() < window._bankLockedUntil &&
            window._bankLockedUser &&
            player.name === window._bankLockedUser
          ) {
            showBankLockedPopup();
            return;
          }
          window._origOpenBank();
        }
      };
    </script>
  </div>
</div>
    </script>
  </div>
</div>
</script>
</div>
</div>
</div>
</div>
<script>
const itemIcons = {};
let player = {
  name: "Hero",
  health: 100,
  maxHealth: 100,
  gold: 1000,
  experience: 0,
  level: 1,
  bankGold: 0,
  inventory: [
    { name: "Potion", type: "potion", heal: 50, count: 10 },
    { name: "Arrows", type: "arrows", count: 100 }
   
  ],
  bag: [],
  equipment: {
    helmet: null,
    weapon: null,
    armor: null,
    ring: null,
    arrows: null,
    cloak: null,
    shield: null,
    amulet: null,
    gloves: null,
    boots: null
  },
  bank: []
};
// Equipment slot order for UI
const equipmentOrderLeft = [
  {slot: "helmet", label: "Helmet"},
  {slot: "weapon", label: "Weapon"},
  {slot: "armor", label: "Armor"},
  {slot: "ring", label: "Ring"},
  {slot: "arrows", label: "Arrows"}
];
const equipmentOrderRight = [
  {slot: "cloak", label: "Cloak"},
  {slot: "shield", label: "Shield"},
  {slot: "amulet", label: "Amulet"},
  {slot: "gloves", label: "Gloves"},
  {slot: "boots", label: "Boots"}
];
let areaNames = [
  "Plains", "Forest", "Mountain", "River", "Ruins", "Cave", "Desert", "Swamp", "Valley", "Hills"
];
let mapSize = 18;
let mapData = [];
let discovered = [];
let towns = [];
let chests = [];
let playerPosition = { x: Math.floor(mapSize/2), y: Math.floor(mapSize/2) };
let enemyIcons = {};
const enemyPool = [
  { name: "Slime", maxHealth: 40, minAttack: 4, maxAttack: 9, xp: 15 },
  { name: "Goblin", maxHealth: 55, minAttack: 7, maxAttack: 14, xp: 22 },
  { name: "Wolf", maxHealth: 65, minAttack: 10, maxAttack: 19, xp: 29 },
  { name: "Bandit", maxHealth: 80, minAttack: 14, maxAttack: 23, xp: 40 },
  { name: "Orc", maxHealth: 120, minAttack: 18, maxAttack: 29, xp: 60 },
  { name: "Dark Knight", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
  { name: "Fire Elemental", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
  { name: "Stone Golem", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
  { name: "Vampire Lord", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
  { name: "Frost Giant", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
  { name: "Shadow Assassin", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
  { name: "Ancient Dragon", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
  { name: "Lich King", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
  { name: "Forest Guardian", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
  { name: "Thunder Beast", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
  { name: "Skeleton Warrior", maxHealth: 70, minAttack: 12, maxAttack: 20, xp: 32 },
  { name: "Zombie", maxHealth: 90, minAttack: 10, maxAttack: 18, xp: 28 },
  { name: "Harpy", maxHealth: 60, minAttack: 15, maxAttack: 22, xp: 35 },
  { name: "Troll", maxHealth: 140, minAttack: 20, maxAttack: 32, xp: 55 },
  { name: "Sand Wraith", maxHealth: 85, minAttack: 17, maxAttack: 25, xp: 38 },
  { name: "Cursed Knight", maxHealth: 130, minAttack: 25, maxAttack: 36, xp: 65 },
  { name: "Giant Spider", maxHealth: 75, minAttack: 13, maxAttack: 21, xp: 30 },
  { name: "Dire Bear", maxHealth: 110, minAttack: 18, maxAttack: 28, xp: 48 },
  { name: "Crystal Serpent", maxHealth: 100, minAttack: 22, maxAttack: 33, xp: 52 },
  { name: "Wraith", maxHealth: 95, minAttack: 19, maxAttack: 27, xp: 44 }
];
// --- Ancient Boss Logic ---
const ancientBossData = {
  name: "Ancient Boss",
  maxHealth: 600,
  minAttack: 40,
  maxAttack: 70,
  xp: 1000
};
let ancientBossActive = false;
let ancientBossShopLocked = false; // Track if shop should be locked due to boss

// Track if the 1-hit kill sword has been used on the boss in this encounter
let ancientBossFirstHit = false;

if (!document.getElementById('ancient-boss-popup')) {
  const bossPopup = document.createElement('div');
  bossPopup.id = 'ancient-boss-popup';
  bossPopup.style = 'display:none;position:fixed;z-index:5000;top:0;left:0;width:100vw;height:100vh;background:#191a1ecc;align-items:center;justify-content:center;';
  bossPopup.innerHTML = `
    <div style="background:linear-gradient(135deg,#23252a 80%,#e53935 100%);padding:48px 54px 38px 54px;border-radius:28px;box-shadow:0 4px 32px #e5393588,0 2px 24px #000a;display:flex;flex-direction:column;align-items:center;min-width:380px;position:relative;">
      <div style="position:absolute;top:-32px;left:50%;transform:translateX(-50%);font-size:3.2em;color:#e53935;text-shadow:0 2px 12px #000a,0 0 8px #ffba3a88;">üëë</div>
      <div style="color:#ffba3a;font-size:1.7em;font-weight:bold;margin-bottom:18px;text-shadow:0 2px 8px #23252a88,0 0 4px #fff;">ANCIENT BOSS ENCOUNTER!</div>
      <div style="margin-bottom:18px;font-size:1.15em;color:#fff;text-align:center;">
        <span style="color:#e53935;font-weight:bold;">A legendary foe blocks your path!</span><br>
        <span style="color:#ffba3a;">Defeat the Ancient Boss for:</span><br>
        <span style="color:gold;font-weight:bold;">Ancient Sword</span> <span style="font-size:1.2em;">‚öîÔ∏è</span> <span style="color:#90ee90;">Ancient Armor Set</span> <span style="font-size:1.2em;">üõ°Ô∏è</span><br>
        
      </div>
      <div style="margin-bottom:18px;">
        <span style="color:#fff;">Will you risk it all for glory and treasure?</span>
      </div>
      <div style="display:flex;gap:18px;">
        <button id="ancient-boss-fight" style="font-size:1.15em;font-weight:bold;background:linear-gradient(90deg,#e53935 70%,#ffba3a 100%);color:#23252a;border:none;border-radius:9px;padding:10px 38px;cursor:pointer;box-shadow:0 2px 14px #e5393588;transition:background 0.18s, color 0.18s;">Fight</button>
        <button id="ancient-boss-run" style="font-size:1.15em;font-weight:bold;background:#35373e;color:#ffba3a;border:none;border-radius:9px;padding:10px 38px;cursor:pointer;box-shadow:0 2px 14px #0006;transition:background 0.18s, color 0.18s;">Run</button>
      </div>
      <div style="margin-top:22px;font-size:0.98em;color:#aaa;text-align:center;">
        <span style="color:#ffd36b;">Tip:</span> Running has a <b>60%</b> chance to succeed.<br>
        If you fail, the boss will strike you for <span style="color:#e53935;font-weight:bold;">25% of your max HP!</span>
      </div>
    </div>
  `;
  document.body.appendChild(bossPopup);
}

document.getElementById('ancient-boss-fight').onclick = function() {
  document.getElementById('ancient-boss-popup').style.display = 'none';
  showAncientBoss();
  ancientBossShopLocked = true;
  showShopClosedOverlay && showShopClosedOverlay();
};
// --- PATCH: Ancient Boss Run Option with Chance to Fail ---
document.getElementById('ancient-boss-run').onclick = function() {
  document.getElementById('ancient-boss-popup').style.display = 'none';
  // 60% chance to successfully run, 40% chance to fail
  if (Math.random() < 0.6) {
    logMsg('You successfully ran away from the Ancient Boss!');
    ancientBossActive = false;
    ancientBossShopLocked = false;
    hideShopClosedOverlay && hideShopClosedOverlay();
  } else {
    // Fail: Boss hits player for 25% of their max health
    let damage = Math.floor(getTotalMaxHealth() * 0.25);
    player.health = Math.max(0, player.health - damage);
    logMsg(`<span style="color:#e53935;font-weight:bold;">Failed to run! The Ancient Boss hits you for <b>${damage}</b>!</span>`);
    renderPlayerStats();
    if (player.health <= 0) {
      logMsg(`<span style="color:#f44;font-weight:bold;">You died! Respawning at town...</span>`);
      respawnPlayer();
      ancientBossActive = false;
      ancientBossShopLocked = false;
      hideShopClosedOverlay && hideShopClosedOverlay();
    } else {
      // Player failed to run but is still alive, keep boss active and shop locked
      ancientBossActive = true;
      ancientBossShopLocked = true;
      showShopClosedOverlay && showShopClosedOverlay();
    }
  }
};

const origShowEnemy = typeof showEnemy === "function" ? showEnemy : null;
function maybeAncientBossEncounter() {
  // Prevent boss encounter if already in combat, boss is active, or tunnel popup is open
  if (inCombat || ancientBossActive || document.getElementById('secret-tunnel-popup')) return false;
  if (Math.random() < 0.15) {
    ancientBossActive = true;
    ancientBossShopLocked = true;
    showShopClosedOverlay && showShopClosedOverlay();
    document.getElementById('ancient-boss-popup').style.display = 'flex';
    return true;
  }
  return false;
}
function showAncientBoss() {
  currentEnemy = {
    name: ancientBossData.name,
    health: ancientBossData.maxHealth,
    maxHealth: ancientBossData.maxHealth,
    minAttack: ancientBossData.minAttack,
    maxAttack: ancientBossData.maxAttack,
    xp: ancientBossData.xp,
    isBoss: true
  };
  inCombat = true;
  ancientBossFirstHit = false; // Reset first hit tracker for this encounter
  renderEnemyEncounter();
  logMsg(`<span style="color:#e53935;font-weight:bold;">A Special Boss has appeared!</span>`);
  ancientBossShopLocked = true;
  showShopClosedOverlay && showShopClosedOverlay();
}
function patchedRandomEncounter() {
  // Prevent any encounter if already in combat or boss is active
  if (inCombat || ancientBossActive) return;
  if (maybeAncientBossEncounter()) return;

  origShowEnemy && origShowEnemy();
}
// Replace showEnemy calls in movePlayer, doExplore, etc.
window.showEnemy = patchedRandomEncounter;

// --- Boss Drop Logic ---
function giveAncientBossRewards() {
  // Ancient Sword
  const ancientSword = {
    name: "Ancient Sword",
    type: "weapon",
    attackPower: 60,
    price: 0,
    description: "A sword only dropped by the Ancient Boss. +60 ATK, +150 HP",
    health: 150
  };
  addItem(ancientSword);

  // Ancient Armor Set: helmet, armor, boots, gloves, cloak
  const armorPieces = [
    { slot: "helmet", name: "Ancient Helmet" },
    { slot: "armor", name: "Ancient Armor" },
    { slot: "boots", name: "Ancient Boots" },
    { slot: "gloves", name: "Ancient Gloves" },
    { slot: "cloak", name: "Ancient Cloak" }
  ];
  armorPieces.forEach(piece => {
    addItem({
      name: piece.name,
      type: piece.slot,
      defense: randomStat(30, 60),
      health: 150,
      price: 0,
      description: `A ${piece.name} only dropped by the Ancient Boss. 0 - 150 HP, +${piece.slot === "armor" ? "60" : "30-60"} DEF`
    });
  });
  logMsg(`<span style="color:gold;font-weight:bold;">You defeated the Ancient Boss!<br>
    <span style="color:#ffba3a;">Ancient Sword</span> and <span style="color:#90ee90;">Ancient Armor Set</span> have been added to your inventory!</span>`);
  ancientBossShopLocked = false;
  hideShopClosedOverlay && hideShopClosedOverlay();
}

// --- Ancient Set Bonus Logic ---
function getAncientSetCount() {
  let count = 0;
  ["helmet", "armor", "boots", "gloves", "cloak"].forEach(slot => {
    const eq = player.equipment[slot];
    if (eq && eq.name && eq.name.startsWith("Ancient ")) count++;
  });
  return count;
}

// Patch getTotalDefense and getTotalMaxHealth for set bonus
const origGetTotalDefense = getTotalDefense;
getTotalDefense = function() {
  let base = origGetTotalDefense();
  let setCount = getAncientSetCount();
  if (setCount >= 2) base += 20; // 2+ pieces: +20 DEF
  if (setCount >= 4) base += 40; // 4+ pieces: +40 DEF
  if (setCount === 5) base += 60; // Full set: +60 DEF
  return base;
};
const origGetTotalMaxHealth = getTotalMaxHealth;
getTotalMaxHealth = function() {
  let base = origGetTotalMaxHealth();
  let setCount = getAncientSetCount();
  if (setCount >= 2) base += 50; // 2+ pieces: +50 HP
  if (setCount >= 4) base += 100; // 4+ pieces: +100 HP
  if (setCount === 5) base += 150; // Full set: +150 HP
  return base;
};

// Patch attackEnemy to handle boss death and rewards
window.attackEnemy = function() {
  if (!currentEnemy || !inCombat) {
    logMsg("No enemy to attack.");
    // If not in combat, ensure boss/shop flags are reset
    ancientBossActive = false;
    ancientBossShopLocked = false;
    hideShopClosedOverlay && hideShopClosedOverlay();
    return;
  }
  // Boss logic
  if (currentEnemy.isBoss) {
    // Check for 1-hit kill sword and first hit
    if (
      player.equipment.weapon &&
      player.equipment.weapon.name === "Debug 1-Hit Sword" &&
      !ancientBossFirstHit
    ) {
      let hit = 1000;
      currentEnemy.health = Math.max(0, currentEnemy.health - hit);
      showHitsplat(hit);
      logMsg(`<span style="color:#ff4444;font-weight:bold;">You unleash the Debug 1-Hit Sword! The Ancient Boss takes <b>${hit}</b> damage!</span>`);
      ancientBossFirstHit = true;
      renderEnemyEncounter();
      if (currentEnemy.health <= 0) {
        player.experience += currentEnemy.xp;
        checkLevelUp();
        giveAncientBossRewards();
        ancientBossActive = false;
        ancientBossShopLocked = false;
        clearEnemy();
        renderPlayerStats();
        hideShopClosedOverlay && hideShopClosedOverlay();
        return;
      }
      setTimeout(()=>{ enemyAttack(); }, 700);
      return;
    }
    let pAtk = (player.equipment.weapon ? player.equipment.weapon.attackPower||8 : 6)
      + (player.equipment.ring ? player.equipment.ring.attackPower||0 : 0);
    let hit = randomStat(30, 90);
    currentEnemy.health = Math.max(0, currentEnemy.health - hit);
    showHitsplat(hit);
    logMsg(`You hit the <b>${currentEnemy.name}</b> for <b>${hit}</b>!`);
    renderEnemyEncounter();
    if (currentEnemy.health <= 0) {
      player.experience += currentEnemy.xp;
      checkLevelUp();
      giveAncientBossRewards();
      ancientBossActive = false;
      ancientBossShopLocked = false;
      clearEnemy();
      renderPlayerStats();
      hideShopClosedOverlay && hideShopClosedOverlay();
      return;
    }
    setTimeout(()=>{ enemyAttack(); }, 700);
    return;
  }
  // Normal enemy
  origAttackEnemy && origAttackEnemy();
};


function randomStat(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
const items = [
  { name: 'Sword', price: 50, description: 'A basic sword for beginners.', type: 'weapon', attackPower: 15 },
  { name: 'Shield', price: 30, description: 'A sturdy shield for protection.', type: 'shield', defense: 20 },
  { name: 'Potion', price: 10, description: 'A basic healing potion.', type: 'potion', heal: 50 },
  { name: 'Advanced Sword', price: 100, description: 'A more powerful sword for experienced fighters.', type: 'weapon', attackPower: 25 },
  { name: 'Advanced Shield', price: 60, description: 'A stronger shield for better protection.', type: 'shield', defense: 30 },
  { name: 'Advanced Potion', price: 25, description: 'A potion that heals more health.', type: 'potion', heal: 50 },
  { name: 'Helmet', price: 40, description: 'A helmet to protect your head.', type: 'helmet', defense: 25, health: randomStat(30,100) },
  { name: 'Armor', price: 80, description: 'A set of armor for full body protection.', type: 'armor', defense: 40 },
  { name: 'Boots', price: 20, description: 'Boots to protect your feet.', type: 'boots', defense: 20, health: randomStat(20,100) },
  { name: 'Magic Wand', price: 120, description: 'A wand for casting powerful spells.', type: 'weapon', attackPower: 20 },
  { name: 'Bow', price: 70, description: 'A bow for ranged attacks.', type: 'weapon', attackPower: 18 },
  { name: 'Arrows', price: 15, description: 'A set of arrows for your bow.', type: 'arrows' },
  { name: 'Ring of Strength', price: 150, description: 'A ring that increases your strength.', type: 'ring', attackPower: 3, health: randomStat(10,100) },
  { name: 'Amulet of Health', price: 200, description: 'An amulet that increases your health.', type: 'amulet', defense: 10 },
  { name: 'Cloak of Invisibility', price: 300, description: 'A cloak that makes you invisible for a short time.', type: 'cloak', defense: 35, health: randomStat(25,100) },
  { name: 'Dagger', price: 45, description: 'A small, quick weapon for close combat.', type: 'weapon', attackPower: 15 },
  { name: 'Healing Herb', price: 5, description: 'A herb that heals minor wounds.', type: 'consumable', heal: 50 },
  { name: 'Mana Potion', price: 20, description: 'A potion that restores mana.', type: 'potion', heal: 50 },
  { name: 'Steel Boots', price: 35, description: 'Heavy boots for better protection.', type: 'boots', defense: 25, health: randomStat(30,100) },
  { name: 'Fire Staff', price: 150, description: 'A staff that casts fire spells.', type: 'weapon', attackPower: 22 },
  { name: 'Ice Amulet', price: 180, description: 'An amulet that grants resistance to ice.', type: 'amulet', defense: 15 },
  { name: 'Thunder Hammer', price: 250, description: 'A hammer that strikes with thunder.', type: 'weapon', attackPower: 30 },
  { name: 'Dragon Scale Armor', price: 500, description: 'Armor made from dragon scales.', type: 'armor', defense: 50 },
  { name: 'Phoenix Feather', price: 75, description: 'A rare feather with magical properties.', type: 'material' },
  { name: 'Elven Bow', price: 200, description: 'A bow crafted by elves.', type: 'weapon', attackPower: 25 },
  { name: 'Mystic Ring', price: 220, description: 'A ring that enhances magical abilities.', type: 'ring', attackPower: 2, health: randomStat(10,100) },
  { name: 'Warrior Helmet', price: 90, description: 'A helmet worn by warriors.', type: 'helmet', defense: 30, health: randomStat(40,100) },
  { name: 'Assassin Cloak', price: 250, description: 'A cloak that grants stealth.', type: 'cloak', defense: 35, health: randomStat(30,100) },
  { name: 'Knight Lance', price: 300, description: 'A lance used by knights.', type: 'weapon', attackPower: 28 },
  { name: 'Ranger Hat', price: 60, description: 'A hat worn by rangers.', type: 'helmet', defense: 20, health: randomStat(20,100) },
  { name: 'Mage Robe', price: 100, description: 'A robe worn by mages.', type: 'armor', defense: 25 },
  { name: 'Leather Gloves', price: 25, description: 'Gloves for better grip.', type: 'gloves', defense: 15, health: randomStat(30,100) }
];

let currentEnemy = null;
let inCombat = false;
let baginvTab = "inventory";
let searchTerm = "";
let chestReward = 0;
let chestOpen = false;
let exploreDir = null;

function getTotalDefense() {
  return (player.equipment.armor?.defense || 0)
    + (player.equipment.helmet?.defense || 0)
    + (player.equipment.shield?.defense || 0)
    + (player.equipment.cloak?.defense || 0)
    + (player.equipment.boots?.defense || 0)
    + (player.equipment.amulet?.defense || 0)
    + (player.equipment.gloves?.defense || 0);
}
function getTotalMaxHealth() {
  return player.maxHealth
    + (player.equipment.helmet?.health || 0)
    + (player.equipment.boots?.health || 0)
    + (player.equipment.cloak?.health || 0)
    + (player.equipment.ring?.health || 0)
    + (player.equipment.gloves?.health || 0);
}
function getTotalAttack() {
  return (player.equipment.weapon?.attackPower || 0)
    + (player.equipment.ring?.attackPower || 0);
}
function renderPlayerStats() {
  // Ensure bankGold is properly initialized
  if (typeof player.bankGold !== 'number' || isNaN(player.bankGold)) {
    player.bankGold = 0;
  }
  let classRow = player.class
    ? `<li class="class-li"><span class="player-class" style="color:#ffd36b;font-weight:bold;">Class:</span> ${player.class}</li>`
    : "";
  document.getElementById('player-stats-ul').innerHTML = `
    <li><span class="username">Name:</span> ${player.name || username || ''}</li>
    ${classRow}
    <li><span class="level">Level:</span> ${player.level}</li>
    <li><span class="health">Health:</span> ${player.health}/${getTotalMaxHealth()}</li>
    <li><span class="gold">Gold:</span> ${player.gold}</li>
    <li>Experience: ${player.experience}</li>
    <li>Bank Gold: ${player.bankGold}</li>
    <li><span class="defense" style="color:#90ee90;">Defense:</span> ${getTotalDefense()}</li>
    <li><span class="attack" style="color:#ffba3a;">Attack:</span> ${getTotalAttack()}</li>
  `;
}
function renderDerivedStats() {
  let atk = getTotalAttack();
  let def = getTotalDefense();
  let hp = getTotalMaxHealth();
  let stats = [
    `<li><span class="derived-label">Attack:</span> ${atk}</li>`,
    `<li><span class="derived-label">Defense:</span> ${def}</li>`,
    `<li><span class="derived-label">Max Health:</span> ${hp}</li>`
  ];
  document.getElementById('derived-stats-list').innerHTML = stats.join('');
}

// --- Secret Tunnel Encounter Logic ---
let movesSinceLastTunnel = 0;
let nextTunnelMove = Math.floor(Math.random() * 6) + 10; // 10-15 moves for first tunnel

function maybeShowSecretTunnel() {
  // Only trigger tunnel if not in combat, chest open, or popup already open
  if (inCombat || chestOpen || document.getElementById('secret-tunnel-popup')) return;
  movesSinceLastTunnel++;
  // Tunnel spawns every 10-15 moves since last tunnel
  if (movesSinceLastTunnel >= nextTunnelMove) {
    movesSinceLastTunnel = 0;
    nextTunnelMove = Math.floor(Math.random() * 6) + 10;
    showSecretTunnelPopup();
  }
}

function showSecretTunnelPopup() {
  let oldPopup = document.getElementById('secret-tunnel-popup');
  if (oldPopup) oldPopup.remove();
  const popup = document.createElement('div');
  popup.id = 'secret-tunnel-popup';
  popup.style = 'position:fixed;z-index:9999;top:0;left:0;width:100vw;height:100vh;background:#191a1ecc;display:flex;align-items:center;justify-content:center;';
  popup.innerHTML = `
    <div style="background:#23252a;padding:32px 38px 24px 38px;border-radius:18px;box-shadow:0 2px 24px #000a;display:flex;flex-direction:column;align-items:center;min-width:320px;">
      <div style="color:#ffd36b;font-size:1.3em;margin-bottom:18px;">Secret Tunnel Discovered!</div>
      <div style="margin-bottom:18px;color:#fff;">
        <b>Daring Risk:</b> Entering the tunnel is a gamble.<br>
        <span style="color:#ff4444;">50% chance</span> to face a mysterious enemy that can instantly kill you and steal your gold.<br>
        <span style="color:#ffd36b;">50% chance</span> to be chosen by the gods and receive a legendary reward!
      </div>
      <div style="margin-bottom:18px;color:#ffd36b;font-weight:bold;">Will you dare to enter?</div>
      <div style="display:flex;gap:18px;">
        <button id="secret-tunnel-enter" style="font-size:1.1em;font-weight:bold;background:#ffba3a;color:#23252a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">Enter</button>
        <button id="secret-tunnel-back" style="font-size:1.1em;font-weight:bold;background:#35373e;color:#ffba3a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">Go back</button>
      </div>
    </div>
  `;
  document.body.appendChild(popup);

  document.getElementById('secret-tunnel-back').onclick = function() {
    popup.remove();
    logMsg(`<span style="color:#ffd36b;">You decided not to enter the secret tunnel.</span>`);
  };
  document.getElementById('secret-tunnel-enter').onclick = function() {
    popup.remove();
    if (Math.random() < 0.5) {
      // Daring risk: mysterious enemy encounter (no popup, just instant effect)
      failSecretTunnelEncounter();
    } else {
      // Success: gods reward
      showSecretTunnelReward();
    }
  };
}
function failSecretTunnelEncounter() {
  // Set up the mysterious enemy
  currentEnemy = {
    name: "The Unknown",
    health: 9999,
    maxHealth: 9999,
    minAttack: 9999,
    maxAttack: 9999,
    xp: 0,
    isTunnelAmbush: true
  };
  inCombat = true;

  let oldPopup = document.getElementById('mysterious-enemy-popup');
  if (oldPopup) oldPopup.remove();
  const popup = document.createElement('div');
  popup.id = 'mysterious-enemy-popup';
  popup.style = 'position:fixed;z-index:10001;top:0;left:0;width:100vw;height:100vh;background:#191a1ecc;display:flex;align-items:center;justify-content:center;';
  popup.innerHTML = `
    <div style="background:linear-gradient(135deg,#23252a 80%,#000 100%);padding:44px 54px 38px 54px;border-radius:28px;box-shadow:0 4px 32px #000a,0 2px 24px #e5393588;display:flex;flex-direction:column;align-items:center;min-width:380px;position:relative;">
      <div style="font-size:3em;margin-bottom:12px;animation: menacingPulse 1.2s infinite alternate;">üï≥Ô∏è</div>
      <div style="color:#e53935;font-size:2.5em;font-weight:bold;margin-bottom:18px;text-shadow:0 2px 8px #23252a88,0 0 4px #fff;">The Unknown Awaits</div>
      <div style="margin-bottom:18px;font-size:1.15em;color:#fff;text-align:center;">
        <span style="color:#ffd36b;">You feel reality twist as a presence beyond comprehension emerges.</span><br>
        <span style="color:#ff4444;font-weight:bold;">There is no escape. Your fate is sealed.</span>
      </div>
      <div style="width:260px;margin-bottom:18px;">
        <div style="margin-bottom:8px;text-align:center;font-size:2em;color:#ffba3a;font-weight:bold;">The Unknown</div>
        <div style="display:flex;flex-direction:column;align-items:center;">
          <div style="width:180px;height:32px;background:#2d2222;border-radius:7px;position:relative;margin-bottom:8px;">
            <div style="background:linear-gradient(90deg,#ff6060 60%,#ffd700 100%);height:100%;width:100%;border-radius:7px;position:absolute;left:0;top:0;"></div>
            <div style="color:#fff;font-size:1.7em;position:absolute;width:100%;text-align:center;left:0;top:0;pointer-events:none;text-shadow:0 0 3px #000;">?????/?????</div>
          </div>
        </div>
      </div>
      <div style="display:flex;justify-content:center;width:100%;margin-bottom:18px;">
        <button id="tunnel-ambush-attack" style="font-size:1.2em;font-weight:bold;background:#e53935;color:#fff;border:none;border-radius:9px;padding:12px 48px;cursor:pointer;box-shadow:0 2px 14px #e5393588;">Confront the Unknown</button>
      </div>
      <div id="tunnel-ambush-result" style="margin-bottom:10px;color:#ffd36b;font-size:1.05em;"></div>
      <button id="tunnel-ambush-continue" style="display:none;font-size:1.1em;font-weight:bold;background:#e53935;color:#fff;border:none;border-radius:9px;padding:10px 38px;cursor:pointer;box-shadow:0 2px 14px #e5393588;">Continue</button>
      <style>
        @keyframes menacingPulse {
          0% { filter: drop-shadow(0 0 8px #e5393588); }
          100% { filter: drop-shadow(0 0 32px #000); }
        }
      </style>
    </div>
  `;
  document.body.appendChild(popup);

  // Attack button logic: instant kill and gold loss
  document.getElementById('tunnel-ambush-attack').onclick = function() {
    let lostGold = Math.floor(player.gold * 0.25);
    player.gold = Math.max(0, player.gold - lostGold);
    player.health = 0;
    document.getElementById('tunnel-ambush-result').innerHTML =
      `<span style="color:#ff4444;font-weight:bold;">You strike, but the void consumes you. Your existence is erased and <b>${lostGold}</b> gold vanishes into nothingness.</span>`;
    document.getElementById('tunnel-ambush-attack').style.display = 'none';
    document.getElementById('tunnel-ambush-continue').style.display = '';
    logMsg(`<span style="color:#ff4444;font-weight:bold;">The Unknown claims you. You are obliterated and lose <b>${lostGold}</b> gold!</span>`);
  };

  // Continue button logic: cleanup and respawn
  document.getElementById('tunnel-ambush-continue').onclick = function() {
    popup.remove();
    clearEnemy();
    respawnPlayer();
    renderPlayerStats();
    inCombat = false;
  };
}

// --- Secret Tunnel Reward ---
function showSecretTunnelReward() {
  // Award: 1000 gold + random item for class, stats x5, show original stats
  player.gold += 1000;
  let classKey = (player.class || "melee").toLowerCase();
  // Class-specific items from the enemy drop table
  let classItems = {
    melee: [
      { name: "Sword", type: "weapon", attackPower: 15, description: "A basic sword for beginners." },
      { name: "Shield", type: "shield", defense: 20, description: "A sturdy shield for protection." },
      { name: "Armor", type: "armor", defense: 40, description: "A set of armor for full body protection." },
      { name: "Helmet", type: "helmet", defense: 25, health: 30, description: "A helmet to protect your head." }
    ],
    ranger: [
      { name: "Bow", type: "weapon", attackPower: 18, isBow: true, description: "A bow for ranged attacks." },
      { name: "Arrows", type: "arrows", count: 100, description: "A set of arrows for your bow." },
      { name: "Cloak of Invisibility", type: "cloak", defense: 35, health: 25, description: "A cloak that makes you invisible for a short time." },
      { name: "Ranger Hat", type: "helmet", defense: 20, health: 20, description: "A hat worn by rangers." },
      { name: "Boots", type: "boots", defense: 20, health: 20, description: "Boots to protect your feet." }
    ],
    mage: [
      { name: "Magic Wand", type: "weapon", attackPower: 20, description: "A wand for casting powerful spells." },
      { name: "Mage Robe", type: "armor", defense: 25, description: "A robe worn by mages." },
      { name: "Amulet of Health", type: "amulet", defense: 10, description: "An amulet that increases your health." },
      { name: "Mystic Ring", type: "ring", attackPower: 2, health: 10, description: "A ring that enhances magical abilities." }
    ]
   };
  let pool = classItems[classKey] || classItems.melee;
  let rewardItem = JSON.parse(JSON.stringify(pool[Math.floor(Math.random() * pool.length)]));
  let originalStats = {};
  if (typeof rewardItem.attackPower === "number") originalStats.attackPower = rewardItem.attackPower;
  if (typeof rewardItem.defense === "number") originalStats.defense = rewardItem.defense;
  if (typeof rewardItem.health === "number") originalStats.health = rewardItem.health;
  // Enhance stats x5
  if (typeof rewardItem.attackPower === "number") rewardItem.attackPower *= 5;
  if (typeof rewardItem.defense === "number") rewardItem.defense *= 5;
  if (typeof rewardItem.health === "number") rewardItem.health *= 5;
  addItem(rewardItem);
  updateAllStats();

  let oldPopup = document.getElementById('secret-tunnel-reward-popup');
  if (oldPopup) oldPopup.remove();
  const popup = document.createElement('div');
  popup.id = 'secret-tunnel-reward-popup';
  popup.style = 'position:fixed;z-index:10000;top:0;left:0;width:100vw;height:100vh;background:#191a1ecc;display:flex;align-items:center;justify-content:center;';
  popup.innerHTML = `
    <div style="background:linear-gradient(135deg,#23252a 80%,#ffd700 100%);padding:44px 54px 38px 54px;border-radius:28px;box-shadow:0 4px 32px #ffd70088,0 2px 24px #000a;display:flex;flex-direction:column;align-items:center;min-width:380px;position:relative;">
      <div style="font-size:3em;margin-bottom:12px;animation: chestShine 1.2s infinite alternate;">ü™ô‚ú®</div>
      <div style="color:#ffd700;font-size:1.6em;font-weight:bold;margin-bottom:18px;text-shadow:0 2px 8px #23252a88,0 0 4px #fff;">Chosen by the Gods!</div>
      <div style="margin-bottom:18px;font-size:1.15em;color:#fff;text-align:center;">
        <span style="color:#ffd36b;">You bravely enter the tunnel and discover a <b>mysterious chest</b>!</span><br>
        <span style="color:gold;">Inside you find:</span><br>
        <span style="color:#ffe066;font-weight:bold;">${rewardItem.name}</span>
        <span style="color:#ffd36b;">(Enhanced x5!)</span><br>
        <span style="color:gold;font-size:1.2em;">+1000 Gold</span>
      </div>
      <div style="margin-bottom:10px;color:#ffd36b;font-size:1.05em;">
        <b>Original Stats:</b> ${Object.entries(originalStats).map(([k,v])=>k+':'+v).join(', ')}
      </div>
      <div style="margin-bottom:18px;color:#ffd700;font-size:1.05em;">
        <b>The gods have chosen your item and multiplied its stats by <span style="color:#ffba3a;">x5</span>!</b>
      </div>
      <button onclick="document.getElementById('secret-tunnel-reward-popup').remove()" style="font-size:1.1em;font-weight:bold;background:#ffba3a;color:#23252a;border:none;border-radius:9px;padding:10px 38px;cursor:pointer;box-shadow:0 2px 14px #ffd70088;transition:background 0.18s, color 0.18s;">Awesome!</button>
    </div>
    <style>
      @keyframes chestShine {
        0% { filter: drop-shadow(0 0 8px #ffd70088); }
        100% { filter: drop-shadow(0 0 32px #ffd700cc); }
      }
    </style>
  `;
  document.body.appendChild(popup);

  logMsg(`<span style="color:gold;font-weight:bold;">You bravely enter the tunnel and find a hidden chest!<br>Inside you find <b>${rewardItem.name}</b> and <b>1000 gold</b>!</span>`);
  logMsg(`<span style="color:gold;font-weight:bold;">${player.name} has obtained <b>${rewardItem.name}</b> (Original: ${Object.entries(originalStats).map(([k,v])=>k+':'+v).join(', ')})</span>`);
  logMsg(`<span style="color:#ffd700;font-weight:bold;">The gods have chosen your item and multiplied its stats by x5!</span>`);
}

function initMap() {
  mapData = [];
  discovered = [];
  towns = [];
  chests = [];
  tunnels = [];
  for (let y = 0; y < mapSize; ++y) {
    let row = [];
    let drow = [];
    for (let x = 0; x < mapSize; ++x) {
      // Assign random area name to each cell
      let areaIdx = Math.floor(Math.random() * areaNames.length);
      row.push({ type: "area", name: areaNames[areaIdx] });
      drow.push(false);
    }
    mapData.push(row);
    discovered.push(drow);
  }
  // Place main town in center
  let mid = Math.floor(mapSize/2);
  mapData[mid][mid] = { type: "central-town", name: "Central Town" };
  discovered[mid][mid] = true;
  towns.push({ x: mid, y: mid, name: "Central Town", central: true });
  // Place 10 more towns randomly
  let townNames = [
    "Oakvale", "Riverside", "Stonehill", "Windmere", "Goldport", "Ironforge", "Mistwood", "Sunvale", "Frostholm", "Shadowfen"
  ];
  for (let i = 0; i < 10; ++i) {
    let tx, ty;
    do {
      tx = Math.floor(Math.random()*mapSize);
      ty = Math.floor(Math.random()*mapSize);
    } while ((mapData[ty][tx].type !== "area") || (Math.abs(tx-mid)+Math.abs(ty-mid)<2));
    mapData[ty][tx] = { type: "town", name: townNames[i] };
    towns.push({ x: tx, y: ty, name: townNames[i], central: false });
  }
  // Place 8 chests randomly
  for (let i = 0; i < 8; ++i) {
    let cx, cy;
    do {
      cx = Math.floor(Math.random()*mapSize);
      cy = Math.floor(Math.random()*mapSize);
    } while (mapData[cy][cx].type !== "area");
    mapData[cy][cx] = { type: "chest", name: "Chest" };
    chests.push({ x: cx, y: cy });
  }
  // Place 3 tunnels randomly (you can adjust the number)
  for (let i = 0; i < 10; ++i) {
    let tx, ty;
    do {
      tx = Math.floor(Math.random()*mapSize);
      ty = Math.floor(Math.random()*mapSize);
    } while (mapData[ty][tx].type !== "area");
    mapData[ty][tx] = { type: "tunnel", name: "Secret Tunnel" };
    tunnels.push({ x: tx, y: ty });
  }
}
function renderMap() {
  const map = document.getElementById('game-map');
  map.innerHTML = "";
  for (let y = 0; y < mapSize; ++y) {
    for (let x = 0; x < mapSize; ++x) {
      let cellClass = "map-cell";
      let label = "";
      let cell = mapData[y][x];
      // Player
      if (x === playerPosition.x && y === playerPosition.y) {
        cellClass += " player";
      }
      // Central Town
      if (cell.type === "central-town") {
        cellClass += " central-town";
        label = "C";
      }
      // Other Towns
      else if (cell.type === "town") {
        cellClass += " town";
        if (visitedTowns[cell.name]) {
          label = "‚úî";
        } else {
          label = "T";
        }
      }
      // Chest
      else if (cell.type === "chest") {
        cellClass += " chest";
        label = "üí∞";
      }
      // Tunnel
      else if (cell.type === "tunnel") {
        cellClass += " tunnel";
        label = "üï≥Ô∏è";
      }
      // Area
      else if (cell.type === "area") {
        if (discovered[y][x]) {
          cellClass += " discovered";
          label = cell.name[0];
        } else {
          cellClass += " area";
          label = cell.name[0];
        }
      }
      // Discovered
      else if (cell.type === "discovered") {
        cellClass += " discovered";
        label = "";
      }
      // Undiscovered
      if (!discovered[y][x] && cell.type !== "central-town" && cell.type !== "town" && cell.type !== "chest" && cell.type !== "tunnel") {
        cellClass += " undiscovered";
        label = "";
      }
      // Show player icon
      if (x === playerPosition.x && y === playerPosition.y) {
        label = "üßë";
      }
      map.innerHTML += `<div class="${cellClass}" data-x="${x}" data-y="${y}" onclick="mapCellClick(${x},${y})" title="${cell.type === 'area' || cell.type === 'discovered' ? cell.name : cell.name || ''}">${label}</div>`;
    }
  }
  let areaLabel = "";
  let cell = mapData[playerPosition.y][playerPosition.x];
  if (cell.type === "central-town") areaLabel = "Area: Central Town";
  else if (cell.type === "town") areaLabel = "Area: " + cell.name;
  else if (cell.type === "chest") areaLabel = "Area: Chest";
  else if (cell.type === "tunnel") areaLabel = "Area: Secret Tunnel";
  else if (!discovered[playerPosition.y][playerPosition.x]) areaLabel = "Area: Not Discovered";
  else areaLabel = "Area: " + (cell.name || "Discovered");
  document.getElementById("map-area-label").textContent = areaLabel;
}

  // Patch movePlayer and doExplore to call maybeShowSecretTunnel
  function movePlayer(dx,dy) {
      if (inCombat || chestOpen) {
      logMsg('You cannot move while fighting or opening a chest!');
      return;
      }
      let nx = Math.max(0, Math.min(mapSize-1, playerPosition.x+dx));
      let ny = Math.max(0, Math.min(mapSize-1, playerPosition.y+dy));
      playerPosition.x = nx;
      playerPosition.y = ny;
      discovered[ny][nx] = true;
      renderMap();
      let cell = mapData[ny][nx];
      if (cell.type === "central-town") {
      logMsg(`Arrived at <b>Central Town</b>.`);
      } else if (cell.type === "town") {
      showTownPopup(cell.name);
      logMsg(`Arrived at town: <b>${cell.name}</b>.`);
      return; // Wait for popup interaction
      } else if (cell.type === "chest") {
      logMsg("You found a chest!");
      openChest();
      return;
      } else if (cell.type === "tunnel") {
      logMsg("You found a secret tunnel!");
      showSecretTunnelPopup();
      // Optionally, remove the tunnel after use:
      // mapData[ny][nx] = { type: "discovered", name: "" };
      // renderMap();
      return;
      } else if (!discovered[ny][nx]) {
      logMsg("You entered a not discovered area.");
      } else {
      logMsg("You entered: <b>" + (cell.name || "a discovered area") + "</b>.");
      }
      // Random town events
      if (cell.type === "town" && Math.random() < 0.5) {
      triggerRandomTownEvent();
      }
      // Random area events
      if (cell.type === "area" && discovered[ny][nx] && Math.random() < 0.15) {
      triggerRandomAreaEvent();
      }
      if (Math.random() < 0.18 && cell.type !== "central-town" && cell.type !== "town" && cell.type !== "chest" && cell.type !== "tunnel") {
      setTimeout(showEnemy, 350);
      }
      // Only call maybeShowSecretTunnel if not on a tunnel cell
      if (cell.type !== "tunnel") {
        maybeShowSecretTunnel();
      }
  }
  
  function startExplore() {
    if (inCombat || chestOpen) {
    logMsg("Finish your battle or chest first!");
    return;
    }
    document.getElementById('direction-select-bar').classList.add('active');
    // Hide shop if enemy is found during explore (handled in doExplore)
  }
  function chooseExploreDir(dx, dy) {
    document.getElementById('direction-select-bar').classList.remove('active');
    exploreDir = {dx, dy};
    doExplore();
  }

// --- SHOP CLOSED DURING COMBAT LOGIC ---
function showShopClosedOverlay() {
  let overlay = document.getElementById('shop-closed-overlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'shop-closed-overlay';
    overlay.style = `
      position:absolute;
      top:0;left:0;width:100%;height:100%;
      background:rgba(25,26,30,0.92);
      z-index:200;
      display:flex;
      align-items:center;
      justify-content:center;
      flex-direction:column;
      pointer-events:auto;
    `;
    overlay.innerHTML = `
      <div style="position:relative;z-index:202;display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%;height:100%;">
      <div style="color:#ff4444;font-size:2em;font-weight:bold;text-shadow:0 2px 8px #000a;margin-bottom:10px;">Shop Locked!</div>
      <div style="color:#ffd36b;font-size:1.1em;margin-bottom:10px;">The Shop keep doesnt want any company!<br>Defeat the enemy or run away to reopen the shop.</div>
      <div style="font-size:2.5em;filter:grayscale(0.7);margin-bottom:8px;">üîí</div>
      </div>
    `;
    const shopPanel = document.getElementById('shop');
    if (shopPanel) {
      shopPanel.style.position = 'relative';
      shopPanel.appendChild(overlay);
    }
  } else {
    overlay.style.display = 'flex';
  }
}
function hideShopClosedOverlay() {
  let overlay = document.getElementById('shop-closed-overlay');
  if (overlay) overlay.style.display = 'none';
}

// Patch showEnemy to show shop closed overlay
const origShowEnemyForShop = typeof showEnemy === "function" ? showEnemy : null;
window.showEnemy = function() {
  showShopClosedOverlay();
  origShowEnemyForShop && origShowEnemyForShop();
};

// Patch clearEnemy to hide shop closed overlay
const origClearEnemyForShop = typeof clearEnemy === "function" ? clearEnemy : null;
window.clearEnemy = function() {
  hideShopClosedOverlay();
  origClearEnemyForShop && origClearEnemyForShop();
};

// Also hide overlay if player runs away or dies (runFromEnemy, respawnPlayer)
const origRunFromEnemyForShop = typeof runFromEnemy === "function" ? runFromEnemy : null;
window.runFromEnemy = function() {
  if (!currentEnemy || !inCombat) return;
  // 60% chance to run away
  if (Math.random() < 0.6) {
    logMsg(`<span style="color:#9cf">You ran away from the ${currentEnemy.name}!</span>`);
    clearEnemy();
    hideShopClosedOverlay();
  } else {
    logMsg(`<span style="color:#f77">You failed to run away!</span>`);
    setTimeout(enemyAttack, 500);
    // Keep overlay visible
  }
};
const origRespawnPlayerForShop = typeof respawnPlayer === "function" ? respawnPlayer : null;
window.respawnPlayer = function() {
  hideShopClosedOverlay();
  origRespawnPlayerForShop && origRespawnPlayerForShop();
};

(function() {
  // Remove old button if exists
  let oldBtn = document.getElementById('auto-explore-btn');
  if (oldBtn) oldBtn.remove();
  // Create button
  const btn = document.createElement('button');
  btn.id = 'auto-explore-btn';
  btn.textContent = 'Auto Explore';
  btn.style.fontWeight = 'bold';
  btn.style.fontSize = '1em';
  btn.style.background = '#ffba3a';
  btn.style.color = '#23252a';
  btn.style.border = 'none';
  btn.style.borderRadius = '12px';
  btn.style.padding = '14px 32px';
  btn.style.cursor = 'pointer';
  btn.style.marginLeft = '18px';
  btn.onclick = function() {
    showAutoExploreDirectionPopup();
  };
  // Insert beside Explore button
  const exploreBar = document.getElementById('explore-bar');
  if (exploreBar) {
    exploreBar.appendChild(btn);
  }
})();

let autoExploreActive = false;
let autoExploreDir = null;
let autoExploreTimer = null;
let autoExploreAutoAttack = false;

function showAutoExploreDirectionPopup() {
  // Remove old popup if exists
  let oldPopup = document.getElementById('auto-explore-dir-popup');
  if (oldPopup) oldPopup.remove();
  // Create popup
  const popup = document.createElement('div');
  popup.id = 'auto-explore-dir-popup';
  popup.style = 'position:fixed;z-index:9999;top:0;left:0;width:100vw;height:100vh;background:#191a1ecc;display:flex;align-items:center;justify-content:center;';
  popup.innerHTML = `
    <div style="background:#23252a;padding:32px 38px 24px 38px;border-radius:18px;box-shadow:0 2px 24px #000a;display:flex;flex-direction:column;align-items:center;">
      <div style="color:#ffba3a;font-size:1.2em;margin-bottom:18px;">Choose Auto Explore Direction</div>
      <label style="margin-bottom:14px;display:flex;align-items:center;gap:8px;">
        <input type="checkbox" id="auto-explore-auto-attack" style="width:18px;height:18px;">
        <span style="color:#ffba3a;font-weight:bold;">Auto Attack Enemies</span>
      </label>
      <div style="display:flex;gap:18px;margin-bottom:18px;">
        <button onclick="startAutoExplore(0,-1);closeAutoExploreDirPopup()" style="font-size:1.1em;background:#35373e;color:#ffba3a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">North</button>
        <button onclick="startAutoExplore(1,0);closeAutoExploreDirPopup()" style="font-size:1.1em;background:#35373e;color:#ffba3a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">East</button>
        <button onclick="startAutoExplore(0,1);closeAutoExploreDirPopup()" style="font-size:1.1em;background:#35373e;color:#ffba3a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">South</button>
        <button onclick="startAutoExplore(-1,0);closeAutoExploreDirPopup()" style="font-size:1.1em;background:#35373e;color:#ffba3a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">West</button>
      </div>
      <button onclick="closeAutoExploreDirPopup()" style="font-size:1em;background:#ff4444;color:#fff;border:none;border-radius:7px;padding:6px 24px;cursor:pointer;">Cancel</button>
    </div>
  `;
  document.body.appendChild(popup);
  // Restore last checkbox state
  setTimeout(() => {
    const cb = document.getElementById('auto-explore-auto-attack');
    if (cb) cb.checked = autoExploreAutoAttack;
    cb && cb.addEventListener('change', function() {
      autoExploreAutoAttack = cb.checked;
    });
  }, 50);
}
function closeAutoExploreDirPopup() {
  let popup = document.getElementById('auto-explore-dir-popup');
  if (popup) popup.remove();
}

function startAutoExplore(dx, dy) {
  autoExploreActive = true;
  autoExploreDir = {dx, dy};
  // Get checkbox value
  const cb = document.getElementById('auto-explore-auto-attack');
  autoExploreAutoAttack = cb ? cb.checked : autoExploreAutoAttack;
  updateAutoExploreBtn(true);
  autoExploreLoop();
}

function stopAutoExplore() {
  autoExploreActive = false;
  autoExploreDir = null;
  if (autoExploreTimer) clearTimeout(autoExploreTimer);
  updateAutoExploreBtn(false);
}

function updateAutoExploreBtn(active) {
  const btn = document.getElementById('auto-explore-btn');
  if (!btn) return;
  if (active) {
    btn.textContent = 'Stop Auto Explore';
    btn.style.background = '#ff4444';
    btn.style.color = '#fff';
    btn.onclick = stopAutoExplore;
  } else {
    btn.textContent = 'Auto Explore';
    btn.style.background = '#ffba3a';
    btn.style.color = '#23252a';
    btn.onclick = function() { showAutoExploreDirectionPopup(); };
  }
}

function autoExploreLoop() {
  if (!autoExploreActive || !autoExploreDir) return;
  // If in combat or chest open, wait and retry
  if (inCombat || chestOpen) {
    autoExploreTimer = setTimeout(autoExploreLoop, 1200);
    return;
  }
  // Try to move in direction
  let nx = Math.max(0, Math.min(mapSize-1, playerPosition.x+autoExploreDir.dx));
  let ny = Math.max(0, Math.min(mapSize-1, playerPosition.y+autoExploreDir.dy));
  // If can't move further, stop
  if (nx === playerPosition.x && ny === playerPosition.y) {
    stopAutoExplore();
    return;
  }
  playerPosition.x = nx;
  playerPosition.y = ny;
  discovered[ny][nx] = true;
  renderMap();
  let cell = mapData[ny][nx];
  // Interactions: only log and handle, do not stop auto-explore unless explicitly triggered
  if (cell.type === "central-town") {
    logMsg(`Arrived at <b>Central Town</b>.`);
    // Optionally, you can set a flag here if you want to stop auto-explore on central town
    // stopAutoExplore();
    // return;
  } else if (cell.type === "town") {
    showTownPopup(cell.name);
    logMsg(`Arrived at town: <b>${cell.name}</b>.`);
    // Optionally, you can set a flag here if you want to stop auto-explore on town
    // stopAutoExplore();
    // return;
  } else if (cell.type === "chest") {
    logMsg("You found a chest!");
    openChest();
    // Optionally, you can set a flag here if you want to stop auto-explore on chest
    // stopAutoExplore();
    // return;
  } else if (!discovered[ny][nx]) {
    logMsg("You entered a not discovered area.");
  } else {
    logMsg("You entered: <b>" + (cell.name || "a discovered area") + "</b>.");
  }
  // Random town events
  if (cell.type === "town" && Math.random() < 0.5) {
    triggerRandomTownEvent();
    // Optionally, you can set a flag here if you want to stop auto-explore on random town event
    // stopAutoExplore();
    // return;


  }
  // Enemy encounter: only stop if auto-attack is not enabled
  if (Math.random() < 0.22 && cell.type !== "central-town" && cell.type !== "town" && cell.type !== "chest") {
    setTimeout(() => {
      showEnemy();
      // If auto-attack is enabled, auto attack until enemy defeated or player dies
      if (autoExploreAutoAttack && currentEnemy && inCombat) {
        autoAttackActive = true;
        autoAttackLoopAutoExplore();
      }
      // else, do not stop auto-explore here; let user stop it manually if desired
    }, 350);
    return;
  }
  // Continue auto-explore after short delay
  autoExploreTimer = setTimeout(autoExploreLoop, 700);
}

// Auto-attack loop for auto-explore (does not stop auto-explore unless player dies or ancient boss)
function autoAttackLoopAutoExplore() {
  if (!autoAttackActive || !currentEnemy || !inCombat) {
    stopAutoExplore();
    return;
  }
  // If ancient boss, stop auto-explore and require manual input
  if (currentEnemy.isBoss) {
    stopAutoExplore();
    return;
  }
  // Only attack if enemy and player are alive
  if (currentEnemy.health > 0 && player.health > 0) {
    attackEnemy();
    setTimeout(() => {
      if (currentEnemy && currentEnemy.health > 0 && player.health > 0 && inCombat && autoAttackActive) {
        autoAttackLoopAutoExplore();
      } else {
        stopAutoExplore();
      }
    }, 900);
  } else {
    stopAutoExplore();
  }
}


function doExplore() {
  if (!exploreDir) return;
  let nx = Math.max(0, Math.min(mapSize-1, playerPosition.x+exploreDir.dx));
  let ny = Math.max(0, Math.min(mapSize-1, playerPosition.y+exploreDir.dy));
  playerPosition.x = nx;
  playerPosition.y = ny;
  discovered[ny][nx] = true;
  renderMap();
  let cell = mapData[ny][nx];
  if (cell.type === "central-town") {
    logMsg(`Arrived at <b>Central Town</b>.`);
  } else if (cell.type === "town") {
    showTownPopup(cell.name);
    logMsg(`Arrived at town: <b>${cell.name}</b>.`);
    exploreDir = null;
    return; // Wait for popup interaction
  } else if (cell.type === "chest") {
    logMsg("You found a chest!");
    openChest();
    return;
  } else if (!discovered[ny][nx]) {
    logMsg("You entered a not discovered area.");
  } else {
    logMsg("You entered: <b>" + (cell.name || "a discovered area") + "</b>.");
  }
  // Random town events
  if (cell.type === "town" && Math.random() < 0.5) {
    triggerRandomTownEvent();
  }
  // Random area events
  if (cell.type === "area" && discovered[ny][nx] && Math.random() < 0.15) {
    triggerRandomAreaEvent();
  }
  // Enemy encounter: show shop closed overlay if enemy found
  if (Math.random() < 0.22 && cell.type !== "central-town" && cell.type !== "town" && cell.type !== "chest") {
    setTimeout(() => {
      showShopClosedOverlay();
      showEnemy();
    }, 350);
  }
  // Check for secret tunnel after exploration movement
  maybeShowSecretTunnel();
  exploreDir = null;
}
// --- Add this after your renderDerivedStats function ---
function updateAllStats() {
  renderPlayerStats();
  renderDerivedStats();
  renderEquipment();
}
/*
  --- NO WEAPON EQUIPPED FUNCTIONALITY ---
  If the user has no weapon equipped, they still deal 1 damage per attack.
  The first time, show a menacing/devilish popup warning the user to equip a weapon,
  or else they will only deal 1 damage per attack until a weapon is equipped.
*/

// Track if the no-weapon popup has been shown in this session
let noWeaponPopupShown = false;

// Patch attackEnemy to handle no-weapon logic (separate from bow/arrows logic)
const origAttackEnemyNoWeapon = typeof attackEnemy === "function" ? attackEnemy : null;
window.attackEnemy = function() {
  // No weapon equipped logic (only if not a bow)
  if (!player.equipment.weapon) {
    // Show popup only the first time per session
    if (!noWeaponPopupShown) {
      showNoWeaponPopup();
      noWeaponPopupShown = true;
    }
    // Deal only 1 damage per attack
    if (!currentEnemy || !inCombat) {
      logMsg("No enemy to attack.");
      return;
    }
    currentEnemy.health = Math.max(0, currentEnemy.health - 1);
    showHitsplat(1);
    logMsg(`<span style="color:#ff4444;font-weight:bold;">You attack with your bare hands and deal <b>1</b> damage!</span>`);
    renderEnemyEncounter();
    if (currentEnemy.health <= 0) {
      let goldDrop = Math.floor(Math.random() * 51);
      player.gold += goldDrop;
      let randomItem = JSON.parse(JSON.stringify(items[Math.floor(Math.random() * items.length)]));
      addItem(randomItem);
      let goldMsg = goldDrop > 0 ? ` <span style="color:gold;">+${goldDrop} Gold</span>` : '';
      logMsg(`<span style="color:#90ee90"><b>You defeated the ${currentEnemy.name}!</b></span> +${currentEnemy.xp} XP${goldMsg} and found ${randomItem.name}`);
      player.experience += currentEnemy.xp;
      checkLevelUp();
      clearEnemy();
      renderPlayerStats();
      return;
    }
    setTimeout(()=>{ enemyAttack(); }, 700);
    return;
  }
  // Continue with normal attack logic
  origAttackEnemyNoWeapon && origAttackEnemyNoWeapon();
};

// Show popup if trying to attack with no weapon equipped
function showNoWeaponPopup() {
  // Remove old popup if exists
  let oldPopup = document.getElementById('no-weapon-popup');
  if (oldPopup) oldPopup.remove();
  // Add styles for devilish animation
  if (!document.getElementById('no-weapon-popup-style')) {
    const style = document.createElement('style');
    style.id = 'no-weapon-popup-style';
    style.textContent = `
      @keyframes devilPulseGlow {
        0% {
          text-shadow: 0 0 0px #e53935, 0 0 0px #ffd36b;
          transform: scale(1);
          opacity: 1;
        }
        50% {
          text-shadow: 0 0 32px #e53935, 0 0 48px #ffd36b;
          transform: scale(1.18) rotate(-3deg);
          opacity: 0.97;
        }
        100% {
          text-shadow: 0 0 0px #e53935, 0 0 0px #ffd36b;
          transform: scale(1);
          opacity: 1;
        }
      }
      #no-weapon-devil {
        animation: devilPulseGlow 1.3s infinite;
        display: inline-block;
        transition: transform 0.2s;
      }
    `;
    document.head.appendChild(style);
  }
  // Create popup
  const popup = document.createElement('div');
  popup.id = 'no-weapon-popup';
  popup.style = 'position:fixed;z-index:9999;top:0;left:0;width:100vw;height:100vh;background:#191a1ecc;display:flex;align-items:center;justify-content:center;';
  popup.innerHTML = `
    <div style="background:#23252a;padding:32px 38px 24px 38px;border-radius:18px;box-shadow:0 2px 24px #000a;display:flex;flex-direction:column;align-items:center;">
      <div id="no-weapon-devil" style="font-size:3em;margin-bottom:10px;">üëä</div>
      <div style="color:#e53935;font-size:1.25em;margin-bottom:12px;font-weight:bold;">No Weapon Equipped!</div>
      <div style="margin-bottom:12px;color:#ffd36b;"><br><b>You will only deal <span style="color:#e53935;">1</span> damage per attack</b> until you equip a weapon.</div>
      <div style="color:#fff;font-size:1.05em;margin-bottom:18px;text-align:center;">
        <b>The spirits mock your bare fists...<br>Equip a weapon to unleash your true power!</b>
      </div>
      <button id="no-weapon-ok" style="font-size:1.1em;font-weight:bold;background:#e53935;color:#fff;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">I Understand</button>
    </div>
  `;
  document.body.appendChild(popup);
  document.getElementById('no-weapon-ok').onclick = function() {
    popup.remove();
  };
}

/*
  --- BOW & ARROWS FUNCTIONALITY ---
  If the user has a bow equipped, they must also have arrows equipped to attack.
  If not, show a popup warning and prevent the attack.
  If bow and arrows are equipped, consume one arrow per attack.
*/

// Helper: check if equipped weapon is a bow
function isEquippedBow() {
  const weapon = player.equipment.weapon;
  return weapon && (weapon.isBow || (weapon.name && weapon.name.toLowerCase().includes('bow')));
}
// Helper: check if arrows are equipped and have count > 0
function hasEquippedArrows() {
  const arrows = player.equipment.arrows;
  return arrows && typeof arrows.count === "number" && arrows.count > 0;
}

// Failsafe: prevent repeated no-arrows popup during auto-attack
let noArrowsPopupActive = false;

// Patch attackEnemy to handle bow/arrows logic (separate from no-weapon logic)
const origAttackEnemyBow = window.attackEnemy;
window.attackEnemy = function() {
  // Bow logic: if equipped weapon is a bow, check for arrows
  if (isEquippedBow()) {
    if (!hasEquippedArrows()) {
      // Show popup: "You need arrows equipped to use a bow!"
      if (!noArrowsPopupActive) showNoArrowsPopup();
      // If auto-attack is running, stop it
      if (typeof autoAttackActive !== "undefined" && autoAttackActive) stopAutoAttack && stopAutoAttack();
      return;
    }
    // If bow and arrows equipped, consume one arrow per attack
    player.equipment.arrows.count -= 1;
    logMsg(`<span style="color:#ffba3a;">Used 1 arrow. ${player.equipment.arrows.count > 0 ? `Arrows left: ${player.equipment.arrows.count}` : "No arrows left!"}</span>`);
    if (player.equipment.arrows.count <= 0) {
      logMsg(`<span style="color:#f44;font-weight:bold;">You have run out of arrows!</span>`);
      player.equipment.arrows = null;
    }
    updateAllStats();
    renderBagInv();
  }
  // Continue with normal attack logic
  origAttackEnemyBow && origAttackEnemyBow.apply(this, arguments);
};

// Show popup if trying to attack with bow but no arrows equipped
function showNoArrowsPopup() {
  // Remove old popup if exists
  let oldPopup = document.getElementById('no-arrows-popup');
  if (oldPopup) oldPopup.remove();
  noArrowsPopupActive = true;
  // Add styles for pulsate, glow, and grow
  if (!document.getElementById('no-arrows-popup-style')) {
    const style = document.createElement('style');
    style.id = 'no-arrows-popup-style';
    style.textContent = `
      @keyframes cautionPulseGlow {
        0% {
          text-shadow: 0 0 0px #ffba3a, 0 0 0px #ffd36b;
          transform: scale(1);
          opacity: 1;
        }
        50% {
          text-shadow: 0 0 24px #ffba3a, 0 0 48px #ffd36b;
          transform: scale(1.25);
          opacity: 0.93;
        }
        100% {
          text-shadow: 0 0 0px #ffba3a, 0 0 0px #ffd36b;
          transform: scale(1);
          opacity: 1;
        }
      }
      #no-arrows-caution {
        animation: cautionPulseGlow 1.2s infinite;
        display: inline-block;
        transition: transform 0.2s;
      }
    `;
    document.head.appendChild(style);
  }
  // Create popup
  const popup = document.createElement('div');
  popup.id = 'no-arrows-popup';
  popup.style = 'position:fixed;z-index:9999;top:0;left:0;width:100vw;height:100vh;background:#191a1ecc;display:flex;align-items:center;justify-content:center;';
  popup.innerHTML = `
    <div style="background:#23252a;padding:32px 38px 24px 38px;border-radius:18px;box-shadow:0 2px 24px #000a;display:flex;flex-direction:column;align-items:center;">
      <div id="no-arrows-caution" style="font-size:3em;margin-bottom:10px;">‚ö†Ô∏è</div>
      <div style="color:#ffba3a;font-size:1.2em;margin-bottom:12px;">No Arrows Equipped!</div>
      <div style="margin-bottom:12px;">You need arrows equipped to use a bow.<br>Equip arrows in your equipment panel.</div>
      <div style="color:#ffd36b;font-size:1.05em;margin-bottom:18px;text-align:center;">
        <b>The spirits frown upon archers who forget their arrows...</b>
      </div>
      <button id="no-arrows-ok" style="font-size:1.1em;font-weight:bold;background:#ffba3a;color:#23252a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">OK</button>
    </div>
  `;
  document.body.appendChild(popup);
  document.getElementById('no-arrows-ok').onclick = function() {
    popup.remove();
    noArrowsPopupActive = false;
  };
}

// --- Replace all calls to renderPlayerStats(), renderDerivedStats(), or renderEquipment() after stat changes with updateAllStats() ---
// For example, in equipItem, equipBagItem, useItem, addItem, handleEquipSlot, etc.
// Example for equipItem:
function equipItem(idx) {
  let item = player.inventory[idx];
  let slot = item.type;
  if (!isEquipable(item)) {
    logMsg(`Cannot equip ${item.name}.`);
    return;
  }
  let old = player.equipment[slot];
  if (old) player.bag.push(old);
  player.equipment[slot] = item;
  player.inventory.splice(idx, 1);
  logMsg(`Equipped ${item.name}.`);
  updateAllStats();
  renderBagInv();
}
function renderEquipment() {
  const eqLeft = document.getElementById('equipment-slots-left');
  const eqRight = document.getElementById('equipment-slots-right');
  eqLeft.innerHTML = "";
  eqRight.innerHTML = "";
  equipmentOrderLeft.forEach((slotData) => {
    const slot = slotData.slot;
    const eq = player.equipment[slot];
    let isAncient = eq && eq.name && eq.name.startsWith("Ancient ");
    let setCount = getAncientSetCount();
    let setBonus = "";
    if (isAncient) {
      setBonus = `<br><span style="color:#90ee90;font-weight:bold;">Ancient Set Bonus (${setCount}/5):</span>`;
      setBonus += `<br><span style="color:${setCount>=2?'#90ee90':'#fff'};">+20 DEF, +50 HP</span>`;
      setBonus += `<br><span style="color:${setCount>=4?'#90ee90':'#fff'};">+40 DEF, +100 HP</span>`;
      setBonus += `<br><span style="color:${setCount===5?'#90ee90':'#fff'};">+60 DEF, +150 HP</span>`;
    }
    // Show arrow count if equipped
    let arrowsCount = "";
    if (slot === "arrows" && eq && typeof eq.count === "number") {
      arrowsCount = `<br>Arrows: <b>x${eq.count}</b>`;
    }
    eqLeft.innerHTML += `
      <div class="equip-slot${isAncient ? ' ancient-set' : ''}" onclick="handleEquipSlot('${slot}')" title="${slotData.label}">
       <b>${slotData.label}:</b> <span class="item-name">${eq ? eq.name.replace(/\s*\([^)]*\)/, "") : "<em>none</em>"}</span>
  <div class="slot-tooltip">
  ${eq ? eq.name.replace(/\s*\([^)]*\)/, "") : "<em>none</em>"}
  ${eq && eq.attackPower ? `<br>ATK: <b>+${eq.attackPower}</b>` : ""}
  ${eq && eq.defense ? `<br>DEF: <b>+${eq.defense}</b>` : ""}
  ${eq && eq.health ? `<br>HP: <b>+${eq.health}</b>` : ""}
  ${arrowsCount}
  ${setBonus}
</div>
    `;
  });
  equipmentOrderRight.forEach((slotData) => {
    const slot = slotData.slot;
    const eq = player.equipment[slot];
    let isAncient = eq && eq.name && eq.name.startsWith("Ancient ");
    let setCount = getAncientSetCount();
    let setBonus = "";
    if (isAncient) {
      setBonus = `<br><span style="color:#90ee90;font-weight:bold;">Ancient Set Bonus (${setCount}/5):</span>`;
      if (setCount >= 2) setBonus += `<br><span style="color:#90ee90;">+20 DEF, +50 HP</span>`;
      if (setCount >= 4) setBonus += `<br><span style="color:#90ee90;">+40 DEF, +100 HP</span>`;
      if (setCount === 5) setBonus += `<br><span style="color:#90ee90;">+60 DEF, +150 HP</span>`;
    }
    // Show arrow count if equipped (for right side, just in case)
    let arrowsCount = "";
    if (slot === "arrows" && eq && typeof eq.count === "number") {
      arrowsCount = `<br>Arrows: <b>x${eq.count}</b>`;
    }
    eqRight.innerHTML += `
  <div class="equip-slot${isAncient ? ' ancient-set' : ''}" onclick="handleEquipSlot('${slot}')" title="${slotData.label}">
    <b>${slotData.label}:</b> <span class="item-name" style="max-width:70px;display:inline-block;vertical-align:middle;">${eq ? eq.name.replace(/\s*\([^)]*\)/, "") : "<em>none</em>"}</span>
    <div class="slot-tooltip">
      ${eq ? eq.name.replace(/\s*\([^)]*\)/, "") : "<em>none</em>"}
      ${eq && eq.attackPower ? `<br>ATK: <b>+${eq.attackPower}</b>` : ""}
      ${eq && eq.defense ? `<br>DEF: <b>+${eq.defense}</b>` : ""}
      ${eq && eq.health ? `<br>HP: <b>+${eq.health}</b>` : ""}
      ${arrowsCount}
      ${setBonus}
    </div>
  </div>
 `;
  });
  document.getElementById('equipment-legend').textContent = "Click a slot to unequip";
}
function handleEquipSlot(slot) {
  if (!player.equipment[slot]) return;
  player.bag.push(player.equipment[slot]);
  logMsg(`Unequipped ${player.equipment[slot].name} from ${slot}.`);
  player.equipment[slot] = null;
  updateAllStats();
  renderBagInv();
}
function switchBagInv(tab) {
  baginvTab = tab;
  document.getElementById('tab-inventory').classList.toggle('active', tab === "inventory");
  document.getElementById('tab-bag').classList.toggle('active', tab === "bag");
  renderBagInv();
}
function renderBagInv() {
  const content = document.getElementById('baginv-content');
  content.innerHTML = "";
  let itemsArr = baginvTab === "inventory" ? player.inventory : player.bag;
  if (searchTerm) {
    itemsArr = itemsArr.filter(i => i.name.toLowerCase().includes(searchTerm));
  }
  if (!itemsArr.length) {
    content.innerHTML = `<div style="color:#9c9c9c;text-align:center;width:100%;padding:29px 0;">No items</div>`;
    return;
  }
  if (baginvTab === "inventory") {
    itemsArr.forEach((item, idx) => {
      let isAncient = item.name && item.name.startsWith("Ancient ");
      let setCount = getAncientSetCount();
      let setBonus = "";
      if (isAncient) {
        setBonus = `<br><span style="color:gold;font-weight:bold;">Ancient Set Bonus (${setCount}/5):</span>`;
        setBonus += `<br><span style="color:${setCount>=2?'#ffd36b':'#fff'};">+20 DEF, +50 HP</span>`;
        setBonus += `<br><span style="color:${setCount>=4?'#ffd36b':'#fff'};">+40 DEF, +100 HP</span>`;
        setBonus += `<br><span style="color:${setCount===5?'#ffd36b':'#fff'};">+60 DEF, +150 HP</span>`;
      }
      content.innerHTML += `
        <div class="item-card${isAncient ? ' ancient-set' : ''}">
          ${item.type==="material" ? `<button class="bag-x-remove-btn" onclick="removeItem(${idx});event.stopPropagation()" title="Remove">&times;</button>` : ""}
          <div class="item-name">${item.name.replace(/\s*\([^)]*\)/, "")}${item.count > 1 ? ` (x${item.count})` : ""}</div>
          <div class="item-actions">
            ${item.type==="potion"||item.type==="consumable"||isHealingItem(item) ? `<button class="item-action-btn" onclick="useItem(${idx});event.stopPropagation()">Use</button>` : ""}
            ${isEquipable(item) ? `<button class="item-action-btn" onclick="equipItem(${idx});event.stopPropagation()">Equip</button>` : ""}
          </div>
          <div class="item-tooltip" style="display:none;position:absolute;left:110%;top:50%;transform:translateY(-50%);background:#18191c;color:#eee;padding:7px 13px;border-radius:8px;border:1px solid #444;white-space:nowrap;font-size:0.98em;box-shadow:0 2px 10px #0007;z-index:10;min-width:160px;">
            <b>${item.name}</b>
            ${item.description ? `<br><span style="color:#aaa;">${item.description}</span>` : ""}
            ${item.attackPower ? `<br>ATK: <b>+${item.attackPower}</b>` : ""}
            ${item.defense ? `<br>DEF: <b>+${item.defense}</b>` : ""}
            ${item.health ? `<br>HP: <b>+${item.health}</b>` : ""}
            ${item.heal ? `<br>Heals: <b>+${item.heal}</b>` : ""}
            ${item.count && item.type === "arrows" ? `<br>Arrows: <b>x${item.count}</b>` : ""}
            ${item.type ? `<br><span style="color:#ffba3a;">Type: ${item.type.charAt(0).toUpperCase() + item.type.slice(1)}</span>` : ""}
            ${setBonus}
          </div>
        </div>
      `;
    });
  } else {
    itemsArr.forEach((item, idx) => {
      let isAncient = item.name && item.name.startsWith("Ancient ");
      let setCount = getAncientSetCount();
      let setBonus = "";
      if (isAncient) {
        setBonus = `<br><span style="color:gold;font-weight:bold;">Ancient Set Bonus (${setCount}/5):</span>`;
        if (setCount >= 2) setBonus += `<br><span style="color:#ffd36b;">+20 DEF, +50 HP</span>`;
        if (setCount >= 4) setBonus += `<br><span style="color:#ffd36b;">+40 DEF, +100 HP</span>`;
        if (setCount === 5) setBonus += `<br><span style="color:#ffd36b;">+60 DEF, +150 HP</span>`;
      }
      content.innerHTML += `
        <div class="item-card${isAncient ? ' ancient-set' : ''}">
          <button class="bag-x-remove-btn" onclick="removeItem(${idx});event.stopPropagation()" title="Remove">&times;</button>
          <div class="item-name">${item.name.replace(/\s*\([^)]*\)/, "")}${item.count > 1 ? ` (x${item.count})` : ""}</div>
          <button class="bag-equip-btn" onclick="equipBagItem(${idx});event.stopPropagation()">Equip</button>
          <div class="item-tooltip" style="display:none;position:absolute;left:110%;top:50%;transform:translateY(-50%);background:#18191c;color:#eee;padding:7px 13px;border-radius:8px;border:1px solid #444;white-space:nowrap;font-size:0.98em;box-shadow:0 2px 10px #0007;z-index:10;min-width:160px;">
            <b>${item.name}</b>
            ${item.description ? `<br><span style="color:#aaa;">${item.description}</span>` : ""}
            ${item.attackPower ? `<br>ATK: <b>+${item.attackPower}</b>` : ""}
            ${item.defense ? `<br>DEF: <b>+${item.defense}</b>` : ""}
            ${item.health ? `<br>HP: <b>+${item.health}</b>` : ""}
            ${item.heal ? `<br>Heals: <b>+${item.heal}</b>` : ""}
            ${item.count && item.type === "arrows" ? `<br>Arrows: <b>x${item.count}</b>` : ""}
            ${item.type ? `<br><span style="color:#ffba3a;">Type: ${item.type.charAt(0).toUpperCase() + item.type.slice(1)}</span>` : ""}
            ${setBonus}
          </div>
        </div>
      `;
    });
  }
  // Tooltip hover logic for all .item-card
  const cards = content.querySelectorAll('.item-card');
  cards.forEach(card => {
    const tip = card.querySelector('.item-tooltip');
    card.onmouseenter = () => { if (tip) tip.style.display = 'block'; };
    card.onmouseleave = () => { if (tip) tip.style.display = 'none'; };
    card.onmousemove = (e) => {
      if (tip) {
        tip.style.left = (e.offsetX + 30) + 'px';
        tip.style.top = (e.offsetY - 10) + 'px';
      }
    };
  });
  
  // Add mystery bag open buttons
  addMysteryBagOpenButton();
}
function isHealingItem(item) {
  return typeof item.heal === "number" && item.heal > 0;
}
function isStatItem(item) {
  return (
    (typeof item.attackPower === "number" && item.attackPower > 0) ||
    (typeof item.defense === "number" && item.defense > 0) ||
    (typeof item.health === "number" && item.health > 0) ||
    ["weapon","armor","shield","ring","arrows","helmet","cloak","amulet","gloves","boots"].includes(item.type)
  );
}
function isEquipable(item) {
  return ["weapon","armor","shield","ring","arrows","helmet","cloak","amulet","gloves","boots"].includes(item.type);
}
function addItem(item) {
  // Prevent stat reroll for special seller items
  if (!item._noReroll) {
    // Only assign random stats if not already set
    if (item.type === "gloves") {
      if (typeof item.defense !== "number") item.defense = 15;
      if (typeof item.health !== "number") item.health = randomStat(30,100);
    }
    if (item.type === "boots") {
      if (typeof item.defense !== "number") item.defense = 20;
      if (typeof item.health !== "number") item.health = randomStat(20,100);
    }
    if (item.type === "helmet") {
      if (typeof item.defense !== "number") item.defense = 25;
      if (typeof item.health !== "number") item.health = randomStat(30,100);
    }
    if (item.type === "cloak") {
      if (typeof item.defense !== "number") item.defense = 35;
      if (typeof item.health !== "number") item.health = randomStat(25,100);
    }
    if (item.type === "ring") {
      if (typeof item.attackPower !== "number") item.attackPower = 2;
      if (typeof item.health !== "number") item.health = randomStat(10,100);
    }
  }

  // Helper to stack items
  function tryStack(arr, item) {
    for (let i = 0; i < arr.length; i++) {
      let it = arr[i];
      // Stack arrows by type only
      if (item.type === "arrows" && it.type === "arrows") {
        it.count = (it.count || 1) + (item.count || 1);
        return true;
      }
      // Stack other items by name, type, and key stats
      if (
        it.name === item.name &&
        it.type === item.type &&
        (it.attackPower === item.attackPower || (!it.attackPower && !item.attackPower)) &&
        (it.defense === item.defense || (!it.defense && !item.defense)) &&
        (it.heal === item.heal || (!it.heal && !item.heal)) &&
        (it.health === item.health || (!it.health && !item.health))
      ) {
        it.count = (it.count || 1) + (item.count || 1);
        return true;
      }
    }
    return false;
  }

  // Always stack arrows in both inventory and bag, updating the count of the existing stack
  if (item.type === "arrows") {
    let stacked = false;
    // Try stacking in inventory first
    for (let i = 0; i < player.inventory.length; i++) {
      let it = player.inventory[i];
      if (it.type === "arrows") {
        it.count = (it.count || 1) + (item.count || 1);
        stacked = true;
        break;
      }
    }
    // If not found in inventory, try stacking in bag
    if (!stacked) {
      for (let i = 0; i < player.bag.length; i++) {
        let it = player.bag[i];
        if (it.type === "arrows") {
          it.count = (it.count || 1) + (item.count || 1);
          stacked = true;
          break;
        }
      }
    }
    // If not found in either, add to bag by default
    if (!stacked) {
      player.bag.push({ ...item, count: item.count || 1 });
    }
    logMsg(`Added ${item.name}${item.count > 1 ? ` (x${item.count})` : ""} to Bag.`);
  } else if (item.type === "material") {
    if (!tryStack(player.inventory, item)) {
      player.inventory.push({ ...item, count: item.count || 1 });
    }
    logMsg(`Added ${item.name}${item.count > 1 ? ` (x${item.count})` : ""} to Inventory.`);
  } else if (isHealingItem(item)) {
    if (!tryStack(player.inventory, item)) {
      player.inventory.push({ ...item, count: item.count || 1 });
    }
    logMsg(`Added ${item.name}${item.count > 1 ? ` (x${item.count})` : ""} to Inventory.`);
  } else if (isStatItem(item)) {
    if (!tryStack(player.bag, item)) {
      player.bag.push({ ...item, count: item.count || 1 });
    }
    logMsg(`Added ${item.name}${item.count > 1 ? ` (x${item.count})` : ""} to Bag.`);
  } else {
    if (!tryStack(player.inventory, item)) {
      player.inventory.push({ ...item, count: item.count || 1 });
    }
    logMsg(`Added ${item.name}${item.count > 1 ? ` (x${item.count})` : ""} to Inventory.`);
  }
  renderBagInv();
}
function selectBagInvItem(idx) {}

// --- PATCH: Multi-use healing items popup ---
function useItem(idx) {
  let itemsArr = baginvTab === "inventory" ? player.inventory : player.bag;
  const item = itemsArr[idx];
  if (isHealingItem(item)) {
    let maxHeal = getTotalMaxHealth();
    if (maxHeal <= 100) maxHeal = 100;
    if (item.count && item.count > 1) {
      // Show popup to ask how many to use
      showUseMultiplePopup(item, idx, itemsArr, maxHeal);
      return;
    }
    if (player.health < maxHeal) {
      player.health = Math.min(maxHeal, player.health + (item.heal||0));
      logMsg(`Used ${item.name}, healed for ${item.heal}.`);
      itemsArr.splice(idx, 1);
    } else {
      logMsg(`${item.name} can't be used at full health.`);
    }
  } else {
    logMsg(`You can't use ${item.name} directly.`);
  }
  updateAllStats();
  renderBagInv();
}

// Helper: show popup for multi-use healing items
function showUseMultiplePopup(item, idx, itemsArr, maxHeal) {
  // Remove existing popup if any
  let oldPopup = document.getElementById('multi-use-popup');
  if (oldPopup) oldPopup.remove();
  // Create popup
  const popup = document.createElement('div');
  popup.id = 'multi-use-popup';
  popup.style = 'position:fixed;z-index:9999;top:0;left:0;width:100vw;height:100vh;background:#191a1ecc;display:flex;align-items:center;justify-content:center;';
  popup.innerHTML = `
    <div style="background:#23252a;padding:32px 38px 24px 38px;border-radius:18px;box-shadow:0 2px 24px #000a;display:flex;flex-direction:column;align-items:center;">
      <div style="color:#ffba3a;font-size:1.2em;margin-bottom:18px;">Use ${item.name} (x${item.count})</div>
      <div style="margin-bottom:12px;">How many would you like to use?</div>
      <input id="multi-use-count" type="number" min="1" max="${item.count}" value="1" style="font-size:1.1em;padding:6px 18px;border-radius:7px;border:1.5px solid #444;background:#18191c;color:#fff;margin-bottom:18px;width:120px;outline:none;">
      <div style="margin-bottom:12px;color:#aaa;">Each heals for ${item.heal}. Current HP: ${player.health}/${maxHeal}</div>
      <div style="display:flex;gap:18px;">
        <button id="multi-use-confirm" style="font-size:1.1em;font-weight:bold;background:#ffba3a;color:#23252a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">Use</button>
        <button id="multi-use-cancel" style="font-size:1.1em;font-weight:bold;background:#35373e;color:#ffba3a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">Cancel</button>
      </div>
      <div id="multi-use-error" style="color:#ff4444;margin-top:10px;display:none;font-size:1em;"></div>
    </div>
  `;
  document.body.appendChild(popup);

  document.getElementById('multi-use-cancel').onclick = function() {
    popup.remove();
  };
  document.getElementById('multi-use-confirm').onclick = function() {
    const countInput = document.getElementById('multi-use-count');
    let useCount = parseInt(countInput.value, 10);
    if (isNaN(useCount) || useCount < 1 || useCount > item.count) {
      document.getElementById('multi-use-error').textContent = 'Enter a valid number.';
      document.getElementById('multi-use-error').style.display = 'block';
      return;
    }
    let totalHeal = useCount * (item.heal || 0);
    let healed = Math.min(maxHeal - player.health, totalHeal);
    if (player.health >= maxHeal) {
      document.getElementById('multi-use-error').textContent = `${item.name} can't be used at full health.`;
      document.getElementById('multi-use-error').style.display = 'block';
      return;
    }
    player.health = Math.min(maxHeal, player.health + totalHeal);
    item.count -= useCount;
    if (item.count <= 0) itemsArr.splice(idx, 1);
    logMsg(`Used ${useCount} ${item.name}${useCount > 1 ? 's' : ''}, healed for ${healed}.`);
    updateAllStats();
    renderBagInv();
    popup.remove();
  };
  document.getElementById('multi-use-count').addEventListener('keydown', function(e) {
    if (e.key === 'Enter') document.getElementById('multi-use-confirm').click();
  });
}
function equipItem(idx) {
  let item = player.inventory[idx];
  let slot = item.type;
  if (!isEquipable(item)) {
    logMsg(`Cannot equip ${item.name}.`);
    return;
  }
  let old = player.equipment[slot];
  if (old) player.bag.push(old);
  player.equipment[slot] = item;
  player.inventory.splice(idx, 1);
  logMsg(`Equipped ${item.name}.`);
  updateAllStats();
  renderBagInv();
}
function removeItem(idx) {
  let itemsArr = baginvTab === "inventory" ? player.inventory : player.bag;
  let item = itemsArr.splice(idx, 1)[0];
  logMsg(`Removed ${item.name}.`);
  renderBagInv();
}
function equipBagItem(idx) {
  let item = player.bag[idx];
  let slot = item.type;
  let old = player.equipment[slot];
  if (old) player.bag.push(old);
  player.equipment[slot] = item;
  player.bag.splice(idx, 1);
  logMsg(`Equipped ${item.name}.`);
  updateAllStats();
  renderBagInv();
}
function getRandomEnemy() {
  let e = enemyPool[Math.floor(Math.random() * enemyPool.length)];
  return {
    name: e.name,
    health: e.maxHealth,
    maxHealth: e.maxHealth,
    minAttack: e.minAttack,
    maxAttack: e.maxAttack,
    xp: e.xp
  };
}
function showEnemy() {
  // Only show a normal enemy if not in unknown enemy mode
  if (window._unknownEnemyActive) return;
  currentEnemy = getRandomEnemy();
  inCombat = true;
  renderEnemyEncounter();
  logMsg(`A wild <b>${currentEnemy.name}</b> appears!`);
}
function renderEnemyEncounter() {
  const enemyDiv = document.getElementById('enemy-encounter');
  if (!currentEnemy) {
    enemyDiv.style.display = "none";
    return;
  }
  enemyDiv.style.display = "flex";
  const percent = Math.max(0, 100 * currentEnemy.health/currentEnemy.maxHealth);
  document.getElementById('enemy-hp-bar-inner').style.width = percent + "%";
  document.getElementById('enemy-hp-bar-text').textContent = `${currentEnemy.health}/${currentEnemy.maxHealth}`;
  const imageBox = document.getElementById('enemy-image');
  imageBox.innerHTML = `${currentEnemy.name}`;
  document.getElementById('enemy-name-label').textContent = currentEnemy.name;
}
function clearEnemy() {
  currentEnemy = null;
  inCombat = false;
  renderEnemyEncounter();
}
function showHitsplat(target, damage, isPlayer) {
  const hitsplat = document.createElement('div');
  hitsplat.className = `hitsplat ${isPlayer ? 'player' : 'enemy'}`;
  hitsplat.textContent = `-${damage}`;
  // Add color styling for hitsplat
  hitsplat.style.position = 'absolute';
  hitsplat.style.top = '10px';
  hitsplat.style.left = '50%';
  hitsplat.style.transform = 'translateX(-50%)';
  hitsplat.style.fontWeight = 'bold';
  hitsplat.style.fontSize = '1.5em';
  hitsplat.style.pointerEvents = 'none';
  hitsplat.style.zIndex = '100';
  hitsplat.style.padding = '2px 10px';
  hitsplat.style.borderRadius = '8px';
  hitsplat.style.boxShadow = '0 2px 10px #0007';
  hitsplat.style.background = isPlayer ? '#2196f3' : '#e53935';
  hitsplat.style.color = '#fff';
  hitsplat.style.opacity = '0.95';
  hitsplat.style.animation = 'hitsplatAnim 0.9s ease-out';
  // Add animation keyframes if not present
  if (!document.getElementById('hitsplat-anim-style')) {
    const style = document.createElement('style');
    style.id = 'hitsplat-anim-style';
    style.textContent = `
      @keyframes hitsplatAnim {
        0% { opacity: 1; transform: translateX(-50%) scale(1) translateY(0); }
        60% { opacity: 1; transform: translateX(-50%) scale(1.2) translateY(-18px);}
        100% { opacity: 0; transform: translateX(-50%) scale(1) translateY(-32px);}
      }
    `;
    document.head.appendChild(style);
  }
  target.appendChild(hitsplat);
  setTimeout(() => {
    if (target.contains(hitsplat)) target.removeChild(hitsplat);
  }, 900);
}
window.attackEnemy = function() {
  if (!currentEnemy || !inCombat) {
    logMsg("No enemy to attack.");
    return;
  }

  // Debug 1-Hit Kill Sword logic (works for all enemies including Ancient Boss and forced encounters)
  if (
    player.equipment.weapon &&
    player.equipment.weapon.name === "Debug 1-Hit Sword"
  ) {
    let hit = currentEnemy.health;
    currentEnemy.health = 0;
    showHitsplat(document.getElementById('enemy-image'), hit, true); // Player attack: blue
    logMsg(`<span style="color:#ff4444;font-weight:bold;">You instantly killed the <b>${currentEnemy.name}</b>!</span>`);
    renderEnemyEncounter();
    let goldDrop = Math.floor(Math.random() * 51);
    player.gold += goldDrop;
    let randomItem = JSON.parse(JSON.stringify(items[Math.floor(Math.random() * items.length)]));
    addItem(randomItem);
    let goldMsg = goldDrop > 0 ? ` <span style="color:gold;">+${goldDrop} Gold</span>` : '';
    logMsg(`<span style="color:#90ee90"><b>You defeated the ${currentEnemy.name}!</b></span> +${currentEnemy.xp} XP${goldMsg} and found ${randomItem.name}`);
    player.experience += currentEnemy.xp;
    checkLevelUp();
    // Always trigger boss rewards if Ancient Boss is killed
    if (currentEnemy.name === "Ancient Boss" || currentEnemy.isBoss) {
      if (typeof giveAncientBossRewards === "function") giveAncientBossRewards();
      ancientBossActive = false;
    }
    clearEnemy();
    renderPlayerStats();
    return;
  }

  // No weapon equipped logic
  if (!player.equipment.weapon) {
    if (!window.noWeaponPopupShown) {
      showNoWeaponPopup();
      window.noWeaponPopupShown = true;
    }
    currentEnemy.health = Math.max(0, currentEnemy.health - 1);
    showHitsplat(document.getElementById('enemy-image'), 1, true);
    logMsg(`<span style="color:#ff4444;font-weight:bold;">You attack with your bare hands and deal <b>1</b> damage!</span>`);
    renderEnemyEncounter();
    if (currentEnemy.health <= 0) {
      let goldDrop = Math.floor(Math.random() * 51);
      player.gold += goldDrop;
      let randomItem = JSON.parse(JSON.stringify(items[Math.floor(Math.random() * items.length)]));
      addItem(randomItem);
      let goldMsg = goldDrop > 0 ? ` <span style="color:gold;">+${goldDrop} Gold</span>` : '';
      logMsg(`<span style="color:#90ee90"><b>You defeated the ${currentEnemy.name}!</b></span> +${currentEnemy.xp} XP${goldMsg} and found ${randomItem.name}`);
      player.experience += currentEnemy.xp;
      checkLevelUp();
      clearEnemy();
      renderPlayerStats();
      return;
    }
    setTimeout(()=>{ enemyAttack(); }, 700);
    return;
  }

  // Bow & arrows logic
  if (isEquippedBow()) {
    if (!hasEquippedArrows()) {
      if (!window.noArrowsPopupActive) showNoArrowsPopup();
      if (typeof autoAttackActive !== "undefined" && autoAttackActive) stopAutoAttack && stopAutoAttack();
      return;
    }
    player.equipment.arrows.count -= 1;
    logMsg(`<span style="color:#ffba3a;">Used 1 arrow. ${player.equipment.arrows.count > 0 ? `Arrows left: ${player.equipment.arrows.count}` : "No arrows left!"}</span>`);
    if (player.equipment.arrows.count <= 0) {
      logMsg(`<span style="color:#f44;font-weight:bold;">You have run out of arrows!</span>`);
      player.equipment.arrows = null;
    }
    updateAllStats();
    renderBagInv();
  }

  // Ancient Boss logic
  if (currentEnemy.isBoss) {
    let pAtk = (player.equipment.weapon ? player.equipment.weapon.attackPower||8 : 6)
      + (player.equipment.ring ? player.equipment.ring.attackPower||0 : 0);
    let hit = randomStat(30, 90);
    currentEnemy.health = Math.max(0, currentEnemy.health - hit);
    showHitsplat(document.getElementById('enemy-image'), hit, true);
    logMsg(`You hit the <b>${currentEnemy.name}</b> for <b>${hit}</b>!`);
    renderEnemyEncounter();
    if (currentEnemy.health <= 0) {
      player.experience += currentEnemy.xp;
      checkLevelUp();
      giveAncientBossRewards();
      ancientBossActive = false;
      ancientBossShopLocked = false;
      clearEnemy();
      renderPlayerStats();
      hideShopClosedOverlay && hideShopClosedOverlay();
      return;
    }
    setTimeout(()=>{ enemyAttack(); }, 700);
    return;
  }

  // Normal enemy attack with multiple styles based on enemy type
  let pAtk = (player.equipment.weapon ? player.equipment.weapon.attackPower || 8 : 6)
    + (player.equipment.ring ? player.equipment.ring.attackPower || 0 : 0);

  // Determine attack style based on enemy name/type
  let hit = 1;
  let attackStyle = "normal";
  if (currentEnemy.name) {
    const name = currentEnemy.name.toLowerCase();
    if (name.includes("fire") || name.includes("elemental")) {
      // Fire enemies: burn effect, extra damage
      hit = Math.max(1, Math.floor(pAtk + Math.random() * 10) + 8);
      attackStyle = "fire";
    } else if (name.includes("ice") || name.includes("frost")) {
      // Ice enemies: chance to freeze (skip next turn)
      hit = Math.max(1, Math.floor(pAtk + Math.random() * 7));
      attackStyle = "ice";
      if (Math.random() < 0.18) {
        logMsg(`<span style="color:#2196f3;font-weight:bold;">You freeze the ${currentEnemy.name}! Enemy skips next attack.</span>`);
        currentEnemy._skipNextAttack = true;
      }
    } else if (name.includes("vampire")) {
      // Vampire: lifesteal, heals enemy
      hit = Math.max(1, Math.floor(pAtk + Math.random() * 8));
      attackStyle = "vampire";
      let heal = Math.floor(hit * 0.5);
      currentEnemy.health = Math.min(currentEnemy.maxHealth, currentEnemy.health + heal);
      logMsg(`<span style="color:#e53935;">The ${currentEnemy.name} steals <b>${heal}</b> HP!</span>`);
    } else if (name.includes("golem") || name.includes("stone")) {
      // Golem: high defense, lower damage
      hit = Math.max(1, Math.floor(pAtk + Math.random() * 5));
      attackStyle = "golem";
    } else if (name.includes("assassin") || name.includes("shadow")) {
      // Assassin: chance for critical hit
      hit = Math.max(1, Math.floor(pAtk + Math.random() * 10));
      attackStyle = "assassin";
      if (Math.random() < 0.15) {
        hit *= 2;
        logMsg(`<span style="color:#ffd36b;font-weight:bold;">Critical hit!</span>`);
      }
    } else if (name.includes("dragon")) {
      // Dragon: fire breath, high damage
      hit = Math.max(1, Math.floor(pAtk + Math.random() * 15) + 10);
      attackStyle = "dragon";
    } else if (name.includes("lich")) {
      // Lich: magic attack, ignore some defense
      hit = Math.max(1, Math.floor(pAtk + Math.random() * 12) + 5);
      attackStyle = "lich";
    } else if (name.includes("troll")) {
      // Troll: chance to stun player
      hit = Math.max(1, Math.floor(pAtk + Math.random() * 9));
      attackStyle = "troll";
      if (Math.random() < 0.12) {
        logMsg(`<span style="color:#ff4444;">The ${currentEnemy.name} stuns you! You lose your next turn.</span>`);
        player._skipNextTurn = true;
      }
    } else {
      // Default style
      hit = Math.max(1, Math.floor(pAtk + Math.random() * 10));
    }
  }

  // Show hitsplat with blue color for player attack
  const enemyImageDiv = document.getElementById('enemy-image');
  if (enemyImageDiv) {
    const hitsplat = document.createElement('div');
    hitsplat.className = 'hitsplat player';
    hitsplat.textContent = `-${hit}`;
    hitsplat.style.background = "#2196f3";
    hitsplat.style.color = "#fff";
    hitsplat.style.position = 'absolute';
    hitsplat.style.top = '10px';
    hitsplat.style.left = '50%';
    hitsplat.style.transform = 'translateX(-50%)';
    hitsplat.style.fontWeight = 'bold';
    hitsplat.style.fontSize = '1.5em';
    hitsplat.style.pointerEvents = 'none';
    hitsplat.style.zIndex = '100';
    hitsplat.style.padding = '2px 10px';
    hitsplat.style.borderRadius = '8px';
    hitsplat.style.boxShadow = '0 2px 10px #0007';
    hitsplat.style.opacity = '0.95';
    hitsplat.style.animation = 'hitsplatAnim 0.9s ease-out';
    enemyImageDiv.appendChild(hitsplat);
    setTimeout(() => {
      if (enemyImageDiv.contains(hitsplat)) enemyImageDiv.removeChild(hitsplat);
    }, 900);
  }

  currentEnemy.health = Math.max(0, currentEnemy.health - hit);
  logMsg(`You hit the <b>${currentEnemy.name}</b> for <b>${hit}</b>!`);
  renderEnemyEncounter();
  if (currentEnemy.health <= 0) {
    let goldDrop = Math.floor(Math.random() * 51);
    player.gold += goldDrop;
    let randomItem = JSON.parse(JSON.stringify(items[Math.floor(Math.random() * items.length)]));
    addItem(randomItem);
    let goldMsg = goldDrop > 0 ? ` <span style="color:gold;">+${goldDrop} Gold</span>` : '';
    logMsg(`<span style="color:#90ee90"><b>You defeated the ${currentEnemy.name}!</b></span> +${currentEnemy.xp} XP${goldMsg} and found ${randomItem.name}`);
    player.experience += currentEnemy.xp;
    checkLevelUp();
    clearEnemy();
    renderPlayerStats();
    return;
  }
  setTimeout(() => { enemyAttack(); }, 700);

  // Enemy attack function
  function enemyAttack() {
    if (!currentEnemy || !inCombat) return;
    // Skip attack if frozen or stunned
    if (currentEnemy._skipNextAttack) {
      logMsg(`<span style="color:#2196f3;font-weight:bold;">${currentEnemy.name} is frozen and skips its attack!</span>`);
      currentEnemy._skipNextAttack = false;
      return;
    }
    if (player._skipNextTurn) {
      logMsg(`<span style="color:#ff4444;">You are stunned and lose your turn!</span>`);
      player._skipNextTurn = false;
      return;
    }
    // Calculate enemy damage
    let minAtk = currentEnemy.minAttack || 5;
    let maxAtk = currentEnemy.maxAttack || 10;
    let hit = Math.max(1, Math.floor(Math.random() * (maxAtk - minAtk + 1)) + minAtk - getTotalDefense());
    if (hit < 1) hit = 1;
    player.health = Math.max(0, player.health - hit);
    // Show hitsplat with red color for enemy attack
    const enemyImageDiv = document.getElementById('enemy-image');
    if (enemyImageDiv) {
      const hitsplat = document.createElement('div');
      hitsplat.className = 'hitsplat enemy';
      hitsplat.textContent = `-${hit}`;
      hitsplat.style.background = "#e53935";
      hitsplat.style.color = "#fff";
      hitsplat.style.position = 'absolute';
      hitsplat.style.top = '10px';
      hitsplat.style.left = '50%';
      hitsplat.style.transform = 'translateX(-50%)';
      hitsplat.style.fontWeight = 'bold';
      hitsplat.style.fontSize = '1.5em';
      hitsplat.style.pointerEvents = 'none';
      hitsplat.style.zIndex = '100';
      hitsplat.style.padding = '2px 10px';
      hitsplat.style.borderRadius = '8px';
      hitsplat.style.boxShadow = '0 2px 10px #0007';
      hitsplat.style.opacity = '0.95';
      hitsplat.style.animation = 'hitsplatAnim 0.9s ease-out';
      enemyImageDiv.appendChild(hitsplat);
      setTimeout(() => {
        if (enemyImageDiv.contains(hitsplat)) enemyImageDiv.removeChild(hitsplat);
      }, 900);
    }
    logMsg(`<span style="color:#e53935;">${currentEnemy.name} attacks you for <b>${hit}</b> damage!</span>`);
    renderPlayerStats();
    if (player.health <= 0) {
      logMsg(`<span style="color:#f44;font-weight:bold;">You died! Respawning at town...</span>`);
      respawnPlayer();
      clearEnemy();
      return;
    }
  }
}

function openChest() {
  chestOpen = true;
  let reward = Math.floor(Math.random()*500)+1;
  chestReward = reward;
  player.gold += reward;
  document.getElementById('chest-reward').textContent = `You found ${reward} gold!`;
  document.getElementById('chest-encounter').style.display = "flex";
  // Remove chest from map
  mapData[playerPosition.y][playerPosition.x] = { type: "discovered", name: "" };
  renderMap();
  renderPlayerStats();
}
function closeChest() {
  chestOpen = false;
  document.getElementById('chest-encounter').style.display = "none";
}
function openBank() {
  document.getElementById('bank-modal-bg').style.display = 'flex';
  renderBank();
}
function closeBank() {
  document.getElementById('bank-modal-bg').style.display = 'none';
}
function renderBank() {
  const bankList = document.getElementById('bank-list');
  const invList = document.getElementById('bank-inv-list');
  bankList.innerHTML = "";
  invList.innerHTML = "";
  if (!player.bank.length) bankList.innerHTML = "<div id='bank-empty-msg'>No items in bank.</div>";
  player.bank.forEach((item, idx) => {
    bankList.innerHTML += `
      <div class="bank-item-card">
        <span>${item.name}</span>
        <button class="bank-action-btn" onclick="removeFromBank(${idx})">Withdraw</button>
      </div>
    `;
  });
  let invItems = [...player.inventory, ...player.bag];
  if (!invItems.length) invList.innerHTML = "<div id='bank-empty-msg'>No items to deposit.</div>";
  invItems.forEach((item, idx) => {
    invList.innerHTML += `
      <div class="bank-item-card">
        <span>${item.name}</span>
        <button class="bank-action-btn" onclick="addToBank(${idx})">Deposit</button>
      </div>
    `;
  });
  updateBankGoldLabels();
}
function addToBank(idx) {
  let itemsArr = [...player.inventory, ...player.bag];
  let item = itemsArr[idx];
  let invIdx = player.inventory.findIndex(i => i === item);
  if (invIdx !== -1) player.inventory.splice(invIdx, 1);
  else player.bag.splice(player.bag.findIndex(i => i === item), 1);
  player.bank.push(item);
  logMsg(`Deposited ${item.name} to the bank.`);
  renderBagInv(); renderBank();
}
function removeFromBank(idx) {
  let item = player.bank.splice(idx, 1)[0];
  if (isEquipable(item)) player.bag.push(item);
  else player.inventory.push(item);
  logMsg(`Withdrew ${item.name} from the bank.`);
  renderBagInv(); renderBank();
}
function explore() {
  // Deprecated, use startExplore
  startExplore();
}
function visitShop() { logMsg("Opening shop... (implement backend)"); }
function showCommands() {
  logMsg(`Commands: /explore, /attack, /shop, /bank, /status, /inventory, /bag, /buy, /sell, /equipment, /unequip`);
}
function searchItem() {
  searchTerm = document.getElementById('item-search').value.toLowerCase();
  renderBagInv();
}
function logMsg(msg) {
  let logDiv = document.getElementById('game-log');
  logDiv.innerHTML += `<div>${msg}</div>`;
  logDiv.scrollTop = logDiv.scrollHeight;
}
function checkLevelUp() {
  let nextLvXp = 60 + (player.level-1)*45;
  if (player.experience >= nextLvXp) {
    player.level += 1;
    player.maxHealth += 18;
    player.health = player.maxHealth;
    player.experience -= nextLvXp;
    logMsg(`<span style="color:gold;font-weight:bold;">You leveled up to Level ${player.level}! Max HP increased.</span>`);
    updateAllStats();
  }
}
function respawnPlayer() {
  player.health = player.maxHealth;
  playerPosition = { x: Math.floor(mapSize/2), y: Math.floor(mapSize/2) };
  discovered[playerPosition.y][playerPosition.x] = true;
  renderPlayerStats();
  renderMap();
}
function renderDerivedStats() {
  let atk = getTotalAttack();
  let def = getTotalDefense();
  let hp = getTotalMaxHealth();
  let stats = [
    `<li><span class="derived-label">Attack:</span> ${atk}</li>`,
    `<li><span class="derived-label">Defense:</span> ${def}</li>`,
    `<li><span class="derived-label">Max Health:</span> ${hp}</li>`
  ];
  document.getElementById('derived-stats-list').innerHTML = stats.join('');
}
// --- TOWN POPUP LOGIC ---
if (!document.getElementById('town-popup')) {
  const townPopup = document.createElement('div');
  townPopup.id = 'town-popup';
  townPopup.style = 'display:none;position:fixed;z-index:4000;top:0;left:0;width:100vw;height:100vh;background:#191a1e99;align-items:center;justify-content:center;';
  townPopup.innerHTML = `
    <div style="background:#23252a;padding:32px 38px 24px 38px;border-radius:18px;box-shadow:0 2px 24px #000a;display:flex;flex-direction:column;align-items:center;">
      <div id="town-popup-title" style="color:#ffba3a;font-size:1.3em;margin-bottom:18px;"></div>
      <div style="margin-bottom:18px;">Do you wish to visit this town?</div>
      <div style="display:flex;gap:18px;">
        <button id="town-popup-yes" style="font-size:1.1em;font-weight:bold;background:#ffba3a;color:#23252a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">Yes</button>
        <button id="town-popup-no" style="font-size:1.1em;font-weight:bold;background:#35373e;color:#ffba3a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">No</button>
      </div>
    </div>
  `;
  document.body.appendChild(townPopup);
}
if (!document.getElementById('special-seller-popup')) {
  const sellerPopup = document.createElement('div');
  sellerPopup.id = 'special-seller-popup';
  sellerPopup.style = 'display:none;position:fixed;z-index:4100;top:0;left:0;width:100vw;height:100vh;background:#191a1e99;align-items:center;justify-content:center;';
  sellerPopup.innerHTML = `
    <div style="background:#23252a;padding:32px 38px 24px 38px;border-radius:18px;box-shadow:0 2px 24px #000a;display:flex;flex-direction:column;align-items:center;min-width:340px;">
      <div style="color:#ffba3a;font-size:1.3em;margin-bottom:18px;">Special Seller</div>
      <div style="margin-bottom:18px;">Welcome, traveler! Here are my rare wares:</div>
      <div id="special-seller-items" style="margin-bottom:18px;width:100%;"></div>
      <button onclick="closeSpecialSeller()" style="font-size:1.1em;font-weight:bold;background:#35373e;color:#ffba3a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">Close</button>
    </div>
  `;
  document.body.appendChild(sellerPopup);


// Ensure showSpecialSeller is globally available and generates items and buy buttons

// Add tooltip CSS if not present
if (!document.getElementById('special-seller-tooltip-style')) {
  const style = document.createElement('style');
  style.id = 'special-seller-tooltip-style';
  style.textContent = `
    .special-seller-item { position: relative; }
    .special-seller-tooltip {
      pointer-events: none;
      opacity: 0.98;
      transition: opacity 0.12s;
    }
  `;
  document.head.appendChild(style);
}
}


let lastTownVisited = null;
function showTownPopup(townName) {
  lastTownVisited = townName;
  document.getElementById('town-popup-title').textContent = `You arrived at ${townName}!`;
  document.getElementById('town-popup').style.display = 'flex';
}
document.getElementById('town-popup-yes').onclick = function() {
  document.getElementById('town-popup').style.display = 'none';
  if (!visitedTowns[lastTownVisited]) {
    showSpecialSeller();
    visitedTowns[lastTownVisited] = true;
    renderMap();
  }
};
document.getElementById('town-popup-no').onclick = function() {
  document.getElementById('town-popup').style.display = 'none';
};
  // Add emojis for area names
  const areaEmojis = {
    Plains: "üåæ",
    Forest: "üå≤",
    Mountain: "‚õ∞Ô∏è",
    River: "üåä",
    Ruins: "üèöÔ∏è",
    Cave: "üï≥Ô∏è",
    Desert: "üèúÔ∏è",
    Swamp: "ü¶Ü",
    Valley: "üèûÔ∏è",
    Hills: "üåÑ"
  };

  // Patch renderMap to show emoji for area cells
  const origRenderMapWithEmoji = renderMap;
  renderMap = function() {
    const map = document.getElementById('game-map');
    map.innerHTML = "";
    for (let y = 0; y < mapSize; ++y) {
      for (let x = 0; x < mapSize; ++x) {
        let cellClass = "map-cell";
        let label = "";
        let cell = mapData[y][x];
        // Player
        if (x === playerPosition.x && y === playerPosition.y) {
          cellClass += " player";
        }
        // Central Town
        if (cell.type === "central-town") {
          cellClass += " central-town";
          label = "C";
        }
        // Other Towns
        else if (cell.type === "town") {
          cellClass += " town";
          if (visitedTowns[cell.name]) {
            label = "‚úî";
          } else {
            label = "T";
          }
        }
        // Chest
        else if (cell.type === "chest") {
          cellClass += " chest";
            label = "ü™ô";
        }
        // Area
        else if (cell.type === "area") {
          if (discovered[y][x]) {
            cellClass += " discovered";
            label = areaEmojis[cell.name] || cell.name[0];
          } else {
            cellClass += " area";
            label = areaEmojis[cell.name] || cell.name[0];
          }
        }
        // Discovered
        else if (cell.type === "discovered") {
          cellClass += " discovered";
          label = "";
        }
        // Undiscovered
        if (!discovered[y][x] && cell.type !== "central-town" && cell.type !== "town" && cell.type !== "chest") {
          cellClass += " undiscovered";
          label = "";
        }
        // Show player icon
        if (x === playerPosition.x && y === playerPosition.y) {
          label = "üßë";
        }
        map.innerHTML += `<div class="${cellClass}" data-x="${x}" data-y="${y}" onclick="mapCellClick(${x},${y})" title="${cell.type === 'area' || cell.type === 'discovered' ? cell.name : cell.name || ''}">${label}</div>`;
      }
    }
    let areaLabel = "";
    let cell = mapData[playerPosition.y][playerPosition.x];
    if (cell.type === "central-town") areaLabel = "Area: Central Town";
    else if (cell.type === "town") areaLabel = "Area: " + cell.name;
    else if (cell.type === "chest") areaLabel = "Area: Chest";
    else if (!discovered[playerPosition.y][playerPosition.x]) areaLabel = "Area: Not Discovered";
    else areaLabel = "Area: " + (cell.name || "Discovered");
    document.getElementById("map-area-label").textContent = areaLabel;
  };

function refreshShopItems() {
  // Helper to generate a random item by type
  function generateItem(type) {
    switch (type) {
      case "armor":
        {
          let def = Math.floor(Math.random() * 106) + 20;
          let price = Math.floor(50 + (def - 20) * 8);
          return {
            name: `Armor`,
            type: 'armor',
            defense: def,
            price: price,
            description: `Protective armor.`,
            _shopStat: def // for tooltip
          };
        }
      case "weapon":
        {
          let atk = Math.floor(Math.random() * 91) + 10;
          let price = Math.floor(30 + (atk - 10) * 5);
          return {
            name: `Weapon`,
            type: 'weapon',
            attackPower: atk,
            price: price,
            description: `A sharp weapon.`,
            _shopStat: atk
          };
        }
      case "potion":
        {
          let heal = Math.floor(Math.random() * 81) + 20;
          let price = Math.floor(10 + (heal - 20) * 3);
          return {
            name: `Potion`,
            type: 'potion',
            heal: heal,
            price: price,
            description: `Heals for ${heal} HP.`,
            _shopStat: heal
          };
        }
      case "helmet":
        {
          let def = Math.floor(Math.random() * 41) + 10;
          let hp = Math.floor(Math.random() * 61) + 20;
          let price = Math.floor(40 + def * 6 + hp * 2);
          return {
            name: `Helmet`,
            type: 'helmet',
            defense: def,
            health: hp,
            price: price,
            description: `Sturdy helmet.`,
            _shopStat: {def, hp}
          };
        }
      case "boots":
        {
          let def = Math.floor(Math.random() * 31) + 10;
          let hp = Math.floor(Math.random() * 41) + 10;
          let price = Math.floor(30 + def * 5 + hp * 2);
          return {
            name: `Boots`,
            type: 'boots',
            defense: def,
            health: hp,
            price: price,
            description: `Protective boots.`,
            _shopStat: {def, hp}
          };
        }
      case "shield":
        {
          let def = Math.floor(Math.random() * 41) + 20;
          let price = Math.floor(50 + def * 7);
          return {
            name: `Shield`,
            type: 'shield',
            defense: def,
            price: price,
            description: `Sturdy shield.`,
            _shopStat: def
          };
        }
      case "cloak":
        {
          let def = Math.floor(Math.random() * 26) + 15;
          let hp = Math.floor(Math.random() * 41) + 10;
          let price = Math.floor(60 + def * 5 + hp * 2);
          return {
            name: `Cloak`,
            type: 'cloak',
            defense: def,
            health: hp,
            price: price,
            description: `Mystical cloak.`,
            _shopStat: {def, hp}
          };
        }
      case "amulet":
        {
          let def = Math.floor(Math.random() * 16) + 5;
          let price = Math.floor(100 + def * 12);
          return {
            name: `Amulet`,
            type: 'amulet',
            defense: def,
            price: price,
            description: `Mystic amulet.`,
            _shopStat: def
          };
        }
      case "ring":
        {
          let atk = Math.floor(Math.random() * 6) + 2;
          let hp = Math.floor(Math.random() * 51) + 10;
          let price = Math.floor(120 + atk * 20 + hp * 3);
          return {
            name: `Ring`,
            type: 'ring',
            attackPower: atk,
            health: hp,
            price: price,
            description: `Magical ring.`,
            _shopStat: {atk, hp}
          };
        }
      case "gloves":
        {
          let def = Math.floor(Math.random() * 21) + 10;
          let hp = Math.floor(Math.random() * 31) + 10;
          let price = Math.floor(25 + def * 4 + hp * 2);
          return {
            name: `Gloves`,
            type: 'gloves',
            defense: def,
            health: hp,
            price: price,
            description: `Strong gloves.`,
            _shopStat: {def, hp}
          };
        }
      case "full-armor-set":
        {
          let setDef = Math.floor(Math.random() * 101) + 100;
          let setHp = Math.floor(Math.random() * 201) + 200;
          let price = Math.floor(1000 + setDef * 15 + setHp * 5);
          return {
            name: `Full Armor Set`,
            type: 'armor-set',
            defense: setDef,
            health: setHp,
            price: Math.min(price, 5000),
            description: `Contains Armor, Helmet, Boots, Shield, Cloak, Gloves.`,
            _shopStat: {setDef, setHp}
          };
        }
      case "arrows":
        return {
          name: 'Arrows',
          type: 'arrows',
          count: 100,
          price: 15,
          description: 'A pack of 100 arrows.',
          _shopStat: 100
        };
      case "bow":
        {
          let batk = Math.floor(Math.random() * 131) + 20;
          let price = Math.floor(60 + (batk - 20) * 3.5);
          return {
            name: `Bow`,
            type: 'weapon',
            attackPower: batk,
            isBow: true,
            price: price,
            description: `A powerful bow.`,
            _shopStat: batk
          };
        }
      default:
        return null;
    }
  }

  // List of types to pick from for variety
  const types = [
    "armor", "weapon", "potion", "helmet", "boots", "shield", "cloak", "amulet", "ring", "gloves", "full-armor-set", "arrows", "bow"
  ];

  // Shuffle and pick 12 types for shop
  let shopTypes = types.slice();
  let shopItems = [];
  while (shopItems.length < 12) {
    let t = shopTypes[Math.floor(Math.random() * shopTypes.length)];
    let item = generateItem(t);
    if (item) shopItems.push(item);
    // Remove type if already picked to avoid duplicates, except for potions/arrows
    if (!["potion", "arrows"].includes(t)) {
      shopTypes = shopTypes.filter(x => x !== t);
    }
    if (shopTypes.length === 0) shopTypes = types.slice();
  }

  window._shopItems = shopItems;
  renderShopItems();
}

// Patch buyShopItem to replace bought item with a new random item of same type
const origBuyShopItem = buyShopItem;
buyShopItem = function(idx) {
  let item = window._shopItems[idx];
  if (player.gold < item.price) {
    logMsg('Not enough gold!');
    return;
  }
  player.gold -= item.price;
  // If buying a full armor set, add all set items
  if (item.type === 'armor-set') {
    let baseDef = Math.floor(item.defense / 6);
    let baseHp = Math.floor(item.health / 6);
    let setItems = [
      { name: 'Set Armor', type: 'armor', defense: baseDef, health: baseHp, price: 0, description: 'Part of full set.' },
      { name: 'Set Helmet', type: 'helmet', defense: baseDef, health: baseHp, price: 0, description: 'Part of full set.' },
      { name: 'Set Gloves', type: 'gloves', defense: baseDef, health: baseHp, price: 0, description: 'Part of full set.' },
      { name: 'Set Boots', type: 'boots', defense: baseDef, health: baseHp, price: 0, description: 'Part of full set.' },
      { name: 'Set Cloak', type: 'cloak', defense: baseDef, health: baseHp, price: 0, description: 'Part of full set.' },
      { name: 'Set Shield', type: 'shield', defense: baseDef, price: 0, description: 'Part of full set.' }
    ];
    setItems.forEach(si => addItem(JSON.parse(JSON.stringify(si))));
    logMsg(`Bought Full Armor Set for ${item.price} gold from the Shop. All set items added!`);
  } else {
    addItem(JSON.parse(JSON.stringify(item)));
    logMsg(`Bought ${item.name} for ${item.price} gold from the Shop.`);
  }
  renderPlayerStats();

  // Replace bought item with a new random item of same type
  function generateItem(type) {
    // (same as above, but you can move the function outside if you want)
    switch (type) {
      case "armor": { let def = Math.floor(Math.random() * 106) + 20; let price = Math.floor(50 + (def - 20) * 8); return { name: `Armor`, type: 'armor', defense: def, price: price, description: `Protective armor.`, _shopStat: def }; }
      case "weapon": { let atk = Math.floor(Math.random() * 91) + 10; let price = Math.floor(30 + (atk - 10) * 5); return { name: `Weapon`, type: 'weapon', attackPower: atk, price: price, description: `A sharp weapon.`, _shopStat: atk }; }
      case "potion": { let heal = Math.floor(Math.random() * 81) + 20; let price = Math.floor(10 + (heal - 20) * 3); return { name: `Potion`, type: 'potion', heal: heal, price: price, description: `Heals for ${heal} HP.`, _shopStat: heal }; }
      case "helmet": { let def = Math.floor(Math.random() * 41) + 10; let hp = Math.floor(Math.random() * 61) + 20; let price = Math.floor(40 + def * 6 + hp * 2); return { name: `Helmet`, type: 'helmet', defense: def, health: hp, price: price, description: `Sturdy helmet.`, _shopStat: {def, hp} }; }
      case "boots": { let def = Math.floor(Math.random() * 31) + 10; let hp = Math.floor(Math.random() * 41) + 10; let price = Math.floor(30 + def * 5 + hp * 2); return { name: `Boots`, type: 'boots', defense: def, health: hp, price: price, description: `Protective boots.`, _shopStat: {def, hp} }; }
      case "shield": { let def = Math.floor(Math.random() * 41) + 20; let price = Math.floor(50 + def * 7); return { name: `Shield`, type: 'shield', defense: def, price: price, description: `Sturdy shield.`, _shopStat: def }; }
      case "cloak": { let def = Math.floor(Math.random() * 26) + 15; let hp = Math.floor(Math.random() * 41) + 10; let price = Math.floor(60 + def * 5 + hp * 2); return { name: `Cloak`, type: 'cloak', defense: def, health: hp, price: price, description: `Mystical cloak.`, _shopStat: {def, hp} }; }
      case "amulet": { let def = Math.floor(Math.random() * 16) + 5; let price = Math.floor(100 + def * 12); return { name: `Amulet`, type: 'amulet', defense: def, price: price, description: `Mystic amulet.`, _shopStat: def }; }
      case "ring": { let atk = Math.floor(Math.random() * 6) + 2; let hp = Math.floor(Math.random() * 51) + 10; let price = Math.floor(120 + atk * 20 + hp * 3); return { name: `Ring`, type: 'ring', attackPower: atk, health: hp, price: price, description: `Magical ring.`, _shopStat: {atk, hp} }; }
      case "gloves": { let def = Math.floor(Math.random() * 21) + 10; let hp = Math.floor(Math.random() * 31) + 10; let price = Math.floor(25 + def * 4 + hp * 2); return { name: `Gloves`, type: 'gloves', defense: def, health: hp, price: price, description: `Strong gloves.`, _shopStat: {def, hp} }; }
      case "full-armor-set": { let setDef = Math.floor(Math.random() * 101) + 100; let setHp = Math.floor(Math.random() * 201) + 200; let price = Math.floor(1000 + setDef * 15 + setHp * 5); return { name: `Full Armor Set`, type: 'armor-set', defense: setDef, health: setHp, price: Math.min(price, 5000), description: `Contains Armor, Helmet, Boots, Shield, Cloak, Gloves.`, _shopStat: {setDef, setHp} }; }
      case "arrows": return { name: 'Arrows', type: 'arrows', count: 100, price: 15, description: 'A pack of 100 arrows.', _shopStat: 100 };
      case "bow": { let batk = Math.floor(Math.random() * 131) + 20; let price = Math.floor(60 + (batk - 20) * 3.5); return { name: `Bow`, type: 'weapon', attackPower: batk, isBow: true, price: price, description: `A powerful bow.`, _shopStat: batk }; }
      default: return null;
    }
  }
  window._shopItems[idx] = generateItem(item.type);
  renderShopItems();
};
function renderShopItems() {
  const shopDiv = document.getElementById('shop-items-list');
  if (!window._shopItems) return;
  shopDiv.innerHTML = "";
  window._shopItems.forEach((item, idx) => {
    shopDiv.innerHTML += `
      <div class="shop-item-card" style="background:#18191c;border-radius:8px;padding:10px 14px;margin-bottom:8px;display:flex;align-items:center;justify-content:space-between;position:relative;cursor:pointer;">
        <b>${item.name}</b>
        <div>
          <span style="color:gold;font-weight:bold;">${item.price} Gold</span>
          <button onclick="buyShopItem(${idx})" style="margin-left:10px;background:#ffba3a;color:#23252a;border:none;border-radius:6px;padding:6px 18px;font-weight:bold;cursor:pointer;">Buy</button>
        </div>
        <div class="shop-item-tooltip" style="display:none;position:absolute;left:110%;top:50%;transform:translateY(-50%);background:#18191c;color:#eee;padding:7px 13px;border-radius:8px;border:1px solid #444;white-space:nowrap;font-size:0.98em;box-shadow:0 2px 10px #0007;z-index:20;min-width:160px;">
          ${getShopItemTooltip(item)}
        </div>
      </div>
    `;
  });
  function getShopItemTooltip(item) {
    let lines = [];
    // First line: name only (no stats)
    lines.push(`<b>${item.name}</b>`);
    // Second line: description
    if (item.description) lines.push(`<span style="color:#aaa;">${item.description}</span>`);
    // Stat line(s)
    if (item.type === "armor" && typeof item.defense === "number") lines.push(`DEF: <b>+${item.defense}</b>`);
    if (item.type === "weapon" && typeof item.attackPower === "number") lines.push(`ATK: <b>+${item.attackPower}</b>`);
    if (item.type === "potion" && typeof item.heal === "number") lines.push(`Heals: <b>+${item.heal}</b>`);
    if (item.type === "helmet" && item.defense && item.health) lines.push(`DEF: <b>+${item.defense}</b>, HP: <b>+${item.health}</b>`);
    if (item.type === "boots" && item.defense && item.health) lines.push(`DEF: <b>+${item.defense}</b>, HP: <b>+${item.health}</b>`);
    if (item.type === "shield" && item.defense) lines.push(`DEF: <b>+${item.defense}</b>`);
    if (item.type === "cloak" && item.defense && item.health) lines.push(`DEF: <b>+${item.defense}</b>, HP: <b>+${item.health}</b>`);
    if (item.type === "amulet" && item.defense) lines.push(`DEF: <b>+${item.defense}</b>`);
    if (item.type === "ring" && item.attackPower && item.health) lines.push(`ATK: <b>+${item.attackPower}</b>, HP: <b>+${item.health}</b>`);
    if (item.type === "gloves" && item.defense && item.health) lines.push(`DEF: <b>+${item.defense}</b>, HP: <b>+${item.health}</b>`);
    if (item.type === "armor-set" && item.defense && item.health) lines.push(`DEF: <b>+${item.defense}</b>, HP: <b>+${item.health}</b>`);
    if (item.type === "arrows" && item.count) lines.push(`Arrows: <b>x${item.count}</b>`);
    if (item.type === "bow" && item.attackPower) lines.push(`ATK: <b>+${item.attackPower}</b>`);
    // Type line
    if (item.type) lines.push(`<span style="color:#ffba3a;">Type: ${item.type.charAt(0).toUpperCase() + item.type.slice(1)}</span>`);
    return lines.join('<br>');
  }

  // Add hover logic for tooltips
  const cards = shopDiv.querySelectorAll('.shop-item-card');
  cards.forEach(card => {
    const tip = card.querySelector('.shop-item-tooltip');
    card.onmouseenter = () => { if (tip) tip.style.display = 'block'; };
    card.onmouseleave = () => { if (tip) tip.style.display = 'none'; };
    card.onmousemove = (e) => {
      if (tip) {
        tip.style.left = (e.offsetX + 30) + 'px';
        tip.style.top = (e.offsetY - 10) + 'px';
      }
    };
  });
}

// --- PATCH: Remove ( ... ) from item names only for display, not for storage ---
// Do NOT modify the item.name before storing; instead, only strip stats in the UI display code.
function buyShopItem(idx) {
  let item = window._shopItems[idx];
  if (player.gold < item.price) {
    logMsg('Not enough gold!');
    return;
  }
  player.gold -= item.price;
  // If buying a full armor set, add all set items
  if (item.type === 'armor-set') {
    let baseDef = Math.floor(item.defense / 6);
    let baseHp = Math.floor(item.health / 6);
    let setItems = [
      { name: 'Set Armor', type: 'armor', defense: baseDef, health: baseHp, price: 0, description: 'Part of full set.' },
      { name: 'Set Helmet', type: 'helmet', defense: baseDef, health: baseHp, price: 0, description: 'Part of full set.' },
      { name: 'Set Gloves', type: 'gloves', defense: baseDef, health: baseHp, price: 0, description: 'Part of full set.' },
      { name: 'Set Boots', type: 'boots', defense: baseDef, health: baseHp, price: 0, description: 'Part of full set.' },
      { name: 'Set Cloak', type: 'cloak', defense: baseDef, health: baseHp, price: 0, description: 'Part of full set.' },
      { name: 'Set Ring', type: 'ring', attackPower: 3, health: baseHp, price: 0, description: 'Part of full set.' }
    ];
    setItems.forEach(si => addItem(JSON.parse(JSON.stringify(si))));
    logMsg(`Bought Full Armor Set for ${item.price} gold from the Shop. All set items added!`);
  } else {
    addItem(JSON.parse(JSON.stringify(item)));
    logMsg(`Bought ${item.name} for ${item.price} gold from the Shop.`);
  }
  renderPlayerStats();
  renderShopItems();
}
document.getElementById('refresh-shop-btn').onclick = refreshShopItems;
refreshShopItems();

// --- SPECIAL SELLER: Only once per town, mark with checkmark ---
let visitedTowns = {};
const origShowTownPopup = showTownPopup;
showTownPopup = function(townName) {
  lastTownVisited = townName;
  document.getElementById('town-popup-title').textContent = `You arrived at ${townName}!`;
  document.getElementById('town-popup').style.display = 'flex';
};
document.getElementById('town-popup-yes').onclick = function() {
  document.getElementById('town-popup').style.display = 'none';
  if (!visitedTowns[lastTownVisited]) {
    showSpecialSeller();
    visitedTowns[lastTownVisited] = true;
    renderMap();
  }
};
document.getElementById('town-popup-no').onclick = function() {
  document.getElementById('town-popup').style.display = 'none';
};
// --- START GAME BUTTON LOGIC ---
const usernameSubmitBtnOld = document.getElementById('username-submit');
if (usernameSubmitBtnOld) {
    usernameSubmitBtnOld.onclick = function() {
    const input = document.getElementById('username-input');
    const error = document.getElementById('username-error');
    const val = input.value.trim();
    if (!val) {
      error.textContent = 'Please enter a username.';
      error.style.display = 'block';
      return;
  }
  player.name = val;
  error.style.display = 'none';
  document.getElementById('username-overlay').style.display = 'none';

  // Initialize map and player position before rendering
  initMap();
  playerPosition = { x: Math.floor(mapSize/2), y: Math.floor(mapSize/2) };
  discovered[playerPosition.y][playerPosition.x] = true;

  renderPlayerStats();
  renderDerivedStats();
  renderEquipment();
  renderBagInv();
  renderMap();

  // Play music if available
  const music = document.getElementById('username-music');
  if (music) {
    music.currentTime = 0;
    music.play().catch(() => {
      document.body.addEventListener('click', () => music.play(), { once: true });
    });
  }
};
}
function showSpecialSeller() {
  // Generate 6 random high-stat items under 500 gold
  let specialItems = [];
  for (let i = 0; i < 6; ++i) {
    let type = ["armor", "weapon", "potion", "helmet", "boots", "shield", "cloak", "amulet", "ring", "gloves"][Math.floor(Math.random()*10)];
    let item = { price: Math.floor(Math.random()*200)+250 };
    if (type === "armor") {
      item.name = "Special Armor";
      item.type = "armor";
      item.defense = Math.floor(Math.random()*30)+50;
      item.description = "A rare armor with high defense.";
    } else if (type === "weapon") {
      item.name = "Special Sword";
      item.type = "weapon";
      item.attackPower = Math.floor(Math.random()*20)+45;
      item.description = "A powerful sword with high attack.";
    } else if (type === "potion") {
      item.name = "Mega Potion";
      item.type = "potion";
      item.heal = Math.floor(Math.random()*50)+100;
      item.description = "Heals a large amount of health.";
    } else if (type === "helmet") {
      item.name = "Special Helmet";
      item.type = "helmet";
      item.defense = Math.floor(Math.random()*15)+25;
      item.health = Math.floor(Math.random()*30)+25;
      item.description = "A sturdy helmet for protection.";
    } else if (type === "boots") {
      item.name = "Special Boots";
      item.type = "boots";
      item.defense = Math.floor(Math.random()*10)+20;
      item.health = Math.floor(Math.random()*20)+20;
      item.description = "Boots that boost defense and health.";
    } else if (type === "shield") {
      item.name = "Special Shield";
      item.type = "shield";
      item.defense = Math.floor(Math.random()*20)+30;
      item.description = "A shield with excellent defense.";
    } else if (type === "cloak") {
      item.name = "Special Cloak";
      item.type = "cloak";
      item.defense = Math.floor(Math.random()*15)+30;
      item.health = Math.floor(Math.random()*20)+20;
      item.description = "A mystical cloak for defense and health.";
    } else if (type === "amulet") {
      item.name = "Special Amulet";
      item.type = "amulet";
      item.defense = Math.floor(Math.random()*10)+15;
      item.description = "A magical amulet for extra defense.";
    } else if (type === "ring") {
      item.name = "Special Ring";
      item.type = "ring";
      item.attackPower = Math.floor(Math.random()*5)+5;
      item.health = Math.floor(Math.random()*20)+10;
      item.description = "A ring that boosts attack and health.";
    } else if (type === "gloves") {
      item.name = "Special Gloves";
      item.type = "gloves";
      item.defense = Math.floor(Math.random()*10)+15;
      item.health = Math.floor(Math.random()*20)+10;
      item.description = "Gloves that increase defense and health.";
    }
    item.price = Math.min(item.price, 499);
    item._noReroll = true; // Prevent stat reroll on addItem
    specialItems.push(item);
  }
  let html = '';
  specialItems.forEach((item, idx) => {
    // Tooltip content
    let tooltip = `<b>${item.name}</b>`;
    if (item.description) tooltip += `<br><span style='color:#aaa;'>${item.description}</span>`;
    if (item.attackPower) tooltip += `<br>ATK: <b>+${item.attackPower}</b>`;
    if (item.defense) tooltip += `<br>DEF: <b>+${item.defense}</b>`;
    if (item.heal) tooltip += `<br>Heals: <b>+${item.heal}</b>`;
    if (item.health) tooltip += `<br>HP: <b>+${item.health}</b>`;
    if (item.type) tooltip += `<br><span style="color:#ffba3a;">Type: ${item.type.charAt(0).toUpperCase() + item.type.slice(1)}</span>`;
    html += `
      <div class="special-seller-item" style="background:#18191c;border-radius:8px;padding:10px 14px;margin-bottom:8px;display:flex;align-items:center;justify-content:space-between;position:relative;cursor:pointer;">
        <div style="position:relative;">
          <b>${item.name}</b>
          <div class="special-seller-tooltip" style="display:none;position:absolute;left:110%;top:50%;transform:translateY(-50%);background:#18191c;color:#eee;padding:7px 13px;border-radius:8px;border:1px solid #444;white-space:nowrap;font-size:0.98em;box-shadow:0 2px 10px #0007;z-index:20;min-width:160px;">
            ${tooltip}
          </div>
        </div>
        <div>
          <span style="color:gold;font-weight:bold;">${item.price} Gold</span>
          <button onclick="window.buySpecialSellerItem(${idx})" style="margin-left:10px;background:#ffba3a;color:#23252a;border:none;border-radius:6px;padding:6px 18px;font-weight:bold;cursor:pointer;">Buy</button>
        </div>
      </div>
    `;
  });
  window._specialSellerItems = specialItems;
  document.getElementById('special-seller-items').innerHTML = html;
  document.getElementById('special-seller-popup').style.display = 'flex';

  // Tooltip hover logic
  const sellerItems = document.querySelectorAll('.special-seller-item');
  sellerItems.forEach(itemDiv => {
    const tip = itemDiv.querySelector('.special-seller-tooltip');
    itemDiv.onmouseenter = () => { if (tip) tip.style.display = 'block'; };
    itemDiv.onmouseleave = () => { if (tip) tip.style.display = 'none'; };
    itemDiv.onmousemove = (e) => {
      if (tip) {
        tip.style.left = (e.offsetX + 30) + 'px';
        tip.style.top = (e.offsetY - 10) + 'px';
      }
    };
  });
}

// Make buySpecialSellerItem and closeSpecialSeller globally available
window.buySpecialSellerItem = function(itemIndex) {
  let item = window._specialSellerItems[itemIndex];
  if (!item) return;
  if (player.gold < item.price) {
    logMsg('Not enough gold!');
    return;
  }
  player.gold -= item.price;
  let itemCopy = JSON.parse(JSON.stringify(item));
  itemCopy._noReroll = true; // Ensure no reroll on addItem
  addItem(itemCopy);
  logMsg(`Bought ${item.name} for ${item.price} gold from the Special Seller.`);
  renderPlayerStats();
  closeSpecialSeller();
};

window.closeSpecialSeller = function() {
  document.getElementById('special-seller-popup').style.display = 'none';
};

// --- Enhanced Save/Load Game System with Validation ---
// Save button logic: saves complete game state + validation file
document.getElementById('main-save-btn').onclick = function() {
  try {
    const dateStr = new Date().toISOString().replace(/[:.]/g, '-');
    
    // Complete game save data (everything except map)
    const saveData = {
      player: {
        name: player.name,
        health: player.health,
        maxHealth: player.maxHealth,
        gold: player.gold,
        experience: player.experience,
        level: player.level,
        bankGold: player.bankGold,
        prayer: (typeof player.prayer !== 'undefined') ? player.prayer : 50,
        maxPrayer: (typeof player.maxPrayer !== 'undefined') ? player.maxPrayer : 50,
        inventory: JSON.parse(JSON.stringify(player.inventory || [])),
        bag: JSON.parse(JSON.stringify(player.bag || [])),
        equipment: JSON.parse(JSON.stringify(player.equipment || {})),
        bank: JSON.parse(JSON.stringify(player.bank || [])),
        class: player.class
      },
      visitedTowns: JSON.parse(JSON.stringify(visitedTowns || {})),
      playerPosition: JSON.parse(JSON.stringify(playerPosition || {x: 9, y: 9})),
      gameState: {
        prayerDeflectActive: (typeof prayerDeflectActive !== 'undefined') ? prayerDeflectActive : false,
        prayerHealActive: (typeof prayerHealActive !== 'undefined') ? prayerHealActive : false,
        movesSinceLastTunnel: (typeof movesSinceLastTunnel !== 'undefined') ? movesSinceLastTunnel : 0,
        nextTunnelMove: (typeof nextTunnelMove !== 'undefined') ? nextTunnelMove : 10
      }
      // Exclude mapData, discovered, towns, chests - these reset on load
    };
    
    // Validation data (only critical stats for cheat detection)
    const lastGameValues = {
      gold: player.gold,
      level: player.level,
      experience: player.experience,
      bankGold: player.bankGold,
      prayer: (typeof player.prayer !== 'undefined') ? player.prayer : 50,
      maxPrayer: (typeof player.maxPrayer !== 'undefined') ? player.maxPrayer : 50,
      maxHealth: player.maxHealth,
      saveTimestamp: Date.now(),
      checksum: btoa((player.gold + player.level + player.experience + player.bankGold).toString())
    };
    
    // Save main game file
    const blob = new Blob([JSON.stringify(saveData, null, 2)], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `game-ui-save-${dateStr}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    // Save validation file
    const validationBlob = new Blob([JSON.stringify(lastGameValues, null, 2)], {type: "application/json"});
    const validationUrl = URL.createObjectURL(validationBlob);
    const validationA = document.createElement('a');
    validationA.href = validationUrl;
    validationA.download = `last-game-values (${Math.floor(Date.now()/1000)}).json`;
    document.body.appendChild(validationA);
    validationA.click();
    document.body.removeChild(validationA);
    URL.revokeObjectURL(validationUrl);
    
    alert('Game saved! Two files downloaded:\n1. Complete save file\n2. Validation file (last-game-values)');
  } catch (error) {
    console.error('Save error:', error);
    alert('Failed to save game: ' + error.message + '\nCheck console for details.');
  }
};

// Enhanced Load System with Validation
document.getElementById('main-load-btn').onclick = function() {
  document.getElementById('main-load-input').click();
};

// Add a file input for loading (used by overlay Load button)
if (!document.getElementById('main-load-input')) {
  const loadInput = document.createElement('input');
  loadInput.type = 'file';
  loadInput.accept = '.json,application/json';
  loadInput.style.display = 'none';
  loadInput.id = 'main-load-input';
  loadInput.multiple = true; // Allow multiple file selection
  document.body.appendChild(loadInput);

  loadInput.addEventListener('change', function(e) {
    const files = Array.from(e.target.files);
    if (files.length === 0) return;
    
    let saveFile = null;
    let validationFile = null;
    
    // Identify files by name pattern
    files.forEach(file => {
      if (file.name.includes('game-ui-save') || file.name.includes('game-save')) {
        saveFile = file;
      } else if (file.name.includes('last-game-values')) {
        validationFile = file;
      }
    });
    
    if (!saveFile) {
      // If only one file selected, assume it's the save file (backward compatibility)
      if (files.length === 1) {
        saveFile = files[0];
        loadGameWithoutValidation(saveFile);
        return;
      } else {
        alert('Please select the main save file (game-ui-save-*.json)');
        return;
      }
    }
    
    if (!validationFile) {
      // Ask user if they want to load without validation
      if (confirm('No validation file found. Load without corruption checking?\n\nNote: This means edited save values cannot be detected.')) {
        loadGameWithoutValidation(saveFile);
      }
      return;
    }
    
    // Load both files and validate
    loadGameWithValidation(saveFile, validationFile);
    
    // Reset input
    e.target.value = '';
  });
}

function loadGameWithoutValidation(saveFile) {
  const reader = new FileReader();
  reader.onload = function(evt) {
    try {
      const saveData = JSON.parse(evt.target.result);
      applyGameSave(saveData);
      alert('Game loaded successfully (no validation performed)!');
    } catch (err) {
      alert('Failed to load save: ' + err.message);
    }
  };
  reader.readAsText(saveFile);
}

function loadGameWithValidation(saveFile, validationFile) {
  let saveData = null;
  let validationData = null;
  let filesLoaded = 0;
  
  // Load save file
  const saveReader = new FileReader();
  saveReader.onload = function(evt) {
    try {
      saveData = JSON.parse(evt.target.result);
      filesLoaded++;
      if (filesLoaded === 2) validateAndLoad(saveData, validationData);
    } catch (err) {
      alert('Failed to load save file: ' + err.message);
    }
  };
  saveReader.readAsText(saveFile);
  
  // Load validation file
  const validationReader = new FileReader();
  validationReader.onload = function(evt) {
    try {
      validationData = JSON.parse(evt.target.result);
      filesLoaded++;
      if (filesLoaded === 2) validateAndLoad(saveData, validationData);
    } catch (err) {
      alert('Failed to load validation file: ' + err.message);
    }
  };
  validationReader.readAsText(validationFile);
}

function validateAndLoad(saveData, validationData) {
  // Check for corruption/editing
  const player = saveData.player;
  const validation = validationData;
  
  let corruption = [];
  
  // Check critical values
  if (player.gold !== validation.gold) {
    corruption.push(`Gold: Save=${player.gold}, Expected=${validation.gold}`);
  }
  if (player.level !== validation.level) {
    corruption.push(`Level: Save=${player.level}, Expected=${validation.level}`);
  }
  if (player.experience !== validation.experience) {
    corruption.push(`Experience: Save=${player.experience}, Expected=${validation.experience}`);
  }
  if (player.bankGold !== validation.bankGold) {
    corruption.push(`Bank Gold: Save=${player.bankGold}, Expected=${validation.bankGold}`);
  }
  if ((player.prayer || 50) !== validation.prayer) {
    corruption.push(`Prayer: Save=${player.prayer || 50}, Expected=${validation.prayer}`);
  }
  if ((player.maxPrayer || 50) !== validation.maxPrayer) {
    corruption.push(`Max Prayer: Save=${player.maxPrayer || 50}, Expected=${validation.maxPrayer}`);
  }
  
  // Check checksum
  const currentChecksum = btoa((player.gold + player.level + player.experience + player.bankGold).toString());
  if (currentChecksum !== validation.checksum) {
    corruption.push(`Checksum mismatch: Save values have been modified`);
  }
  
  if (corruption.length > 0) {
    // Show corruption warning
    showCorruptionWarning(corruption, saveData, validationData);
  } else {
    // Safe to load
    applyGameSave(saveData);
    alert('‚úÖ Game loaded successfully! Save file integrity verified.');
  }
}

function showCorruptionWarning(corruption, saveData, validationData) {
  // Create devious corruption popup
  const popup = document.createElement('div');
  popup.id = 'corruption-warning-popup';
  popup.style = 'position:fixed;z-index:99999;top:0;left:0;width:100vw;height:100vh;background:#000000ee;display:flex;align-items:center;justify-content:center;font-family:monospace;';
  popup.innerHTML = `
    <div style="background:linear-gradient(135deg,#1a0000 0%,#330000 50%,#1a0000 100%);border:3px solid #ff0000;border-radius:15px;padding:40px;max-width:600px;width:90%;box-shadow:0 0 50px #ff000088,inset 0 0 20px #ff000033;animation:corruptGlow 2s infinite alternate;">
      <div style="text-align:center;margin-bottom:30px;">
        <div style="font-size:4em;color:#ff0000;margin-bottom:10px;text-shadow:0 0 20px #ff0000;animation:corruptPulse 1s infinite;">‚ö†Ô∏èüíÄ‚ö†Ô∏è</div>
        <div style="color:#ff4444;font-size:2em;font-weight:bold;text-shadow:0 2px 10px #000;margin-bottom:15px;">CORRUPTION DETECTED</div>
        <div style="color:#ffaaaa;font-size:1.2em;text-shadow:0 1px 5px #000;">Save file has been tampered with!</div>
      </div>
      
      <div style="background:#220000;border:1px solid #ff0000;border-radius:8px;padding:20px;margin-bottom:25px;max-height:200px;overflow-y:auto;">
        <div style="color:#ff6666;font-weight:bold;margin-bottom:15px;">üîç DETECTED MODIFICATIONS:</div>
        ${corruption.map(c => `<div style="color:#ffcccc;margin-bottom:8px;font-size:0.95em;">‚Ä¢ ${c}</div>`).join('')}
      </div>
      
      <div style="color:#ffaaaa;text-align:center;margin-bottom:25px;font-size:1.1em;line-height:1.4;">
        <div style="color:#ff6666;font-weight:bold;margin-bottom:10px;">‚ö° WARNING ‚ö°</div>
        Editing save files compromises game integrity.<br>
        The save has been modified from its original state.<br>
        <span style="color:#ff4444;font-weight:bold;">Continue at your own risk!</span>
      </div>
      
      <div style="display:flex;gap:15px;justify-content:center;">
        <button id="corruption-load-anyway" style="background:#660000;color:#ff9999;border:2px solid #ff0000;border-radius:8px;padding:12px 25px;cursor:pointer;font-weight:bold;font-size:1em;">Load Anyway</button>
        <button id="corruption-cancel" style="background:#333;color:#fff;border:2px solid #666;border-radius:8px;padding:12px 25px;cursor:pointer;font-weight:bold;font-size:1em;">Cancel</button>
      </div>
    </div>
    
    <style>
      @keyframes corruptGlow {
        0% { box-shadow: 0 0 30px #ff000066, inset 0 0 15px #ff000022; }
        100% { box-shadow: 0 0 60px #ff0000aa, inset 0 0 25px #ff000044; }
      }
      @keyframes corruptPulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); }
      }
    </style>
  `;
  
  document.body.appendChild(popup);
  
  document.getElementById('corruption-load-anyway').onclick = function() {
    popup.remove();
    applyGameSave(saveData);
    alert('‚ö†Ô∏è Corrupted save loaded. Game integrity may be compromised.');
  };
  
  document.getElementById('corruption-cancel').onclick = function() {
    popup.remove();
    alert('Load cancelled. Please use an unmodified save file.');
  };
}

function applyGameSave(saveData) {
  if (saveData.player && saveData.visitedTowns && saveData.playerPosition) {
    // Defensive deep assignment to avoid undefined errors
    initMap(); // Ensure mapData, discovered, towns, chests are initialized
    
    // Load player data
    player.name = saveData.player.name || "Hero";
    player.health = typeof saveData.player.health === "number" ? saveData.player.health : 100;
    player.maxHealth = typeof saveData.player.maxHealth === "number" ? saveData.player.maxHealth : 100;
    player.gold = typeof saveData.player.gold === "number" ? saveData.player.gold : 0;
    player.experience = typeof saveData.player.experience === "number" ? saveData.player.experience : 0;
    player.level = typeof saveData.player.level === "number" ? saveData.player.level : 1;
    player.bankGold = typeof saveData.player.bankGold === "number" ? saveData.player.bankGold : 0;
    player.prayer = typeof saveData.player.prayer === "number" ? saveData.player.prayer : 50;
    player.maxPrayer = typeof saveData.player.maxPrayer === "number" ? saveData.player.maxPrayer : 50;
    player.class = saveData.player.class || "Warrior";
    
    // Load arrays and objects
    player.inventory = Array.isArray(saveData.player.inventory) ? JSON.parse(JSON.stringify(saveData.player.inventory)) : [];
    player.bag = Array.isArray(saveData.player.bag) ? JSON.parse(JSON.stringify(saveData.player.bag)) : [];
    player.equipment = typeof saveData.player.equipment === "object" && saveData.player.equipment !== null
      ? JSON.parse(JSON.stringify(saveData.player.equipment))
      : { helmet: null, weapon: null, armor: null, ring: null, arrows: null, cloak: null, shield: null, amulet: null, gloves: null, boots: null };
    player.bank = Array.isArray(saveData.player.bank) ? JSON.parse(JSON.stringify(saveData.player.bank)) : [];
    
    // Load game state
    Object.keys(visitedTowns).forEach(k => delete visitedTowns[k]);
    Object.assign(visitedTowns, saveData.visitedTowns);
    playerPosition.x = typeof saveData.playerPosition.x === "number" ? saveData.playerPosition.x : Math.floor(mapSize/2);
    playerPosition.y = typeof saveData.playerPosition.y === "number" ? saveData.playerPosition.y : Math.floor(mapSize/2);
    
    // Load additional game state
    if (saveData.gameState) {
      prayerDeflectActive = saveData.gameState.prayerDeflectActive || false;
      prayerHealActive = saveData.gameState.prayerHealActive || false;
      movesSinceLastTunnel = saveData.gameState.movesSinceLastTunnel || 0;
      nextTunnelMove = saveData.gameState.nextTunnelMove || 10;
    }
    
    // Ensure discovered array is properly sized (map always resets)
    if (!Array.isArray(discovered) || discovered.length !== mapSize) {
      discovered = [];
      for (let y = 0; y < mapSize; ++y) {
        let drow = [];
        for (let x = 0; x < mapSize; ++x) drow.push(false);
        discovered.push(drow);
      }
    }
    if (!Array.isArray(discovered[playerPosition.y])) {
      discovered[playerPosition.y] = [];
      for (let x = 0; x < mapSize; ++x) discovered[playerPosition.y][x] = false;
    }
    discovered[playerPosition.y][playerPosition.x] = true;
    
    // Refresh UI
    renderPlayerStats();
    renderDerivedStats();
    renderEquipment();
    renderBagInv();
    renderMap();
    if (typeof updatePrayerUI === "function") updatePrayerUI();
    
    // Hide overlay if loading from overlay
    if (document.getElementById('username-overlay').style.display !== 'none') {
      document.getElementById('username-overlay').style.display = 'none';
      const overlayLoadBtn2 = document.getElementById('overlay-load-btn2');
      if (overlayLoadBtn2) overlayLoadBtn2.style.display = 'none';
    }
  } else {
    alert('Invalid save file format.');
  }
}

// Overlay Load UI in overlay, right below Stop Music
if (document.getElementById('username-overlay')) {
  const overlayDiv = document.querySelector('#username-overlay > div');
  if (overlayDiv && !document.getElementById('overlay-load-btn2')) {
    // Create Load UI
    const saveLoadDiv = document.createElement('div');
    saveLoadDiv.id = 'overlay-save-load-ui';
    saveLoadDiv.style.display = 'flex';
    saveLoadDiv.style.gap = '8px';
    saveLoadDiv.style.alignItems = 'center';
    saveLoadDiv.style.marginBottom = '18px';

    // Load button (triggers file input)
    const loadBtn = document.createElement('button');
    loadBtn.id = 'overlay-load-btn2';
    loadBtn.textContent = 'Load Save';
    loadBtn.style.fontWeight = 'bold';
    loadBtn.style.fontSize = '1em';
    loadBtn.style.background = '#35373e';
    loadBtn.style.color = '#ffba3a';
    loadBtn.style.border = 'none';
    loadBtn.style.borderRadius = '6px';
    loadBtn.style.padding = '6px 18px';
    loadBtn.style.cursor = 'pointer';
    loadBtn.onclick = function() {
      document.getElementById('main-load-input').click();
    };

    saveLoadDiv.appendChild(loadBtn);

    // Insert right below Stop Music button (after the two music buttons)
    const musicBtns = overlayDiv.querySelectorAll('button');
    if (musicBtns.length >= 2) {
      musicBtns[1].after(saveLoadDiv);
    } else {
      overlayDiv.prepend(saveLoadDiv);
    }
  }
}

// Hide overlay load button after starting game
const usernameSubmitBtn = document.getElementById('username-submit');
if (usernameSubmitBtn) {
  usernameSubmitBtn.addEventListener('click', function() {
    const overlayLoadBtn = document.getElementById('overlay-load-btn2');
    if (overlayLoadBtn) overlayLoadBtn.style.display = 'none';
  });
}
/* --- MUSIC BUTTON IN MAIN UI (top left, by Save) --- */
if (!document.getElementById('main-music-btn')) {
  // Create music button
  const musicBtn = document.createElement('button');
  musicBtn.id = 'main-music-btn';
  musicBtn.title = 'Toggle Music';
  musicBtn.style.fontWeight = 'bold';
  musicBtn.style.fontSize = '1.2em';
  musicBtn.style.background = '#35373e';
  musicBtn.style.color = '#ffba3a';
  musicBtn.style.border = 'none';
  musicBtn.style.borderRadius = '6px';
  musicBtn.style.padding = '6px 12px';
  musicBtn.style.cursor = 'pointer';
  musicBtn.style.marginRight = '6px';
  musicBtn.innerHTML = 'üéµ';

  // Insert before Save button in #main-save-ui
  const saveUi = document.getElementById('main-save-ui');
  if (saveUi && saveUi.firstChild) {
    saveUi.insertBefore(musicBtn, saveUi.firstChild);
  }

  // Toggle music play/pause
  musicBtn.onclick = function() {
    // Prefer uploaded audio if loaded and visible
    const uploadedAudio = document.getElementById('uploaded-audio');
    const music = document.getElementById('username-music');
    let audioToControl = null;
    if (uploadedAudio && uploadedAudio.src && uploadedAudio.style.display !== "none") {
      audioToControl = uploadedAudio;
    } else if (music) {
      audioToControl = music;
    }
    if (!audioToControl) return;
    if (audioToControl.paused) {
      audioToControl.play().catch(() => {
        document.body.addEventListener('click', () => audioToControl.play(), { once: true });
      });
      musicBtn.style.background = '#ffba3a';
      musicBtn.style.color = '#23252a';
    } else {
      audioToControl.pause();
      musicBtn.style.background = '#35373e';
      musicBtn.style.color = '#ffba3a';
    }
  };

  // Set initial state based on music
  const uploadedAudio = document.getElementById('uploaded-audio');
  const music = document.getElementById('username-music');
  if ((uploadedAudio && uploadedAudio.src && uploadedAudio.style.display !== "none" && !uploadedAudio.paused) ||
      (music && !music.paused)) {
    musicBtn.style.background = '#ffba3a';
    musicBtn.style.color = '#23252a';
  }
}



// Helper: generate tooltip HTML for an item
function getItemTooltip(item) {
  let lines = [];
  lines.push(`<b>${item.name}</b>`);
  if (item.description) lines.push(`<span style="color:#aaa;">${item.description}</span>`);
  if (item.attackPower) lines.push(`ATK: <b>+${item.attackPower}</b>`);
  if (item.defense) lines.push(`DEF: <b>+${item.defense}</b>`);
  if (item.health) lines.push(`HP: <b>+${item.health}</b>`);
  if (item.heal) lines.push(`Heals: <b>+${item.heal}</b>`);
  if (item.count && item.type === "arrows") lines.push(`Arrows: <b>x${item.count}</b>`);
  if (item.type) lines.push(`<span style="color:#ffba3a;">Type: ${item.type.charAt(0).toUpperCase() + item.type.slice(1)}</span>`);
  return lines.join('<br>');
}

// Patch renderBagInv to add tooltip to each item-card
const origRenderBagInv = renderBagInv;
renderBagInv = function() {
  origRenderBagInv();
  // Add tooltip event listeners to all .item-card
  const cards = document.querySelectorAll('#baginv-content .item-card');
  let itemsArr = baginvTab === "inventory" ? player.inventory : player.bag;
  cards.forEach((card, idx) => {
    // Remove any existing tooltip
    let oldTip = card.querySelector('.item-tooltip');
    if (oldTip) oldTip.remove();

    // Create tooltip div
    const tooltip = document.createElement('div');
    tooltip.className = 'item-tooltip';
    tooltip.style.display = 'none';
    tooltip.style.position = 'absolute';
    tooltip.style.left = '110%';
    tooltip.style.top = '50%';
    tooltip.style.transform = 'translateY(-50%)';
    tooltip.style.background = '#18191c';
    tooltip.style.color = '#eee';
    tooltip.style.padding = '7px 13px';
    tooltip.style.borderRadius = '8px';
    tooltip.style.border = '1px solid #444';
    tooltip.style.whiteSpace = 'nowrap';
    tooltip.style.fontSize = '0.98em';
    tooltip.style.boxShadow = '0 2px 10px #0007';
    tooltip.style.zIndex = '10';
    tooltip.style.minWidth = '160px';
    tooltip.innerHTML = getItemTooltip(itemsArr[idx]);
    card.appendChild(tooltip);

    // Show/hide on hover
    card.onmouseenter = () => { tooltip.style.display = 'block'; };
    card.onmouseleave = () => { tooltip.style.display = 'none'; };
    card.onmousemove = (e) => {
      // Optional: move tooltip with mouse
      tooltip.style.left = (e.offsetX + 30) + 'px';
      tooltip.style.top = (e.offsetY - 10) + 'px';
    };
  });
};

// Add tooltip CSS
const style = document.createElement('style');
style.textContent = `
  .item-card { position: relative; }
  .item-tooltip {
    pointer-events: none;
    opacity: 0.98;
    transition: opacity 0.12s;
  }
`;
document.head.appendChild(style);

/*
  --- AUTO ATTACK BUTTON FOR ENEMY ENCOUNTER ---
  Adds a button (‚öîÔ∏è‚öîÔ∏è) to auto-attack the enemy until one side is defeated or the player cancels.
*/

// Add the auto-attack button to the enemy controls UI
function addAutoAttackButton() {
  const controls = document.getElementById('enemy-controls');
  if (!controls) return;
  // Prevent duplicate button
  if (document.getElementById('auto-attack-btn')) return;
  const btn = document.createElement('button');
  btn.className = 'enemy-action-btn';
  btn.id = 'auto-attack-btn';
  btn.innerHTML = '‚öîÔ∏è Auto Attack ‚öîÔ∏è';
  btn.style.fontWeight = 'bold';
  btn.onclick = startAutoAttack;
  controls.appendChild(btn);
}

// Remove the auto-attack button (e.g., after combat ends)
function removeAutoAttackButton() {
  const btn = document.getElementById('auto-attack-btn');
  if (btn && btn.parentNode) btn.parentNode.removeChild(btn);
}

// Auto-attack logic
let autoAttackActive = false;
function startAutoAttack() {
  if (!currentEnemy || !inCombat) return;
  autoAttackActive = true;
  // Change button to "Cancel Auto"
  const btn = document.getElementById('auto-attack-btn');
  if (btn) {
    btn.textContent = '‚ùå Cancel Auto';
    btn.onclick = stopAutoAttack;
    btn.style.background = '#ff4444';
    btn.style.color = '#fff';
  }
  autoAttackLoop();
}
function stopAutoAttack() {
  autoAttackActive = false;
  // Restore button
  const btn = document.getElementById('auto-attack-btn');
  if (btn) {
    btn.textContent = '‚öîÔ∏è Auto Attack ‚öîÔ∏è';
    btn.onclick = startAutoAttack;
    btn.style.background = '';
    btn.style.color = '';
  }
}

// Loop: attack, wait, repeat if still in combat and autoAttackActive
function autoAttackLoop() {
  if (!autoAttackActive || !currentEnemy || !inCombat) {
    stopAutoAttack();
    return;
  }
  // Only attack if enemy and player are alive
  if (currentEnemy.health > 0 && player.health > 0) {
    attackEnemy();
    // Wait for enemy attack animation, then repeat
    setTimeout(() => {
      if (currentEnemy && currentEnemy.health > 0 && player.health > 0 && inCombat && autoAttackActive) {
        autoAttackLoop();
      } else {
        stopAutoAttack();
      }
    }, 900);
  } else {
    stopAutoAttack();
  }
}

// Patch renderEnemyEncounter to add/remove the button
const origRenderEnemyEncounter = renderEnemyEncounter;
renderEnemyEncounter = function() {
  origRenderEnemyEncounter();
  if (currentEnemy && inCombat) {
    addAutoAttackButton();
  } else {
    removeAutoAttackButton();
    autoAttackActive = false;
  }
};

// Also stop auto-attack if player runs away or dies
const origClearEnemy = clearEnemy;
clearEnemy = function() {
  autoAttackActive = false;
  removeAutoAttackButton();
  origClearEnemy();
};
/*
  --- PATCH: Robust Save/Load Error Handling ---
  Ensures save files are saved and loaded correctly, with user-friendly error messages.
*/

// Patch save button to catch errors
const origMainSaveBtn = document.getElementById('main-save-btn').onclick;
document.getElementById('main-save-btn').onclick = function() {
  try {
    origMainSaveBtn && origMainSaveBtn();
  } catch (e) {

  }
};

// Patch load input to catch errors and validate file structure
const mainLoadInput = document.getElementById('main-load-input');
if (mainLoadInput) {
  const origLoadHandler = mainLoadInput.onchange || null;
  mainLoadInput.onchange = function(e) {
    try {
      const file = e.target.files[0];
   
      const reader = new FileReader();
      reader.onload = function(evt) {
        try {
          const saveData = JSON.parse(evt.target.result);
          if (
            !saveData.player ||
            typeof saveData.player !== 'object' ||
            !saveData.visitedTowns ||
            typeof saveData.visitedTowns !== 'object' ||
            !saveData.playerPosition ||
            typeof saveData.playerPosition !== 'object'
          ) {
            throw new Error('Invalid save file structure.');
          }
          // --- RESET MAP: all towns unvisited, everything reset ---
          initMap();
          Object.keys(visitedTowns).forEach(k => delete visitedTowns[k]);
          // Defensive assignment as before
          player.name = saveData.player.name || "Hero";
          player.health = typeof saveData.player.health === "number" ? saveData.player.health : 100;
          player.maxHealth = typeof saveData.player.maxHealth === "number" ? saveData.player.maxHealth : 100;
          player.gold = typeof saveData.player.gold === "number" ? saveData.player.gold : 0;
          player.experience = typeof saveData.player.experience === "number" ? saveData.player.experience : 0;
          player.level = typeof saveData.player.level === "number" ? saveData.player.level : 1;
          player.bankGold = typeof saveData.player.bankGold === "number" ? saveData.player.bankGold : 0;
          player.inventory = Array.isArray(saveData.player.inventory) ? JSON.parse(JSON.stringify(saveData.player.inventory)) : [];
          player.bag = Array.isArray(saveData.player.bag) ? JSON.parse(JSON.stringify(saveData.player.bag)) : [];
          player.equipment = typeof saveData.player.equipment === "object" && saveData.player.equipment !== null
            ? JSON.parse(JSON.stringify(saveData.player.equipment))
            : { helmet: null, weapon: null, armor: null, ring: null, arrows: null, cloak: null, shield: null, amulet: null, gloves: null, boots: null };
          player.bank = Array.isArray(saveData.player.bank) ? JSON.parse(JSON.stringify(saveData.player.bank)) : [];
          // Always default player to central town on load
          playerPosition.x = Math.floor(mapSize/2);
          playerPosition.y = Math.floor(mapSize/2);
          discovered[playerPosition.y][playerPosition.x] = true;
          renderPlayerStats();
          renderDerivedStats();
          renderEquipment();
          renderBagInv();
          renderMap();
          alert('Game loaded from file! Map has been reset and player is at Central Town.');
          if (document.getElementById('username-overlay').style.display !== 'none') {
            document.getElementById('username-overlay').style.display = 'none';
            const overlayLoadBtn2 = document.getElementById('overlay-load-btn2');
            if (overlayLoadBtn2) overlayLoadBtn2.style.display = 'none';
          }
        } catch (err) {
          alert('Your file has loaded!: ' + (err && err.message ? err.message : err));
        }
      };
      reader.readAsText(file);
      e.target.value = '';
    } catch (err) {
    
    }
    if (origLoadHandler) origLoadHandler.call(this, e);
  };
}

// Always default player to central town on refresh
window.addEventListener('DOMContentLoaded', function() {
  playerPosition.x = Math.floor(mapSize/2);
  playerPosition.y = Math.floor(mapSize/2);
  if (Array.isArray(discovered) && Array.isArray(discovered[playerPosition.y])) {
    discovered[playerPosition.y][playerPosition.x] = true;
  }
  renderMap && renderMap();
  
  // Initialize bank gold display
  if (typeof player.bankGold !== 'number' || isNaN(player.bankGold)) {
    player.bankGold = 0;
  }
  // Update bank gold display if element exists
  setTimeout(() => {
    if (document.getElementById('bank-gold-label')) {
      document.getElementById('bank-gold-label').textContent = player.bankGold;
    }
  }, 100);
});

/*
  --- PANEL LOCATION UI ---
  Adds a button to show a popup listing all panels and their current column (Left, Center, Right).
  Allows moving panels between columns via a dropdown, and updates the UI live.
*/

// Helper: panel IDs and display names
const panelLocations = [
  { id: 'player-stats', name: 'Player Stats' },
  { id: 'equipment', name: 'Equipment' },
  { id: 'baginv', name: 'Inventory/Bag' },
  { id: 'derived-stats', name: 'Current Stats' },
  { id: 'bank', name: 'Bank' },
  { id: 'map', name: 'Map' },
  { id: 'shop', name: 'Shop' },
  { id: 'log-panel', name: 'Game Log' },
  { id: 'prayer-panel', name: 'Prayer Panel' },
  { id: 'prayer-altar-panel', name: 'Prayer Altar' },
  { id: 'spellbook-panel', name: 'Spellbook' }
];

// Add the "Panel Locations" button to the bottom left of the main UI
(function() {
  if (!document.getElementById('panel-locations-btn')) {
    const btn = document.createElement('button');
    btn.id = 'panel-locations-btn';
    btn.textContent = 'Panel Locations';
    btn.style.fontWeight = 'bold';
    btn.style.fontSize = '1em';
    btn.style.background = '#35373e';
    btn.style.color = '#ffba3a';
    btn.style.border = 'none';
    btn.style.borderRadius = '6px';
    btn.style.padding = '6px 18px';
    btn.style.cursor = 'pointer';
    btn.style.position = 'fixed';
    btn.style.left = '10px';
    btn.style.bottom = '10px';
    btn.style.zIndex = '2100';
    document.body.appendChild(btn);
    btn.onclick = showPanelLocationsPopup;
  }
})();

// Panel Locations Popup logic
function showPanelLocationsPopup() {
  let popup = document.getElementById('panel-locations-popup');
  if (!popup) {
    popup = document.createElement('div');
    popup.id = 'panel-locations-popup';
    popup.style = 'display:flex;position:fixed;z-index:6000;top:0;left:0;width:100vw;height:100vh;background:#191a1ecc;align-items:center;justify-content:center;';
    popup.innerHTML = `
      <div style="background:#23252a;padding:38px 44px 32px 44px;border-radius:18px;box-shadow:0 2px 24px #000a;display:flex;flex-direction:column;align-items:center;min-width:340px;">
        <div style="color:#ffba3a;font-size:1.3em;margin-bottom:18px;">Panel Locations</div>
        <div id="panel-locations-list" style="margin-bottom:18px;width:100%;"></div>
        <button id="panel-locations-close" style="font-size:1.1em;font-weight:bold;background:#35373e;color:#ffba3a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">Close</button>
      </div>
    `;
    document.body.appendChild(popup);
    document.getElementById('panel-locations-close').onclick = function() {
      popup.style.display = 'none';
    };
  }
  renderPanelLocationsList();
  popup.style.display = 'flex';
}

// Helper: get column name for a panel
function getPanelColumn(panelId) {
  const panel = document.getElementById(panelId);
  if (!panel || !panel.parentNode) return 'Unknown';
  if (panel.parentNode.id === 'left-col') return 'Left';
  if (panel.parentNode.id === 'center-col') return 'Center';
  if (panel.parentNode.id === 'right-col') return 'Right';
  return 'Unknown';
}

// Helper: move panel to column
function movePanelToColumn(panelId, colName) {
  const panel = document.getElementById(panelId);
  let targetCol = null;
  if (colName === 'Left') targetCol = document.getElementById('left-col');
  else if (colName === 'Center') targetCol = document.getElementById('center-col');
  else if (colName === 'Right') targetCol = document.getElementById('right-col');
  if (panel && targetCol && panel.parentNode !== targetCol) {
    targetCol.appendChild(panel);
    // Reset position if it was being dragged
    panel.style.position = '';
    panel.style.left = '';
    panel.style.top = '';
    panel.style.right = '';
    panel.style.bottom = '';
    panel.style.zIndex = '';
  }
  renderPanelLocationsList();
}

// Render the panel locations list with dropdowns
function renderPanelLocationsList() {
  const listDiv = document.getElementById('panel-locations-list');
  if (!listDiv) return;
  let html = '<table style="width:100%;color:#fff;font-size:1em;">';
  html += '<tr><th style="text-align:left;">Panel</th><th style="text-align:left;">Location</th><th style="text-align:left;">Move</th></tr>';
  panelLocations.forEach(panel => {
    const col = getPanelColumn(panel.id);
    html += `<tr>
      <td>${panel.name}</td>
      <td>${col}</td>
      <td>
        <select onchange="movePanelToColumn('${panel.id}', this.value)">
          <option value="Left"${col==='Left'?' selected':''}>Left</option>
          <option value="Center"${col==='Center'?' selected':''}>Center</option>
          <option value="Right"${col==='Right'?' selected':''}>Right</option>
        </select>
      </td>
    </tr>`;
  });
  html += '</table>';
  listDiv.innerHTML = html;
}

// Expose movePanelToColumn globally for dropdown onchange
window.movePanelToColumn = movePanelToColumn;
/*
  --- PRAYER STAT & UI PANEL ---
  Adds a prayer stat (default 50/50) to player stats, and a separate prayer panel (menu) below player stats.
  Adds two prayers: Deflect (üó°Ô∏è) and Heal (+). Heal prayer restores +10 health after each enemy turn.
*/
 const debugSecret = "legend2024"; // Change this to your desired password
// 1. Add prayer stat to player object (default 50/50)
if (typeof player.prayer !== "number") player.prayer = 50;
if (typeof player.maxPrayer !== "number") player.maxPrayer = 50;

// 2. Patch renderPlayerStats to always show prayer stat in the stats list (no clickable UI here)
const origRenderPlayerStats = renderPlayerStats;
renderPlayerStats = function() {
  origRenderPlayerStats();
  // Add or update prayer stat row (just numbers, no button)
  const ul = document.getElementById('player-stats-ul');
  let prayerLi = ul ? ul.querySelector('.prayer-li') : null;
  if (!prayerLi && ul) {
    prayerLi = document.createElement('li');
    prayerLi.className = 'prayer-li';
    prayerLi.innerHTML = `<span class="prayer" style="color:#6cf;font-weight:bold;">Prayer:</span> <span id="prayer-label">${player.prayer}/${player.maxPrayer}</span>`;
    ul.appendChild(prayerLi);
  } else if (prayerLi) {
    const prayerLabel = prayerLi.querySelector('#prayer-label');
    if (prayerLabel) prayerLabel.textContent = `${player.prayer}/${player.maxPrayer}`;
  }
};

// 3. Add separate Prayer Panel below player stats panel (like a menu/panel)
(function() {
  if (!document.getElementById('prayer-panel')) {
    const prayerPanel = document.createElement('div');
    prayerPanel.id = 'prayer-panel';
    prayerPanel.className = 'panel';
    prayerPanel.style = 'margin-top:8px;background:#292c31;border-radius:10px;padding:16px;box-shadow:0 2px 10px #000a;';
    prayerPanel.innerHTML = `
      <h2 style="color:#6cf;">Prayer</h2>
      <div style="display:flex;align-items:center;gap:14px;">
        <button id="prayer-deflect-btn" title="Deflect Attack" style="background:#23252a;border:none;border-radius:50%;width:38px;height:38px;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:1.5em;transition:background 0.18s;">
          <span id="prayer-deflect-icon" style="color:#aaa;">üó°Ô∏è</span>
        </button>
        <button id="prayer-heal-btn" title="Heal Over Time" style="background:#23252a;border:none;border-radius:50%;width:38px;height:38px;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:1.5em;transition:background 0.18s;">
          <span id="prayer-heal-icon" style="color:#aaa;">+</span>
        </button>
        <span id="prayer-countdown" style="color:#6cf;font-weight:bold;font-size:1.1em;">${player.prayer}/${player.maxPrayer}</span>
        <span id="prayer-status-label" style="color:#aaa;font-size:0.98em;"></span>
      </div>
    `;
    // Insert after player stats panel
    const statsPanel = document.getElementById('player-stats');
    if (statsPanel && statsPanel.parentNode) {
      statsPanel.parentNode.insertBefore(prayerPanel, statsPanel.nextSibling);
    }
  }
})();

// 4. Prayer logic
let prayerDeflectActive = false;
let prayerHealActive = false;
let prayerInterval = null;

// Tooltip logic for prayers
function showPrayerTooltip(btnId, text) {
  let btn = document.getElementById(btnId);
  if (!btn) return;
  let tip = document.createElement('div');
  tip.className = 'prayer-tooltip';
  tip.style.position = 'absolute';
  tip.style.left = '50%';
  tip.style.top = '110%';
  tip.style.transform = 'translateX(-50%)';
  tip.style.background = '#18191c';
  tip.style.color = '#eee';
  tip.style.padding = '8px 16px';
  tip.style.borderRadius = '8px';
  tip.style.border = '1px solid #444';
  tip.style.whiteSpace = 'nowrap';
  tip.style.fontSize = '1em';
  tip.style.boxShadow = '0 2px 10px #0007';
  tip.style.zIndex = '9999';
  tip.innerHTML = text;
  btn.appendChild(tip);
  btn._prayerTip = tip;
}
function hidePrayerTooltip(btnId) {
  let btn = document.getElementById(btnId);
  if (btn && btn._prayerTip) {
    btn.removeChild(btn._prayerTip);
    btn._prayerTip = null;
  }
}

function getPrayerDrainRate() {
  let activeCount = (prayerDeflectActive ? 1 : 0) + (prayerHealActive ? 1 : 0);
  return activeCount === 2 ? "1%" : activeCount === 1 ? "0.5%" : "0%";
}

function updatePrayerUI() {
  // Update prayer panel layout and status
  const panel = document.getElementById('prayer-panel');
  if (!panel) return;
  panel.innerHTML = `
    <h2 style="color:#6cf;">Prayer</h2>
    <div style="display:flex;align-items:center;gap:14px;margin-bottom:8px;position:relative;">
      <button id="prayer-deflect-btn" title="Deflect Attack" style="background:${prayerDeflectActive ? '#232' : '#23252a'};border:none;border-radius:50%;width:38px;height:38px;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:1.5em;transition:background 0.18s;position:relative;">
        <span id="prayer-deflect-icon" style="color:${prayerDeflectActive ? '#2ecc40' : '#aaa'};">üó°Ô∏è</span>
      </button>
      <button id="prayer-heal-btn" title="Heal Over Time" style="background:${prayerHealActive ? '#232' : '#23252a'};border:none;border-radius:50%;width:38px;height:38px;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:1.5em;transition:background 0.18s;position:relative;">
        <span id="prayer-heal-icon" style="color:${prayerHealActive ? '#2ecc40' : '#aaa'};">‚ù§Ô∏è</span>
      </button>
      <span id="prayer-countdown" style="color:${(prayerDeflectActive||prayerHealActive) ? '#2ecc40' : '#6cf'};font-weight:bold;font-size:1.1em;">
        ${player.prayer}/${player.maxPrayer}
      </span>
      <span id="prayer-status-label" style="color:#aaa;font-weight:bold;font-size:1.1em;">
        ${prayerDeflectActive ? 'Deflect Active' : ''}${prayerDeflectActive && prayerHealActive ? ' & ' : ''}${prayerHealActive ? 'Heal Active' : ''}
        ${!prayerDeflectActive && !prayerHealActive ? 'Inactive' : ''}
      </span>
    </div>
    <div style="color:#aaa;font-size:0.98em;">
      Prayer drain rate: <b>${getPrayerDrainRate()}</b> per tick
    </div>
  `;
  // Remove old tooltips if any
  hidePrayerTooltip('prayer-deflect-btn');
  hidePrayerTooltip('prayer-heal-btn');
  // Attach hover logic for tooltips
  const deflectBtn = document.getElementById('prayer-deflect-btn');
  const healBtn = document.getElementById('prayer-heal-btn');
  if (deflectBtn) {
    deflectBtn.onmouseenter = function() {
      showPrayerTooltip('prayer-deflect-btn', `Deflect: Negates half enemy damage.<br>Drain rate: 0.5% per tick if active.`);
    };
    deflectBtn.onmouseleave = function() {
      hidePrayerTooltip('prayer-deflect-btn');
    };
  }
  if (healBtn) {
    healBtn.onmouseenter = function() {
      showPrayerTooltip('prayer-heal-btn', `Heal: Restores 50 health after each enemy turn.<br>Drain rate: 0.5% per tick if active.`);
    };
    healBtn.onmouseleave = function() {
      hidePrayerTooltip('prayer-heal-btn');
    };
  }
  // Toggle logic
  if (deflectBtn) deflectBtn.onclick = function() {
    prayerDeflectActive = !prayerDeflectActive;
    if (prayerDeflectActive && prayerHealActive && player.prayer <= 0) {
      prayerDeflectActive = false;
      prayerHealActive = false;
    }
    updatePrayerUI();
    handlePrayerInterval();
  };
  if (healBtn) healBtn.onclick = function() {
    prayerHealActive = !prayerHealActive;
    if (prayerDeflectActive && prayerHealActive && player.prayer <= 0) {
      prayerDeflectActive = false;
      prayerHealActive = false;
    }
    updatePrayerUI();
    handlePrayerInterval();
  };
  // Also update player stats prayer label
  const prayerLabel = document.getElementById('prayer-label');
  if (prayerLabel) prayerLabel.textContent = `${player.prayer}/${player.maxPrayer}`;
}
function handlePrayerInterval() {
  // Only drain prayer if any prayer is active
  if ((prayerDeflectActive || prayerHealActive) && player.prayer > 0) {
    if (!prayerInterval) {
      prayerInterval = setInterval(() => {
        if (!(prayerDeflectActive || prayerHealActive)) return;
        if (player.prayer > 0) {
          // Drain rate: 0.5% per prayer per tick
          let drain = 0;
          if (prayerDeflectActive) drain += 0.5;
          if (prayerHealActive) drain += 0.5;
          // Convert percent to actual prayer points (maxPrayer * drain%)
          let drainAmount = Math.max(1, Math.floor(player.maxPrayer * (drain / 100)));
          player.prayer = Math.max(0, player.prayer - drainAmount);
          updatePrayerUI();
          checkPrayerZero();
        }
        if (player.prayer <= 0) {
          prayerDeflectActive = false;
          prayerHealActive = false;
          updatePrayerUI();
          clearInterval(prayerInterval);
          prayerInterval = null;
        }
      }, 700);
    }
  } else {
    if (prayerInterval) {
      clearInterval(prayerInterval);
      prayerInterval = null;
    }
  }
}
updatePrayerUI();

// 5. Patch enemyAttack to deflect half damage if prayerDeflectActive and heal +10 if prayerHealActive
const origEnemyAttack = enemyAttack;
enemyAttack = function() {
  if (!currentEnemy || !inCombat) return;
  let pDef = getTotalDefense();
  let min = currentEnemy.minAttack;
  let max = currentEnemy.maxAttack;
  let eHit = Math.max(0, Math.floor(min + Math.random()*(max-min+1)) - Math.floor(pDef/3));
  // Prayer deflect logic
  if (prayerDeflectActive && player.prayer > 0) {
    let deflected = Math.ceil(eHit / 2);
    eHit = eHit - deflected;
    logMsg(`<span style="color:#2ecc40;font-weight:bold;">Prayer Deflect: Negated ${deflected} damage!</span>`);
    updatePrayerUI();
    checkPrayerZero();
  }
  player.health = Math.max(0, player.health - eHit);
  logMsg(`<span style="color:#f66">The ${currentEnemy.name} hits you for <b>${eHit}</b>!</span>`);
  // Heal prayer logic: heal 50 after enemy turn
  if (prayerHealActive && player.prayer > 0 && player.health > 0) {
    let maxHeal = getTotalMaxHealth();
    let healed = Math.min(50, maxHeal - player.health);
    if (healed > 0) {
      player.health += healed;
      logMsg(`<span style="color:#2ecc40;font-weight:bold;">Prayer Heal: Restored ${healed} health!</span>`);
    }
    updatePrayerUI();
    checkPrayerZero();
  }
  renderPlayerStats();
  if (player.health <= 0) {
    logMsg(`<span style="color:#f44;font-weight:bold;">You died! Respawning at town...</span>`);
    respawnPlayer();
    clearEnemy();
  }
};

// 6. Restore prayer only on respawn (not after every battle or level up)
const origRespawnPlayer = respawnPlayer;
respawnPlayer = function() {
  player.prayer = player.maxPrayer;
  prayerDeflectActive = false;
  prayerHealActive = false;
  updatePrayerUI();
  origRespawnPlayer();
};
// Do NOT reset prayer on level up
const origCheckLevelUp = checkLevelUp;
checkLevelUp = function() {
  origCheckLevelUp();
  updatePrayerUI();
};

// 7. Update prayer UI on game load/start
window.addEventListener('DOMContentLoaded', updatePrayerUI);
const usernameSubmitButton = document.getElementById('username-submit');
if (usernameSubmitButton) {
  usernameSubmitButton.addEventListener('click', updatePrayerUI);
}

// 8. Add logic to ensure prayer does not reset after each explore, and reacts appropriately at 0

// Remove any code that resets prayer on explore or movement
// (No code in your explore/movePlayer/doExplore resets prayer, so nothing to remove)

// Patch explore, movePlayer, doExplore to NOT reset prayer
// Already handled: prayer only resets on respawn/level up

// Ensure prayer reacts appropriately at 0 (disable prayers, update UI)
function checkPrayerZero() {
  if (player.prayer <= 0) {
    player.prayer = 0;
    prayerDeflectActive = false;
    prayerHealActive = false;
    updatePrayerUI();
    if (prayerInterval) { clearInterval(prayerInterval); prayerInterval = null; }
    logMsg('<span style="color:#6cf;font-weight:bold;">Prayer depleted! All prayers disabled.</span>');
  }
}

// Patch all places where prayer is decremented to call checkPrayerZero
let enemyTurnCounter = 0;
const origEnemyAttack2 = enemyAttack;
enemyAttack = function() {
  if (!currentEnemy || !inCombat) return;
  let pDef = getTotalDefense();
  let min = currentEnemy.minAttack;
  let max = currentEnemy.maxAttack;
  let eHit = Math.max(0, Math.floor(min + Math.random()*(max-min+1)) - Math.floor(pDef/3));
  // Prayer deflect logic
  if (prayerDeflectActive && player.prayer > 0) {
    let deflected = Math.ceil(eHit / 2);
    eHit = eHit - deflected;
    logMsg(`<span style="color:#2ecc40;font-weight:bold;">Prayer Deflect: Negated ${deflected} damage!</span>`);
    updatePrayerUI();
    checkPrayerZero();
  }
  player.health = Math.max(0, player.health - eHit);
  logMsg(`<span style="color:#f66">The ${currentEnemy.name} hits you for <b>${eHit}</b>!</span>`);
  // Heal prayer logic: heal 50 after every 5 enemy turns
  if (prayerHealActive && player.prayer > 0 && player.health > 0) {
    enemyTurnCounter = (enemyTurnCounter || 0) + 1;
    if (enemyTurnCounter % 5 === 0) {
      let maxHeal = getTotalMaxHealth();
      let healed = Math.min(50, maxHeal - player.health);
      if (healed > 0) {
        player.health += healed;
        logMsg(`<span style="color:#2ecc40;font-weight:bold;">Prayer Heal: Restored ${healed} health!</span>`);
      }
      updatePrayerUI();
      checkPrayerZero();
    }
  }
  renderPlayerStats();
  if (player.health <= 0) {
    logMsg(`<span style="color:#f44;font-weight:bold;">You died! Respawning at town...</span>`);
    respawnPlayer();
    clearEnemy();
    enemyTurnCounter = 0;
  }
};

// Patch prayerInterval drain to call checkPrayerZero
function handlePrayerInterval() {
  // Only drain prayer if any prayer is active
  if ((prayerDeflectActive || prayerHealActive) && player.prayer > 0) {
    if (!prayerInterval) {
      prayerInterval = setInterval(() => {
        if (!(prayerDeflectActive || prayerHealActive)) return;
        if (player.prayer > 0) {
          // Drain rate: 0.5% per prayer per tick
          let drain = 0;
          if (prayerDeflectActive) drain += 0.5;
          if (prayerHealActive) drain += 0.5;
          let drainAmount = Math.max(1, Math.floor(player.maxPrayer * (drain / 100)));
          player.prayer = Math.max(0, player.prayer - drainAmount);
          updatePrayerUI();
          checkPrayerZero();
        }
        if (player.prayer <= 0) {
          prayerDeflectActive = false;
          prayerHealActive = false;
          updatePrayerUI();
          clearInterval(prayerInterval);
          prayerInterval = null;
        }
      }, 700);
    }
  } else {
    if (prayerInterval) {
      clearInterval(prayerInterval);
      prayerInterval = null;
    }
  }
}

// Prayer only resets on respawn/level up (already handled above)
(function() {
  const style = document.createElement('style');
  style.textContent = `
    #prayer-panel { margin-top:8px; }
    #prayer-deflect-btn, #prayer-heal-btn { transition:background 0.18s; }
    #prayer-deflect-btn:active, #prayer-heal-btn:active { box-shadow:0 0 8px #2ecc40; }
    #prayer-deflect-icon, #prayer-heal-icon { transition:color 0.18s; }
    #prayer-countdown { font-weight:bold; }
    .prayer-tooltip {
      pointer-events: none;
      opacity: 0.98;
      transition: opacity 0.12s;
    }
  `;
  document.head.appendChild(style);

// --- PRAYER ALTAR UI ---
// Check if the altar panel already exists
if (!document.getElementById('prayer-altar-panel')) {
  const altarPanel = document.createElement('div');
  altarPanel.id = 'prayer-altar-panel';
  altarPanel.className = 'panel';
  altarPanel.style = 'background:url("assets/chaos_altar.png") center/cover;border-radius:10px;box-shadow:0 2px 10px #000a;margin-top:8px;min-height:200px;position:relative;overflow:hidden;';

  altarPanel.innerHTML = `
    <!-- Dark overlay for better text readability -->
    <div style="position:absolute;top:0;left:0;right:0;bottom:0;background:linear-gradient(to bottom, transparent 0%, rgba(35,37,42,0.7) 60%, rgba(35,37,42,0.9) 100%);border-radius:10px;"></div>
    
    <!-- Content container -->
    <div style="position:relative;z-index:2;display:flex;flex-direction:column;align-items:center;justify-content:flex-end;height:100%;padding:16px;">
      <button id="renew-prayer-btn" style="font-size:1.1em;font-weight:bold;background:#6cf;color:#23252a;border:none;border-radius:8px;padding:12px 24px;cursor:pointer;box-shadow:0 2px 8px #6cf4;margin-bottom:8px;">Renew Prayer</button>
      <div id="renew-prayer-msg" style="color:#6cf;font-size:0.98em;display:none;text-align:center;width:90%;margin-top:8px;text-shadow:0 1px 4px #000;"></div>
    </div>
  `;
  // Insert below prayer panel
  const prayerPanel = document.getElementById('prayer-panel');
  if (prayerPanel && prayerPanel.parentNode) {
    prayerPanel.parentNode.insertBefore(altarPanel, prayerPanel.nextSibling);
  }
  // Renew Prayer button logic - directly renew prayer without popup
  document.getElementById('renew-prayer-btn').onclick = function() {
    player.prayer = player.maxPrayer;
    updatePrayerUI();
    renderPlayerStats();
    const msg = document.getElementById('renew-prayer-msg');
    msg.textContent = '‚ú® Your prayer has been renewed at the altar! ‚ú®';
    msg.style.display = 'block';
    setTimeout(() => {
      msg.style.display = 'none';
    }, 2000);
  };
}
// Popup helpers
function showCorruptSavePopup() {
  let oldPopup = document.getElementById('corrupt-save-popup');
  if (oldPopup) oldPopup.remove();
  const popup = document.createElement('div');
  popup.id = 'corrupt-save-popup';
  popup.style = 'position:fixed;z-index:9999;top:0;left:0;width:100vw;height:100vh;background:#191a1ecc;display:flex;align-items:center;justify-content:center;';
  popup.innerHTML = `
   <div style="background:#23252a;padding:38px 44px 32px 44px;border-radius:18px;box-shadow:0 2px 24px #000a;display:flex;flex-direction:column;align-items:center;min-width:340px;">
    <div style="color:#ff4444;font-size:1.5em;margin-bottom:18px;">Corrupt Save Detected!</div>
    <div style="margin-bottom:18px;color:#ffd36b;font-size:1.1em;">
      <b>Something is amiss in your save file...</b><br>
      The ancient magic cannot restore your progress.<br>
      <span style="color:#ffba3a;">Please check your save file and try again!</span>
    </div>
    <button onclick="document.getElementById('corrupt-save-popup').remove()" style="font-size:1.1em;font-weight:bold;background:#ff4444;color:#fff;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">OK</button>
   </div>
  `;
  document.body.appendChild(popup);
}

function showPassedSavePopup() {
  let oldPopup = document.getElementById('passed-save-popup');
  if (oldPopup) oldPopup.remove();
  const popup = document.createElement('div');
  popup.id = 'passed-save-popup';
  popup.style = 'position:fixed;z-index:9999;top:0;left:0;width:100vw;height:100vh;background:#191a1ecc;display:flex;align-items:center;justify-content:center;';
  popup.innerHTML = `
   <div style="background:#23252a;padding:38px 44px 32px 44px;border-radius:18px;box-shadow:0 2px 24px #000a;display:flex;flex-direction:column;align-items:center;min-width:340px;">
    <div style="color:#90ee90;font-size:1.5em;margin-bottom:18px;">Save Verified!</div>
    <div style="margin-bottom:18px;color:#ffd36b;font-size:1.1em;">
      <b>Your save file passed the ancient safety check.</b><br>
      The legend continues!
    </div>
    <button onclick="document.getElementById('passed-save-popup').remove()" style="font-size:1.1em;font-weight:bold;background:#ffba3a;color:#23252a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">Continue</button>
   </div>
  `;
  document.body.appendChild(popup);
}

// Patch load input to add safety check using uploaded last-game-values.json
const mainLoadInput = document.getElementById('main-load-input');
if (mainLoadInput) {
  const origLoadHandler = mainLoadInput.onchange || null;
  mainLoadInput.onchange = function(e) {
   try {
    const file = e.target.files[0];
    if (!file) throw new Error('No file selected.');
    const reader = new FileReader();
    reader.onload = function(evt) {
      try {
       const saveData = JSON.parse(evt.target.result);

       // Prompt user to upload last-game-values.json for strict check
       let lastValuesInput = document.createElement('input');
       lastValuesInput.type = 'file';
       lastValuesInput.accept = '.json,application/json';
       lastValuesInput.style.display = 'none';
       document.body.appendChild(lastValuesInput);

       lastValuesInput.onchange = function(ev) {
        const lastFile = ev.target.files[0];
        if (!lastFile) {
          showCorruptSavePopup();
          document.body.removeChild(lastValuesInput);
          return;
        }
        const lastReader = new FileReader();
        lastReader.onload = function(ev2) {
          let lastSaved = null;
          try {
           lastSaved = JSON.parse(ev2.target.result);
          } catch (e) { lastSaved = null; }
          let passed = (
           saveData &&
           typeof saveData.player === "object" &&
           Array.isArray(saveData.player.inventory) &&
           Array.isArray(saveData.player.bag) &&
           typeof saveData.player.equipment === "object" &&
           Array.isArray(saveData.player.bank) &&
           typeof saveData.visitedTowns === "object" &&
           typeof saveData.playerPosition === "object" &&
           typeof saveData.playerPosition.x === "number" &&
           typeof saveData.playerPosition.y === "number"
          );
          let strictValid = true;
          if (lastSaved) {
           strictValid =
            typeof saveData.player.gold === "number" && saveData.player.gold === lastSaved.gold &&
            typeof saveData.player.level === "number" && saveData.player.level === lastSaved.level &&
            typeof saveData.player.experience === "number" && saveData.player.experience === lastSaved.experience;
          }
          if (!passed || !strictValid) {
           showCorruptSavePopup();
           document.body.removeChild(lastValuesInput);
           return;
          }
          showPassedSavePopup();
          // Normal load logic
          initMap();
          Object.keys(visitedTowns).forEach(k => delete visitedTowns[k]);
          player.name = saveData.player.name || "Hero";
          player.health = typeof saveData.player.health === "number" ? saveData.player.health : 100;
          player.maxHealth = typeof saveData.player.maxHealth === "number" ? saveData.player.maxHealth : 100;
          player.gold = typeof saveData.player.gold === "number" ? saveData.player.gold : 0;
          player.experience = typeof saveData.player.experience === "number" ? saveData.player.experience : 0;
          player.level = typeof saveData.player.level === "number" ? saveData.player.level : 1;
          player.bankGold = typeof saveData.player.bankGold === "number" ? saveData.player.bankGold : 0;
          player.inventory = Array.isArray(saveData.player.inventory) ? JSON.parse(JSON.stringify(saveData.player.inventory)) : [];
          player.bag = Array.isArray(saveData.player.bag) ? JSON.parse(JSON.stringify(saveData.player.bag)) : [];
          player.equipment = typeof saveData.player.equipment === "object" && saveData.player.equipment !== null
           ? JSON.parse(JSON.stringify(saveData.player.equipment))
           : { helmet: null, weapon: null, armor: null, ring: null, arrows: null, cloak: null, shield: null, amulet: null, gloves: null, boots: null };
          player.bank = Array.isArray(saveData.player.bank) ? JSON.parse(JSON.stringify(saveData.player.bank)) : [];
          playerPosition.x = typeof saveData.playerPosition.x === "number" ? saveData.playerPosition.x : Math.floor(mapSize/2);
          playerPosition.y = typeof saveData.playerPosition.y === "number" ? saveData.playerPosition.y : Math.floor(mapSize/2);
          renderPlayerStats();
          renderDerivedStats();
          renderEquipment();
          renderBagInv();
          renderMap();
          alert('Game loaded from file! Map has been reset and player is at Central Town.');
          if (document.getElementById('username-overlay').style.display !== 'none') {
           document.getElementById('username-overlay').style.display = 'none';
           const overlayLoadBtn2 = document.getElementById('overlay-load-btn2');
           if (overlayLoadBtn2) overlayLoadBtn2.style.display = 'none';
          }
          document.body.removeChild(lastValuesInput);
        };
        lastReader.readAsText(lastFile);
       };

       // Prompt user to upload last-game-values.json
       alert('Please select your last-game-values.json file for safety check.');
       lastValuesInput.click();

      } catch (err) {
       alert('Failed to load save: ' + (err && err.message ? err.message : err));
      }
    };
    reader.readAsText(file);
    e.target.value = '';
   } catch (err) {
    alert('Failed to load save: ' + (err && err.message ? err.message : err));
   }
   if (origLoadHandler) origLoadHandler.call(this, e);
  };
}

})();
</script>
</body>
<!-- DEBUG MODE POPUP & LOGIC -->
<style>
  #debug-mode-banner {
    display: none;
    position: fixed;
    top: 0; left: 0; width: 100vw;
    background: #ff4444;
    color: #fff;
    font-weight: bold;
    font-size: 1.2em;
    text-align: center;
    z-index: 99999;
    padding: 8px 0;
    letter-spacing: 2px;
    box-shadow: 0 2px 12px #000a;
    cursor: pointer;
  }
  #debug-popup {
    display: none;
    position: fixed;
    z-index: 100000;
    top: 0; left: 0; width: 100vw; height: 100vh;
    background: #191a1ecc;
    align-items: center;
    justify-content: center;
  }
  #debug-popup-inner {
    background: #23252a;
    padding: 38px 44px 32px 44px;
    border-radius: 18px;
    box-shadow: 0 2px 24px #000a;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-width: 340px;
    max-width: 96vw;
    max-height: 90vh;
    overflow-y: auto;
  }
  #debug-popup label { color: #ffd36b; font-weight: bold; }
  #debug-popup input[type="checkbox"] { margin-right: 8px; }
  #debug-popup select, #debug-popup button { margin: 4px 0; }
  #debug-popup .debug-section { margin-bottom: 18px; }
</style>
<div id="debug-mode-banner" style="display:none;">DEBUG MODE ENABLED (F12 to toggle)</div>
<script>
(function() {
  let debugMode = false;
  let unlimitedHealth = false;



  // Store if password was validated
  let debugPasswordValidated = false;

  function showDebugPasswordPrompt(callback) {
    // Remove old popup if exists
    let old = document.getElementById('debug-password-popup');
    if (old) old.remove();
    // Create popup
    const popup = document.createElement('div');
    popup.id = 'debug-password-popup';
    popup.style = 'position:fixed;z-index:100001;top:0;left:0;width:100vw;height:100vh;background:#191a1ecc;display:flex;align-items:center;justify-content:center;';
    popup.innerHTML = `
      <div style="background:#23252a;padding:32px 38px 24px 38px;border-radius:18px;box-shadow:0 2px 24px #000a;display:flex;flex-direction:column;align-items:center;min-width:320px;">
        <div style="color:#ffba3a;font-size:1.2em;margin-bottom:18px;">Enter Debug Password</div>
        <input id="debug-password-input" type="password" placeholder="Password..." style="font-size:1.1em;padding:6px 18px;border-radius:7px;border:1.5px solid #444;background:#18191c;color:#fff;margin-bottom:18px;width:180px;outline:none;">
        <div id="debug-password-error" style="color:#ff4444;margin-bottom:10px;display:none;font-size:1em;"></div>
        <div style="display:flex;gap:18px;">
          <button id="debug-password-ok" style="font-size:1.1em;font-weight:bold;background:#ffba3a;color:#23252a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">OK</button>
          <button id="debug-password-cancel" style="font-size:1.1em;font-weight:bold;background:#35373e;color:#ffba3a;border:none;border-radius:7px;padding:8px 32px;cursor:pointer;">Cancel</button>
        </div>
      </div>
    `;
    document.body.appendChild(popup);
    document.getElementById('debug-password-ok').onclick = function() {
      const val = document.getElementById('debug-password-input').value;
      if (val === debugSecret) {
        debugPasswordValidated = true;
        popup.remove();
        callback(true);
      } else {
        document.getElementById('debug-password-error').textContent = "Incorrect password.";
        document.getElementById('debug-password-error').style.display = 'block';
      }
    };
    document.getElementById('debug-password-cancel').onclick = function() {
      popup.remove();
      callback(false);
    };
    document.getElementById('debug-password-input').addEventListener('keydown', function(e) {
      if (e.key === 'Enter') document.getElementById('debug-password-ok').click();
    });
    setTimeout(() => document.getElementById('debug-password-input').focus(), 100);
  }

  function createDebugUI() {
    // Remove existing popup if any
    let oldPopup = document.getElementById('debug-popup');
    if (oldPopup) oldPopup.remove();

    // Create popup
    const popup = document.createElement('div');
    popup.id = 'debug-popup';
    popup.style.display = debugMode ? 'flex' : 'none';
    popup.style.position = 'fixed';
    popup.style.zIndex = '100000';
    popup.style.top = '0';
    popup.style.left = '0';
    popup.style.width = '100vw';
    popup.style.height = '100vh';
    popup.style.background = '#191a1ecc';
    popup.style.alignItems = 'center';
    popup.style.justifyContent = 'center';

    popup.innerHTML = `
      <div id="debug-popup-inner">
        <div style="font-size:1.5em;color:#ff4444;font-weight:bold;margin-bottom:18px;">Debug Mode</div>
        <div class="debug-section">
          <label><input type="checkbox" id="debug-unlimited-health"> Unlimited Health</label>
        </div>
        <div class="debug-section">
          <button id="debug-1hit-weapon" style="background:#ffba3a;color:#23252a;border:none;border-radius:6px;padding:6px 18px;font-weight:bold;cursor:pointer;">Give 1-Hit Kill Weapon</button>
        </div>
        <!-- Force Spawn Enemy section removed -->
        <div class="debug-section">
          <label>Force Encounter:</label>
          <select id="debug-encounter-list"></select>
          <button id="debug-force-encounter" style="margin-left:8px;">Trigger</button>
        </div>
        <div class="debug-section">
          <label><input type="checkbox" id="debug-disable-checkbox"> Disable Debug Mode & Menu</label>
        </div>
        <button id="debug-close-btn" style="margin-top:12px;background:#35373e;color:#ffba3a;border:none;border-radius:6px;padding:6px 18px;font-weight:bold;cursor:pointer;">Close</button>
      </div>
    `;
    document.body.appendChild(popup);

    // Populate enemy and encounter lists
    populateEnemyList();
    populateEncounterList();

    // Event handlers
    document.getElementById('debug-unlimited-health').checked = unlimitedHealth;
    document.getElementById('debug-unlimited-health').onchange = function() {
      unlimitedHealth = this.checked;
    };
    document.getElementById('debug-1hit-weapon').onclick = function() {
      let weapon = {
        name: "Debug 1-Hit Sword",
        type: "weapon",
        attackPower: 99999,
        price: 0,
        description: "Debug sword. Instantly kills enemies."
      };
      addItem(weapon);
      logMsg('<span style="color:#ff4444;">Debug: 1-Hit Kill Weapon added to bag.</span>');
      renderBagInv && renderBagInv();
    };
    document.getElementById('debug-force-encounter').onclick = function() {
      let enc = document.getElementById('debug-encounter-list').value;
      if (!enc) return;
      if (enc === "Normal Enemy") {
        showEnemy && showEnemy();
        logMsg('<span style="color:#ff4444;">Debug: Forced normal enemy encounter.</span>');
      } else if (enc === "Ancient Boss") {
        window.showAncientBoss && window.showAncientBoss();
        logMsg('<span style="color:#ff4444;">Debug: Forced Ancient Boss encounter.</span>');
      } else if (enc === "Secret Tunnel") {
        window.showSecretTunnelPopup && window.showSecretTunnelPopup();
        logMsg('<span style="color:#ff4444;">Debug: Forced Secret Tunnel encounter.</span>');
      } else if (enc === "Unknown Enemy") {
        window.failSecretTunnelEncounter && window.failSecretTunnelEncounter();
        logMsg('<span style="color:#ff4444;">Debug: Forced Unknown Enemy encounter.</span>');
      }
      popup.style.display = 'none';
    };
    document.getElementById('debug-disable-checkbox').checked = !debugMode;
    document.getElementById('debug-disable-checkbox').onchange = function() {
      if (this.checked) {
        debugMode = false;
        unlimitedHealth = false;
        removeDebugUI();
        updateDebugBanner();
      }
    };
    document.getElementById('debug-close-btn').onclick = function() {
      popup.style.display = 'none';
      debugMode = false;
      unlimitedHealth = false;
      removeDebugUI();
      updateDebugBanner();
    };
    function populateEnemyList() {
      let debugEnemyList = document.getElementById('debug-enemy-list');
      if (!debugEnemyList) return;
      debugEnemyList.innerHTML = "";
      // Hardcoded enemy list
      const debugEnemies = [
        { name: "Slime", maxHealth: 40, minAttack: 4, maxAttack: 9, xp: 15 },
        { name: "Goblin", maxHealth: 55, minAttack: 7, maxAttack: 14, xp: 22 },
        { name: "Wolf", maxHealth: 65, minAttack: 10, maxAttack: 19, xp: 29 },
        { name: "Bandit", maxHealth: 80, minAttack: 14, maxAttack: 23, xp: 40 },
        { name: "Orc", maxHealth: 120, minAttack: 18, maxAttack: 29, xp: 60 },
        { name: "Dark Knight", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
        { name: "Fire Elemental", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
        { name: "Stone Golem", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
        { name: "Vampire Lord", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
        { name: "Frost Giant", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
        { name: "Shadow Assassin", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
        { name: "Ancient Dragon", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
        { name: "Lich King", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
        { name: "Forest Guardian", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
        { name: "Thunder Beast", maxHealth: Math.floor(Math.random() * 101) + 150, minAttack: 30, maxAttack: 40, xp: Math.floor(Math.random() * 51) + 50 },
        { name: "Skeleton Warrior", maxHealth: 70, minAttack: 12, maxAttack: 20, xp: 32 },
        { name: "Zombie", maxHealth: 90, minAttack: 10, maxAttack: 18, xp: 28 },
        { name: "Harpy", maxHealth: 60, minAttack: 15, maxAttack: 22, xp: 35 },
        { name: "Troll", maxHealth: 140, minAttack: 20, maxAttack: 32, xp: 55 },
        { name: "Sand Wraith", maxHealth: 85, minAttack: 17, maxAttack: 25, xp: 38 },
        { name: "Cursed Knight", maxHealth: 130, minAttack: 25, maxAttack: 36, xp: 65 },
        { name: "Giant Spider", maxHealth: 75, minAttack: 13, maxAttack: 21, xp: 30 },
        { name: "Dire Bear", maxHealth: 110, minAttack: 18, maxAttack: 28, xp: 48 },
        { name: "Crystal Serpent", maxHealth: 100, minAttack: 22, maxAttack: 33, xp: 52 },
        { name: "Wraith", maxHealth: 95, minAttack: 19, maxAttack: 27, xp: 44 }
      ];
      debugEnemies.forEach(e => {
        let opt = document.createElement('option');
        opt.value = e.name;
        opt.textContent = e.name;
        debugEnemyList.appendChild(opt);
      });
      // Add Ancient Boss if present
      if (window.ancientBossData && window.ancientBossData.name) {
        let opt = document.createElement('option');
        opt.value = window.ancientBossData.name;
        opt.textContent = window.ancientBossData.name;
        debugEnemyList.appendChild(opt);
      }
      renderPlayerStats && renderPlayerStats();
    }
    function populateEncounterList() {
      let debugEncounterList = document.getElementById('debug-encounter-list');
      if (!debugEncounterList) return;
      debugEncounterList.innerHTML = "";
      const encounters = [
        "Normal Enemy",
        "Ancient Boss",
        "Secret Tunnel",
        "Unknown Enemy"
      ];
      encounters.forEach(enc => {
        let opt = document.createElement('option');
        opt.value = enc;
        opt.textContent = enc;
        debugEncounterList.appendChild(opt);
      });
    }
  }

  // F12 toggles debug mode
  window.addEventListener('keydown', function(e) {
    if (e.key === "F12") {
      if (!debugPasswordValidated) {
        showDebugPasswordPrompt(function(success) {
          if (success) {
            debugMode = true;
            createDebugUI();
            updateDebugBanner();
          }
        });
      } else {
        debugMode = !debugMode;
        if (debugMode) {
          createDebugUI();
        } else {
          unlimitedHealth = false;
          removeDebugUI();
        }
        updateDebugBanner();
      }
      e.preventDefault();
    }
  });

  // Banner click shows debug UI if enabled
  let banner = document.getElementById('debug-mode-banner');
  if (banner) {
    banner.onclick = function() {
      if (debugMode) {
        createDebugUI();
        let popup = document.getElementById('debug-popup');
        if (popup) popup.style.display = 'flex';
      }
    };
  }

  function removeDebugUI() {
    let popup = document.getElementById('debug-popup');
    if (popup) popup.remove();
  }
  function updateDebugBanner() {
    let banner = document.getElementById('debug-mode-banner');
    if (banner) banner.style.display = debugMode ? 'block' : 'none';
  }
// --- MOVE COUNTER LOGIC FOR MAP UI ---
// Counts and displays the number of moves made in the current explore/auto-explore session.

// Add move counter UI to the map panel if not present
if (!document.getElementById('move-counter-label')) {
  const label = document.createElement('div');
  label.id = 'move-counter-label';
  label.style = 'color:#ffd36b;font-weight:bold;font-size:1.08em;text-align:center;margin-bottom:6px;';
  label.textContent = 'Moves: 0';
  const mapPanel = document.getElementById('map-panel') || document.getElementById('map-container');
  if (mapPanel) {
    mapPanel.insertBefore(label, mapPanel.firstChild);
  }
}

// Track moves for current explore/auto-explore session
let moveCounter = 0;
let moveCounterActive = true; // Always active unless user dies

// Helper to update the move counter UI
function updateMoveCounterUI() {
  const label = document.getElementById('move-counter-label');
  if (label) {
    label.textContent = `Moves: ${moveCounter}`;
  }
}

// Only reset move counter on player death/respawn
function resetMoveCounter() {
  moveCounter = 0;
  moveCounterActive = true;
  updateMoveCounterUI();
}

// Increment move counter and update UI
function incrementMoveCounter() {
  if (moveCounterActive) {
    moveCounter++;
    updateMoveCounterUI();
  }
}

// Patch doExplore to increment move counter on each step
const origDoExploreForMoves = typeof doExplore === "function" ? doExplore : null;
doExplore = function() {
  incrementMoveCounter();
  origDoExploreForMoves && origDoExploreForMoves();
};

// Patch autoExploreLoop to increment move counter on each step
const origAutoExploreLoopForMoves = typeof autoExploreLoop === "function" ? autoExploreLoop : null;
autoExploreLoop = function() {
  incrementMoveCounter();
  origAutoExploreLoopForMoves && origAutoExploreLoopForMoves();
};

// Patch respawnPlayer to reset move counter on death
const origRespawnPlayerForMoves = typeof respawnPlayer === "function" ? respawnPlayer : null;
respawnPlayer = function() {
  resetMoveCounter();
  origRespawnPlayerForMoves && origRespawnPlayerForMoves();
};

})();
/*
  --- SPELLBOOK UI & LOGIC FOR MAGE CLASS ---
  Adds a spellbook panel below prayer panel, with three spells: Fire, Water, Air.
  Only available for Mage class. Spells require runes from inventory and can be toggled on/off.
  When attacking, if a spell is active, the corresponding runes are consumed and the spell effect is applied.
*/

// 1. Add spellbook panel below prayer panel (only for Mage)
(function() {
  if (!document.getElementById('spellbook-panel')) {
    const spellbookPanel = document.createElement('div');
    spellbookPanel.id = 'spellbook-panel';
    spellbookPanel.className = 'panel';
    spellbookPanel.style = 'margin-top:8px;background:#292c31;border-radius:10px;padding:16px;box-shadow:0 2px 10px #000a;display:none;';
    spellbookPanel.innerHTML = `
      <h2 style="color:#ffba3a;">Spellbook</h2>
      <div style="display:flex;align-items:center;gap:18px;">
        <button id="spell-fire-btn" title="Fire Spell" style="background:#23252a;border:none;border-radius:50%;width:44px;height:44px;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:2em;transition:background 0.18s;position:relative;">
          <span id="spell-fire-icon" style="color:#ff4444;">üî•</span>
        </button>
        <button id="spell-water-btn" title="Water Spell" style="background:#23252a;border:none;border-radius:50%;width:44px;height:44px;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:2em;transition:background 0.18s;position:relative;">
          <span id="spell-water-icon" style="color:#2196f3;">üíß</span>
        </button>
        <button id="spell-air-btn" title="Air Spell" style="background:#23252a;border:none;border-radius:50%;width:44px;height:44px;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:2em;transition:background 0.18s;position:relative;">
          <span id="spell-air-icon" style="color:#90ee90;">üí®</span>
        </button>
        <span id="spell-status-label" style="color:#aaa;font-size:1.08em;"></span>
      </div>
    `;
    // Insert below prayer panel
    const prayerPanel = document.getElementById('prayer-panel');
    if (prayerPanel && prayerPanel.parentNode) {
      prayerPanel.parentNode.insertBefore(spellbookPanel, prayerPanel.nextSibling);
    }
  }
})();

// 2. Spell logic: track which spell is active
let spellFireActive = false;
let spellWaterActive = false;
let spellAirActive = false;

// 3. Show/hide spellbook panel only for Mage
function updateSpellbookUI() {
  const panel = document.getElementById('spellbook-panel');
  if (!panel) return;
  if (player.class && player.class.toLowerCase() === "mage") {
    panel.style.display = '';
  } else {
    panel.style.display = 'none';
    spellFireActive = false;
    spellWaterActive = false;
    spellAirActive = false;
  }
  // Update spell icons and status
  panel.querySelector('h2').textContent = "Spellbook";
  const fireBtn = document.getElementById('spell-fire-btn');
  const waterBtn = document.getElementById('spell-water-btn');
  const airBtn = document.getElementById('spell-air-btn');
  const fireIcon = document.getElementById('spell-fire-icon');
  const waterIcon = document.getElementById('spell-water-icon');
  const airIcon = document.getElementById('spell-air-icon');
  const statusLabel = document.getElementById('spell-status-label');
  if (fireBtn && fireIcon) {
    fireBtn.style.background = spellFireActive ? '#e53935' : '#23252a';
    fireIcon.style.color = spellFireActive ? '#fff' : '#ff4444';
  }
  if (waterBtn && waterIcon) {
    waterBtn.style.background = spellWaterActive ? '#2196f3' : '#23252a';
    waterIcon.style.color = spellWaterActive ? '#fff' : '#2196f3';
  }
  if (airBtn && airIcon) {
    airBtn.style.background = spellAirActive ? '#90ee90' : '#23252a';
    airIcon.style.color = spellAirActive ? '#23252a' : '#90ee90';
  }
  if (statusLabel) {
    statusLabel.textContent =
      spellFireActive ? 'Fire Spell Active' :
      spellWaterActive ? 'Water Spell Active' :
      spellAirActive ? 'Air Spell Active' :
      'No Spell Active';
  }
}

// 5. Tooltip logic for spells
function showSpellTooltip(btnId, text) {
  let btn = document.getElementById(btnId);
  if (!btn) return;
    let tip = document.createElement('div');
    tip.className = 'spell-tooltip';
    tip.style.position = 'absolute';
    tip.style.left = '50%';
    tip.style.top = '110%';
    tip.style.transform = 'translateX(-50%)';
    tip.style.background = '#18191c';
    tip.style.color = '#eee';
    tip.style.padding = '8px 16px';
    tip.style.borderRadius = '8px';
    tip.style.border = '1px solid #444';
    tip.style.whiteSpace = 'nowrap';
    tip.style.fontSize = '1em';
    tip.style.boxShadow = '0 2px 10px #0007';
    tip.style.zIndex = '9999';
    tip.innerHTML = text;
    btn.appendChild(tip);
    btn._spellTip = tip;
  }
  function hideSpellTooltip(btnId) {
    let btn = document.getElementById(btnId);
    if (btn && btn._spellTip) {
      btn.removeChild(btn._spellTip);
      btn._spellTip = null;
    }
  }
  // Attach hover logic for tooltips
  const fireBtn = document.getElementById('spell-fire-btn');
  const waterBtn = document.getElementById('spell-water-btn');
  const airBtn = document.getElementById('spell-air-btn');
  if (fireBtn) {
    fireBtn.onmouseenter = function() {
      showSpellTooltip('spell-fire-btn', `Requires <b>1 Fire Rune</b> & <b>1 Air Rune</b>`);
    };
    fireBtn.onmouseleave = function() {
      hideSpellTooltip('spell-fire-btn');
    };
    fireBtn.onclick = function() {
      if (!inCombat || !currentEnemy) {
        logMsg(`<span style="color:#ff4444;">You must be in combat to activate this spell!</span>`);
        return;
      }
      spellFireActive = !spellFireActive;
      spellWaterActive = false;
      spellAirActive = false;
      updateSpellbookUI();
    };
  }
  if (waterBtn) {
    waterBtn.onmouseenter = function() {
      showSpellTooltip('spell-water-btn', `Requires <b>1 Water Rune</b> & <b>1 Air Rune</b>`);
    };
    waterBtn.onmouseleave = function() {
      hideSpellTooltip('spell-water-btn');
    };
    waterBtn.onclick = function() {
      if (!inCombat || !currentEnemy) {
        logMsg(`<span style="color:#ff4444;">You must be in combat to activate this spell!</span>`);
        return;
      }
      spellWaterActive = !spellWaterActive;
      spellFireActive = false;
      spellAirActive = false;
      updateSpellbookUI();
    };
  }
  if (airBtn) {
    airBtn.onmouseenter = function() {
      showSpellTooltip('spell-air-btn', `Requires <b>1 Air Rune</b>`);
    };
    airBtn.onmouseleave = function() {
      hideSpellTooltip('spell-air-btn');
    };
    airBtn.onclick = function() {
      if (!inCombat || !currentEnemy) {
        logMsg(`<span style="color:#ff4444;">You must be in combat to activate this spell!</span>`);
        return;
      }
      spellAirActive = !spellAirActive;
      spellFireActive = false;
      spellWaterActive = false;
      updateSpellbookUI();
    };
  }

window.addEventListener('DOMContentLoaded', updateSpellbookUI);
const usernameSubmitButton2 = document.getElementById('username-submit');
if (usernameSubmitButton2) {
  usernameSubmitButton2.addEventListener('click', updateSpellbookUI);
}

// 4. Patch attackEnemy to use spell if mage and spell is active, consume runes, apply effect
const origAttackEnemySpell = window.attackEnemy;
window.attackEnemy = function() {
  // Only for Mage class and if a spell is active
  if (player.class && player.class.toLowerCase() === "mage" && (spellFireActive || spellWaterActive || spellAirActive)) {
    // Ensure spells only work in combat
    if (!inCombat || !currentEnemy) {
      logMsg(`<span style="color:#ff4444;">You must be in combat to cast spells!</span>`);
      spellFireActive = false;
      spellWaterActive = false;
      spellAirActive = false;
      updateSpellbookUI();
      return;
    }
    // Helper: find and consume rune from inventory
    function consumeRune(runeName) {
      for (let i = 0; i < player.inventory.length; i++) {
        let item = player.inventory[i];
        if (item.type === "material" && item.name === runeName && item.count > 0) {
          item.count -= 1;
          if (item.count <= 0) player.inventory.splice(i, 1);
          return true;
        }
      }
      return false;
    }
    // Fire Spell: requires 1 Fire Rune & 1 Air Rune
    if (spellFireActive) {
      let hasFire = false, hasAir = false;
      for (let item of player.inventory) {
        if (item.type === "material" && item.name === "Fire Rune" && item.count > 0) hasFire = true;
        if (item.type === "material" && item.name === "Air Rune" && item.count > 0) hasAir = true;
      }
      if (!hasFire || !hasAir) {
        logMsg(`<span style="color:#ff4444;">Not enough runes for Fire Spell!</span>`);
        spellFireActive = false;
        updateSpellbookUI();
        return;
      }
      consumeRune("Fire Rune");
      consumeRune("Air Rune");
      let hit = Math.floor(Math.random() * 21) + 10; // 10-30 fire damage
      currentEnemy.health = Math.max(0, currentEnemy.health - hit);
      showHitsplat(document.getElementById('enemy-image'), hit, true);
      logMsg(`<span style="color:#ff4444;font-weight:bold;">You cast Fire Spell! Dealt <b>${hit}</b> fire damage!</span>`);
      renderEnemyEncounter();
      if (currentEnemy.health <= 0) {
        let goldDrop = Math.floor(Math.random() * 51);
        player.gold += goldDrop;
        let randomItem = JSON.parse(JSON.stringify(items[Math.floor(Math.random() * items.length)]));
        addItem(randomItem);
        let goldMsg = goldDrop > 0 ? ` <span style="color:gold;">+${goldDrop} Gold</span>` : '';
        logMsg(`<span style="color:#90ee90"><b>You defeated the ${currentEnemy.name}!</b></span> +${currentEnemy.xp} XP${goldMsg} and found ${randomItem.name}`);
        player.experience += currentEnemy.xp;
        checkLevelUp();
        clearEnemy();
        renderPlayerStats();
        updateSpellbookUI();
        return;
      }
      setTimeout(()=>{ enemyAttack(); }, 700);
      updateSpellbookUI();
      renderBagInv();
      return;
    }
    // Water Spell: requires 1 Water Rune & 1 Air Rune
    if (spellWaterActive) {
      let hasWater = false, hasAir = false;
      for (let item of player.inventory) {
        if (item.type === "material" && item.name === "Water Rune" && item.count > 0) hasWater = true;
        if (item.type === "material" && item.name === "Air Rune" && item.count > 0) hasAir = true;
      }
      if (!hasWater || !hasAir) {
        logMsg(`<span style="color:#2196f3;">Not enough runes for Water Spell!</span>`);
        spellWaterActive = false;
        updateSpellbookUI();
        return;
      }
      consumeRune("Water Rune");
      consumeRune("Air Rune");
      let hit = Math.floor(Math.random() * 16) + 10; // 10-25 water damage
      currentEnemy.health = Math.max(0, currentEnemy.health - hit);
      showHitsplat(document.getElementById('enemy-image'), hit, true);
      logMsg(`<span style="color:#2196f3;font-weight:bold;">You cast Water Spell! Dealt <b>${hit}</b> water damage!</span>`);
      renderEnemyEncounter();
      if (currentEnemy.health <= 0) {
        let goldDrop = Math.floor(Math.random() * 51);
        player.gold += goldDrop;
        let randomItem = JSON.parse(JSON.stringify(items[Math.floor(Math.random() * items.length)]));
        addItem(randomItem);
        let goldMsg = goldDrop > 0 ? ` <span style="color:gold;">+${goldDrop} Gold</span>` : '';
        logMsg(`<span style="color:#90ee90"><b>You defeated the ${currentEnemy.name}!</b></span> +${currentEnemy.xp} XP${goldMsg} and found ${randomItem.name}`);
        player.experience += currentEnemy.xp;
        checkLevelUp();
        clearEnemy();
        renderPlayerStats();
        updateSpellbookUI();
        return;
      }
      setTimeout(()=>{ enemyAttack(); }, 700);
      updateSpellbookUI();
      renderBagInv();
      return;
    }
    // Air Spell: requires 1 Air Rune
    if (spellAirActive) {
      let hasAir = false;
      for (let item of player.inventory) {
        if (item.type === "material" && item.name === "Air Rune" && item.count > 0) hasAir = true;
      }
      if (!hasAir) {
        logMsg(`<span style="color:#90ee90;">Not enough runes for Air Spell!</span>`);
        spellAirActive = false;
        updateSpellbookUI();
        return;
      }
      consumeRune("Air Rune");
      let hit = Math.floor(Math.random() * 11) + 5; // 5-15 air damage
      currentEnemy.health = Math.max(0, currentEnemy.health - hit);
      showHitsplat(document.getElementById('enemy-image'), hit, true);
      logMsg(`<span style="color:#90ee90;font-weight:bold;">You cast Air Spell! Dealt <b>${hit}</b> air damage!</span>`);
      renderEnemyEncounter();
      if (currentEnemy.health <= 0) {
        let goldDrop = Math.floor(Math.random() * 51);
        player.gold += goldDrop;
        let randomItem = JSON.parse(JSON.stringify(items[Math.floor(Math.random() * items.length)]));
        addItem(randomItem);
        let goldMsg = goldDrop > 0 ? ` <span style="color:gold;">+${goldDrop} Gold</span>` : '';
        logMsg(`<span style="color:#90ee90"><b>You defeated the ${currentEnemy.name}!</b></span> +${currentEnemy.xp} XP${goldMsg} and found ${randomItem.name}`);
        player.experience += currentEnemy.xp;
        checkLevelUp();
        clearEnemy();
        renderPlayerStats();
        updateSpellbookUI();
        return;
      }
      setTimeout(()=>{ enemyAttack(); }, 700);
      updateSpellbookUI();
      renderBagInv();
      return;
    }
  }
  // Otherwise, normal attack logic
  origAttackEnemySpell && origAttackEnemySpell();
  updateSpellbookUI();
};

// 5. Update spellbook UI after bag/inventory changes
const origRenderBagInvSpell = renderBagInv;
renderBagInv = function() {
  origRenderBagInvSpell();
  updateSpellbookUI();
};

// 6. Add spellbook panel styles
(function() {
  const style = document.createElement('style');
  style.textContent = `
    #spellbook-panel { margin-top:8px; }
    #spell-fire-btn, #spell-water-btn, #spell-air-btn { transition:background 0.18s; }
    #spell-fire-btn:active, #spell-water-btn:active, #spell-air-btn:active { box-shadow:0 0 8px #ffba3a; }
    #spell-fire-icon, #spell-water-icon, #spell-air-icon { transition:color 0.18s; }
    .spell-tooltip {
      pointer-events: none;
      opacity: 0.98;
      transition: opacity 0.12s;
    }
  `;
  document.head.appendChild(style);
})();
/*
  --- CLASS-SPECIFIC ITEM LOGIC ---
  Only allow equipping weapons/armors that match the player's class.
  Swords: Melee, Bows: Ranger, Staffs/Wands: Mage.
  Armor: Melee (Armor, Helmet, Shield), Ranger (Cloak, Boots, Hat), Mage (Robe, Amulet, Ring).
*/

// Helper: check if item is class-specific and matches player class
function isClassAllowed(item) {
  if (!player.class) return true; // If no class, allow all
  const cls = player.class.toLowerCase();
  // Weapon logic
  if (item.type === "weapon") {
    if (item.name && item.name.toLowerCase().includes("sword")) return cls === "melee";
    if (item.isBow || (item.name && item.name.toLowerCase().includes("bow"))) return cls === "ranger";
    if (item.name && (item.name.toLowerCase().includes("staff") || item.name.toLowerCase().includes("wand"))) return cls === "mage";
    // Other weapons: allow all classes
    return true;
  }
  // Armor logic
  if (item.type === "armor" || item.type === "chestplate") {
    if (item.name && item.name.toLowerCase().includes("robe")) return cls === "mage";
    return cls === "melee";
  }
  if (item.type === "helmet") {
    if (item.name && item.name.toLowerCase().includes("hat")) return cls === "ranger";
    return cls === "melee";
  }
  if (item.type === "shield") return cls === "melee";
  if (item.type === "cloak" || item.type === "cape") return cls === "ranger";
  if (item.type === "amulet" || item.type === "ring") return cls === "mage";
  if (item.type === "boots") {
    if (item.name && item.name.toLowerCase().includes("boots")) return cls === "ranger";
    return cls === "melee";
  }
  // Gloves: allow all
  // Arrows: ranger only
  if (item.type === "arrows") return cls === "ranger";
  // Materials, potions, consumables: allow all
  return true;
}

// Patch isEquipable to check class
const origIsEquipable = isEquipable;
isEquipable = function(item) {
  return origIsEquipable(item) && isClassAllowed(item);
};

// Patch equipItem and equipBagItem to enforce class restriction
const origEquipItem = equipItem;
equipItem = function(idx) {
  let item = player.inventory[idx];
  if (!isClassAllowed(item)) {
    logMsg(`<span style="color:#ff4444;">${item.name} cannot be equipped by your class (${player.class}).</span>`);
    return;
  }
  origEquipItem(idx);
};

const origEquipBagItem = equipBagItem;
equipBagItem = function(idx) {
  let item = player.bag[idx];
  if (!isClassAllowed(item)) {
    logMsg(`<span style="color:#ff4444;">${item.name} cannot be equipped by your class (${player.class}).</span>`);
    return;
  }
  origEquipBagItem(idx);
};

// Patch renderBagInv to show "Not for your class" on restricted items
const origRenderBagInvClass = renderBagInv;
renderBagInv = function() {
  origRenderBagInvClass();
  let itemsArr = baginvTab === "inventory" ? player.inventory : player.bag;
  const cards = document.querySelectorAll('#baginv-content .item-card');
  cards.forEach((card, idx) => {
    const item = itemsArr[idx];
    if (item && !isClassAllowed(item) && isEquipable(item)) {
      // Add warning
      let warn = card.querySelector('.class-restrict-warning');
      if (!warn) {
        warn = document.createElement('div');
        warn.className = 'class-restrict-warning';
        warn.style = 'color:#ff4444;font-size:0.95em;margin-top:4px;text-align:center;';
        warn.textContent = `Not for your class`;
        card.appendChild(warn);
      }
      // Disable Equip button
      const equipBtn = card.querySelector('.item-action-btn');
      if (equipBtn) equipBtn.disabled = true;
    }
  });
};
</script>
